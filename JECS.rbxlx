<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="327">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<float name="AirTurbulenceIntensity">0</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AuthorityMode">1</token>
			<token name="AvatarUnificationMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBX83D9D355499A4415855229096E28D3D9</Ref>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<bool name="FallHeightEnabled">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="LuauTypeCheckMode">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<token name="MoverConstraintRootBehavior">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PathfindingUseImprovedSearch">0</token>
			<token name="PhysicsImprovedSleep">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SandboxedInstanceMode">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<token name="TouchEventsUseCollisionGroups">0</token>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000002</UniqueId>
			<token name="UseImprovedModelLod">0</token>
			<token name="UseNewLuauTypeSolver">0</token>
			<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX83D9D355499A4415855229096E28D3D9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>-5.97012329</X>
					<Y>18.2091446</Y>
					<Z>20.6473465</Z>
					<R00>0.973960876</R00>
					<R01>0.128946513</R01>
					<R02>-0.186475173</R02>
					<R10>-0</R10>
					<R11>0.822505176</R11>
					<R12>0.568757653</R12>
					<R20>0.226716101</R20>
					<R21>-0.553947687</R21>
					<R22>0.801087856</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>0</X>
					<Y>0</Y>
					<Z>-5</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000036f</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Part" referent="328">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284636770</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d8</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXC41680132FCF4B66B0A1E3D8A2BA2288">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AudioCanCollide">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d9</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="TimerService" referent="RBXE17329675F2B4B019B18E1617BE3249A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000327</UniqueId>
		</Properties>
	</Item>
	<Item class="SoundService" referent="317">
		<Properties>
			<bool name="AcousticSimulationEnabled">false</bool>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AudioApiByDefault">0</token>
			<token name="AudioPlayerVolumeFix">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="CharacterSoundsUseNewApi">0</token>
			<token name="DefaultListenerLocation">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsNewExpForAudioApiByDefault">false</bool>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000328</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX284DC675F09244668BBDBD402806D325">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000334</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX32AB640F6A8744FC998256324A464E30">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000335</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX029325074001488EA9DF6E96CD047026">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000336</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX8216E538F6344EC59B59E4D1C8F5A354">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsAutoMigrated">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000033c</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX89DE6DEEA264415D809852703F1E34AF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BanningEnabled">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000033e</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBXEAF4B31E006E4DB9BE9D4DE901E4E6B6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000341</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBXD24B8E7DD2C749B6A51319344D7F5642">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000343</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX70D0C3C6799242B1B060A36FA0A07712">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000344</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX4758A282627643B293B035E677E4AE31">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="HasSeenDeprecationDialog">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsLegacyChatDisabled">false</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000345</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBXD3339C490098413C9517AE9AD0757835">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004db</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXDA0D32354D1D45C0AEF70CCCCAA29444">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004dc</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXC6652F0A07004042872DF918C9F5EEBA">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/Montserrat-Medium.ttf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004dd</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
		<Item class="ChannelTabsConfiguration" referent="RBXDAE7AE723E85425DAAEBBB455811D51B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">false</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/BuilderSans.json</url></Family>
					<Weight>700</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/BuilderSans-Bold.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Color3 name="HoverBackgroundColor3">
					<R>0.490196079</R>
					<G>0.490196079</G>
					<B>0.490196079</B>
				</Color3>
				<string name="Name">ChannelTabsConfiguration</string>
				<Color3 name="SelectedTabTextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>0.686274529</R>
					<G>0.686274529</G>
					<B>0.686274529</B>
				</Color3>
				<int64 name="TextSize">18</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">1</double>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004de</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBXC600199836064BAAA36A116EE92D9AB0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000347</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX0BDEFBDAB69B422E85169DED0F164E7D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<int name="TextElongationFactor">0</int>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000348</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXF14D9B5DACED488895F36ED17C2669EC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000034c</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="318">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_SerializedRollout">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="ClassicDeath">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<bool name="RagdollDeath">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000034e</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="319">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d0</UniqueId>
			</Properties>
			<Item class="LocalScript" referent="320">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">main</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{8B32FC89-81F6-4FEC-B33F-056AB971B7D1}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local start = require(ReplicatedStorage.start)

start(script.Parent:WaitForChild("systems"):GetChildren())
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d1</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="321">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">systems</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d2</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="322">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lol</string>
						<string name="ScriptGuid">{044A5A0B-4069-4BEE-91A0-4724B6E62177}</string>
						<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local jecs = require(ReplicatedStorage.ecs)
local __ = jecs.Wildcard
local std = ReplicatedStorage.std

local world = require(std.world)

local Position = world:component() :: jecs.Entity<vector>
local Previous = jecs.Rest
local pre = jecs.pair(Position, Previous)

local added = world
	:query(Position)
	:without(pre)
	:cached()
local changed = world
	:query(Position, pre)
	:cached()
local removed = world
	:query(pre)
	:without(Position)
	:cached()

local children = {}
for i = 1, 10 do
	local e = world:entity()
	world:set(e, Position, vector.create(i, i, i))
	table.insert(children, e)
end
local function flip()
	return math.random() > 0.5
end
local function system()
	for i, child in children do
		world:set(child, Position, vector.create(i,i,i))
	end
	for e, p in added:iter() do
		world:set(e, pre, p)
	end
	for i, child in children do
		if flip() then
			world:set(child, Position, vector.create(i + 1, i + 1, i + 1))
		end
	end
	for e, new, old in changed:iter() do
		if new ~= old then
			world:set(e, pre, new)
		end
	end

	for i, child in children do
		world:remove(child, Position)
	end

	for e in removed:iter() do
		world:remove(e, pre)
	end
end
local scheduler = require(std.scheduler)

scheduler.SYSTEM(system)

return 0
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d3</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="323">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lol2</string>
						<string name="ScriptGuid">{D2EBD1BA-D024-4618-93E9-3BC6DF7EA927}</string>
						<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local jecs = require(ReplicatedStorage.ecs)
local __ = jecs.Wildcard
local std = ReplicatedStorage.std

local world = require(std.world)

local Position = world:component() :: jecs.Entity<vector>
local Previous = jecs.Rest
local pre = jecs.pair(Position, Previous)

local added = world
	:query(Position)
	:without(pre)
	:cached()
local changed = world
	:query(Position, pre)
	:cached()
local removed = world
	:query(pre)
	:without(Position)
	:cached()

local children = {}
for i = 1, 10 do
	local e = world:entity()
	world:set(e, Position, vector.create(i, i, i))
	table.insert(children, e)
end
local function flip()
	return math.random() > 0.5
end
local entity_index = world.entity_index
local function copy(archetypes, id)
	for _, archetype in archetypes do

		local to = jecs.archetype_traverse_add(world, pre, archetype)
		local columns = to.columns
		local records = to.records
		local old = columns[records[pre]]
		local new =	columns[records[id]]

		if to ~= archetype then
			for _, entity in archetype.entities do
				local r = jecs.entity_index_try_get_fast(entity_index, entity)
				jecs.entity_move(entity_index, entity, r, to)
			end
		end

		table.move(new, 1, #new, 1, old)

	end
end
local function system2()
	for i, child in children do
		world:set(child, Position, vector.create(i,i,i))
	end
	for e, p in added:iter() do
	end
	copy(added:archetypes(), Position)
	for i, child in children do
		if flip() then
			world:set(child, Position, vector.create(i + 1, i + 1, i + 1))
		end
	end

	for e, new, old in changed:iter() do
		if new ~= old then
		end
	end

	copy(changed:archetypes(), Position)

	for i, child in children do
		world:remove(child, Position)
	end

	for e in removed:iter() do
		world:remove(e, pre)
	end
end
local scheduler = require(std.scheduler)


return 0
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d4</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="324">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">move</string>
						<string name="ScriptGuid">{8BE3AF2D-171E-4944-81E3-C55BFF3ECB22}</string>
						<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local blink = require(ReplicatedStorage.net)
local std = ReplicatedStorage.std
local world = require(std.world)
local ref = require(std.ref)

local cts = require(std.components)
local Model = cts.Model
local Transform = cts.Transform

-- Query: entities that have a Roblox model and a Transform
local moved_models = world:query(Model, Transform):cached()

-- ---------- Smooth interpolation state ----------
-- For each entity we keep a small state machine:
-- prev -> next over 'span' seconds, with alpha advancing each frame.
type Smooth = {
    prev: CFrame,
    next: CFrame,
    rendered: CFrame,  -- last frame’s output
    alpha: number,     -- [0..1]
    span: number,      -- seconds to complete the blend
}

local smooth: { [number]: Smooth } = {}

-- Pick a blend time ~ network period (12 Hz ~= 0.083s).
-- A bit longer is nicer; tweak to taste.
local TARGET_SPAN = 0.10   -- 100 ms
local MIN_SPAN    = 1/120  -- never 0; avoids huge alpha steps
local MAX_SPAN    = 0.25   -- don't smear too long

local function beginBlend(e: number, serverCF: CFrame)
    local s = smooth[e]
    if not s then
        -- first time: start at server pose (no pop)
        s = {
            prev = serverCF,
            next = serverCF,
            rendered = serverCF,
            alpha = 1,
            span = TARGET_SPAN,
        }
        smooth[e] = s
        return
    end

    -- Start new blend FROM what we actually rendered last frame (no rewind)
    local start = s.rendered
    s.prev = start
    s.next = serverCF

    -- Optional: dynamic span based on travel distance (longer jump = slightly longer smoothing)
    local dist = (s.next.Position - s.prev.Position).Magnitude
    local span = TARGET_SPAN
    if dist > 10 then
        span = math.clamp(TARGET_SPAN * 1.5, MIN_SPAN, MAX_SPAN)
    end

    s.span  = math.clamp(span, MIN_SPAN, MAX_SPAN)
    s.alpha = 0
end

local function stepBlend(e: number, dt: number): CFrame?
    local s = smooth[e]
    if not s then return nil end
    -- advance
    if s.alpha < 1 then
        -- normalize dt by span, clamp so big hitches don’t overshoot badly
        local da = math.clamp(dt / s.span, 0, 0.5)
        s.alpha = math.min(1, s.alpha + da)
    end
    -- CFrame:Lerp blends pos+rot (slerp-like)
    local out = s.prev:Lerp(s.next, s.alpha)
    s.rendered = out
    return out
end

-- Helper: ensure a Transform component exists with a .new CFrame
local function ensureTransform(e: number): {new: CFrame}
    local t = world:get(e, Transform)
    if t == nil then
        -- initialize with identity if missing (should be rare)
        t = { new = CFrame.new() }
        world:set(e, Transform, t)
    elseif t.new == nil then
        -- normalize shape if someone set Transform = CFrame by mistake
        t = { new = (t :: any) :: CFrame }
        world:set(e, Transform, t)
    end
    return t :: {new: CFrame}
end

-- --- Network handlers (register once) ---

-- Delta updates: [{ id: number, dp: Vector3 }, ...]
blink.UpdateTransformDelta.On(function(payload)
    for _, entry in payload do
        local e = ref("server-" .. tostring(entry.id))

        -- authoritatively advance ECS Transform
        local t = ensureTransform(e)
        t.new = t.new + entry.dp

        -- start a smooth blend FROM current rendered TO new server pose
        beginBlend(e, t.new)
    end
end)

-- Full updates: [{ id: number, dp: Vector3 }, ...]
blink.UpdateTransformFull.On(function(payload)
    for _, entry in payload do
        local e = ref("server-" .. tostring(entry.id))
        local cf = if entry.r
            then CFrame.new(entry.dp) * CFrame.Angles(0, entry.r, 0)
            else CFrame.new(entry.dp)

        local t = ensureTransform(e)
        t.new = cf

        beginBlend(e, cf)
    end
end)

-- ---------- 60 Hz presentation ----------
local RENDER_HZ = 60
local RENDER_DT = 1 / RENDER_HZ
local acc = 0

local function present(dt: number)
    acc += dt
    if acc < RENDER_DT then return end
    acc = 0

    for e, model, _ in moved_models do
        local m = (model :: Model)
        if m and m.PrimaryPart then
            local cf = stepBlend(e, RENDER_DT)
            if cf then
                m.PrimaryPart.CFrame = cf
            end
        end
    end
end

local scheduler = require(std.scheduler)
scheduler.SYSTEM(present)

return 0
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d5</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="325">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">syncMobs</string>
						<string name="ScriptGuid">{CD97F010-C9E3-467A-801F-9DF9BF5EC53B}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local blink = require(ReplicatedStorage.net)
local std = ReplicatedStorage.std
local ref = require(std.ref)
local world = require(std.world)
local cts = require(std.components)
local spawned = {}

local pool = {}

local MobsFolder = Instance.new("Folder")
MobsFolder.Name = "Mobs"
MobsFolder.Parent = workspace

local function tweenMob(mob: Model, size: number)
	if not mob.PrimaryPart then return end

	local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Linear)
	local tween = game:GetService("TweenService"):Create(mob.PrimaryPart, tweenInfo, {Size = Vector3.new(1,1,1) * size})
	tween:Play()
	
end

local function syncMobs()
	for _, id, cf, Size in blink.SpawnMob.Iter() do
		if not spawned[id] then

			local part = Instance.new("Part")
			part.Shape = Enum.PartType.Ball
			part.Material = Enum.Material.Neon
			part.Color = Color3.fromRGB(math.random(0,255), math.random(0,255), math.random(0,255))
			part.Anchored = true
			part.CastShadow = false
			part.CanCollide = false
			part.CanQuery = false
			part.CanTouch = false
			local model = Instance.new("Model")
			model.PrimaryPart = part
			part.Parent = model
			model.Name = "Mob-" .. tostring(id)
			model.PrimaryPart.CFrame = cf
			model.Parent = MobsFolder
			part.Size = Vector3.new(.1,.1,.1)
			tweenMob(model, Size)

			local e = ref("server-" .. tostring(id))
			world:set(e, cts.Transform, { new = cf, old = cf })
			world:set(e, cts.Model, model)
			world:add(e, cts.Mob)

			spawned[id] = true
		end
	end
end

local scheduler = require(std.scheduler)
scheduler.SYSTEM(syncMobs)

return 0

]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d6</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="326">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">test</string>
						<string name="ScriptGuid">{8563F526-C4B1-4FC3-B017-87B79FC25E69}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local std = ReplicatedStorage.std
local world = require(std.world)

local A = world:component()
local B = world:component()
local C = world:component()
local D = world:component()

local function flip() 
    return math.random() >= 0.15
end

for i = 1, 2^8 do 
    local e = world:entity()
    if flip() then 
        world:set(e, A, true)
    end
    if flip() then 
        world:set(e, B, true)
    end
    if flip() then 
        world:set(e, C, true)
    end
    if flip() then 
        world:set(e, D, true)
    end
end

local function uncached() 
    for _ in world:query(A, B, C, D) do 
    end
end

local q = world:query(A, B, C, D):cached()
local function cached() 
    for _ in q do 
    end
end

local scheduler = require(std.scheduler)
scheduler.SYSTEM(uncached)
scheduler.SYSTEM(cached)
return 0]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004d7</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX57C4F738B3F049308BEF3122BA2F233E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004da</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX471D540B3DCD4F4DA66CB23D6BC2736C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000034f</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX47EFD0995CDA4C6E814581DFFAF57F25">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<Ref name="StudioDefaultStyleSheet">null</Ref>
			<Ref name="StudioInsertWidgetLayerCollectorAutoLinkStyleSheet">null</Ref>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000350</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX1DE1DF8AD7DE4579AE800D25CFFA067C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000352</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX79C3308ACC4B41FAA0036AB83A31F81D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000356</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXB0B1C985763C4A48AE4CCE299A742F48">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000358</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX36299164539446F686BFBF1C6785F544">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000359</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX57127C7F1229442C9F70C359987FF5B9">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000035c</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXAA985C540D35487EBCAA6A7689D95B1C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000025ac</UniqueId>
				<string name="Value">{2A30702E-9563-45F1-9119-1DF634078867}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX8BA38AA28DD84C0EB4CCF066FDA203B0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000035d</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXB666CE88A0134D30A3CC90353DC1C684">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000035e</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX98A7D6BB70D64E298ACE0AADFA94621B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000035f</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX828732E7CA334178B5A0C1D15BD247D4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000360</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXB6AB2EBD6B6145A5BFD92E17CCDC5068">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ControllerModels">1</token>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LaserPointer">1</token>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000364</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXA0D10D9C4EE34FCF902D0ADEE440146D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000365</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX69B0F5290B9945E5B9CAC8B725A2762B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000366</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX0421EF626D7B48D68B537C0CB7B21AF6">
		<Properties>
			<bool name="AllowInsertFreeAssets">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000367</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX0CCB5C115B1242E5945EA7D7C600C222">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000368</UniqueId>
		</Properties>
	</Item>
	<Item class="AvatarSettings" referent="RBX091438532ADC4630AAEB0E35620B56C6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AvatarSettings</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000036e</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBXF3AA9703573249FC955BC50C9CD0EC70">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000376</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXFF9EBF6B22A24C63BC7DE8D9FC0EA2ED">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000377</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000378</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ecs_init</string>
				<string name="ScriptGuid">{1F64D17B-63BE-454E-A13A-8E267C110FE9}</string>
				<ProtectedString name="Source"><![CDATA[_G.JECS_DEBUG = true
_G.JECS_HI_COMPONENT_ID = 32
require(game:GetService("ReplicatedStorage").ecs)
return
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000395</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">start</string>
				<string name="ScriptGuid">{00556888-8A53-448A-B9DC-E07E0B8E2121}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local jabby = require(ReplicatedStorage.Packages.jabby)
local std = ReplicatedStorage.std
local scheduler = require(std.scheduler)
local world = require(std.world)

local function start(modules)
	for _, module in modules do
		require(module)
	end
	local events = scheduler.COLLECT()
	scheduler.BEGIN(events)
	jabby.set_check_function(function(player)
		return true
	end)
	if RunService:IsClient() then
		local player = game:GetService("Players").LocalPlayer
		local playergui = player:WaitForChild("PlayerGui")
		local client = jabby.obtain_client()
		UserInputService.InputBegan:Connect(function(input)
			if input.KeyCode == Enum.KeyCode.F4 then
				local home = playergui:FindFirstChild("Home")
				if home then
					home:Destroy()
				end
				client.spawn_app(client.apps.home)
			end
		end)
	end
end

return start
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000396</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">std</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000397</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">bt</string>
					<string name="ScriptGuid">{C728CE09-5485-4521-A997-BFD6FB2FB7C4}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native

-- original author @centau

local FAILURE = -1 
local RUNNING = 0 
local SUCCESS = 1 

local function SEQUENCE(nodes)
	return function(...)
		for _, node in nodes do
			local status = node(...)
			if status <= RUNNING  then
				return status
			end
		end
		return SUCCESS
	end
end

local function FALLBACK(nodes)
	return function(...)
		for _, node in nodes do
			local status = node(...)
			if status > FAILURE then
				return status
			end
		end
		return FAILURE
	end
end

local bt = {
	SEQUENCE = SEQUENCE,
	FALLBACK = FALLBACK,
	RUNNING = RUNNING,
}

return bt
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000398</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">collect</string>
					<string name="ScriptGuid">{997781AE-3B0D-4507-88B8-0B377A4AF409}</string>
					<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	local signal = Signal.new() :: Signal.Signal<string, string>
	local events = collect(signal)
	local function system(world)
		for id, str1, str2 in events do
			--
		end
	end
]]

--[[
original author by @memorycode

MIT License

Copyright (c) 2024 Michael

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

type Signal<T...> = { [any]: any }
local function collect<T...>(event: Signal<T...>)
	local storage = {}
	local mt = {}
	local iter = function()
		local n = #storage
		return function()
			if n <= 0 then
				mt.__iter = nil
				return nil
			end

			n -= 1
			return n + 1, unpack(table.remove(storage, 1) :: any)
		end
	end

	local disconnect = event:Connect(function(...)
		table.insert(storage, { ... })
		mt.__iter = iter
	end)

	setmetatable(storage, mt)
	return (storage :: any) :: () -> (number, T...), function()
		disconnect()
	end
end

return collect
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000399</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">components</string>
					<string name="ScriptGuid">{21A79BE8-1A44-4019-9FB5-6B76DA43C3FD}</string>
					<ProtectedString name="Source"><![CDATA[local jecs = require(game:GetService("ReplicatedStorage").ecs)
local world = require(script.Parent.world)

type Entity<T = nil> = jecs.Entity<T>
local components: {
	Character: Entity<Model>,
	Mob: Entity,
	Model: Entity<Model>,
	Player: Entity,
	Target: Entity,
	Transform: Entity<{ new: CFrame, old: CFrame }>,
	Speed: Entity<number>,
	Velocity: Entity<Vector3>,
	Previous: Entity,
	Size: Entity<number>,

	--Physics)
	Gravity: Entity<{ vy: number, enabled: boolean? }>,
    Knockback: Entity<{ force: Vector3, remaining: number }>,
	StaticCollider: Entity<{size:Vector3, center: Vector3?}>,
    Collider: Entity<{ radius: number }>,
    Grounded: Entity,

	 -- Behavior Components
    StateMachine: Entity<{ current: string, states: {[string]: any} }>,
    ChaseTarget: Entity<{ target: number?, range: number, loseRange: number }>,
    Patrol: Entity<{ points: {Vector3}, current: number, wait: number }>,
	
    Wander: Entity<{ center: Vector3, radius: number, nextMove: number }>,
    Aggressive: Entity<{ attackRange: number, damage: number, cooldown: number }>,
    Flee: Entity<{ from: number?, fleeRange: number, speed: number }>,
    
    -- Timers/Conditions
    Timer: Entity<{ remaining: number }>,
    Cooldown: Entity<{ remaining: number }>,
	PendingMovements: Entity<{ [number]:{ id:number, dp: Vector3 } }>,
	PendingStateChanges: Entity<{ [number]:{ id:number,  state: string } }>,
} = {
		Character = world:component(),
		Mob = world:component(),
		Model = world:component(),
		Player = world:component(),
		Target = world:component(),
		Transform = world:component(),
		Speed = world:component(),
		Velocity = world:component(),
		Previous = world:component(),
		Size = world:component(),

		Gravity = world:component(),
		Knockback = world:component(),
		Collider = world:component(),
		StaticCollider = world:component(),
		Grounded = world:component(),

		StateMachine = world:component(),
		ChaseTarget = world:component(),
		Patrol = world:component(),
		Wander = world:component(),
		Aggressive = world:component(),
		Flee = world:component(),
		Timer = world:component(),
		Cooldown = world:component(),
		PendingMovements = world:component(),
		PendingStateChanges = world:component(),
	}

for name, component in components :: {[string]: jecs.Entity} do 
	world:set(component, jecs.Name, name)
end

return table.freeze(components)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039a</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">interval</string>
					<string name="ScriptGuid">{5746A79A-AA47-4F2E-8B89-2362DC7012BB}</string>
					<ProtectedString name="Source"><![CDATA[local function interval(s)
	local pin

	local function throttle()
		if not pin then
			pin = os.clock()
		end

		local elapsed = os.clock() - pin > s
		if elapsed then
			pin = os.clock()
		end

		return elapsed
	end
	return throttle
end

return interval]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039b</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">phases</string>
					<string name="ScriptGuid">{025517BF-E0B9-42F5-AA7A-33547F1E0983}</string>
					<ProtectedString name="Source"><![CDATA[local std = game:GetService("ReplicatedStorage").std
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local scheduler = require(std.scheduler)
local PHASE = scheduler.PHASE

-- ===== Phase Creation with Validation =====
local phases = {}

local function createPhase(name: string, config: { after: any?, event: RBXScriptSignal? }?)
    if phases[name] then
        warn(`Phase '{name}' already exists! Skipping...`)
        return phases[name]
    end
    
    local phase = PHASE(config or {})
    phases[name] = phase
    
    if _G.__DEV__ then  -- Only in development
        print(`✓ Created phase: {name}`)
    end
    
    return phase
end

-- ===== Core Phases (Never Change) =====
phases.Heartbeat = scheduler.phases.Heartbeat
phases.PreSimulation = scheduler.phases.PreSimulation  
phases.PreAnimation = scheduler.phases.PreAnimation
phases.PreRender = scheduler.phases.PreRender

-- ===== Player Events =====
createPhase("PlayerAdded", { event = Players.PlayerAdded })
createPhase("PlayerRemoved", { event = Players.PlayerRemoving })

-- ===== Game Phases (Dependency Chain) =====
-- This order is the contract - changing it breaks everything
createPhase("EarlyUpdate", { after = phases.PreSimulation })
createPhase("Input", { after = phases.EarlyUpdate })
createPhase("GameLogic", { after = phases.Input })

-- Physics chain (order matters!)
createPhase("Physics", { after = phases.GameLogic })
createPhase("PhysicsKnockback", { after = phases.Physics })
createPhase("PhysicsGravity", { after = phases.PhysicsKnockback })
createPhase("PhysicsTerrain", { after = phases.PhysicsGravity })
createPhase("PhysicsCollision", { after = phases.PhysicsTerrain })

-- AI chain (can run in parallel within same phase)
createPhase("AIBehavior", { after = phases.PhysicsCollision })
createPhase("AIStateMachine", { after = phases.AIBehavior })
createPhase("AIMovement", { after = phases.AIStateMachine })  -- Chase/Patrol/Wander run here
createPhase("AICombat", { after = phases.AIMovement })

-- Game Systems
createPhase("Combat", { after = phases.AICombat })
createPhase("Health", { after = phases.Combat })
createPhase("Inventory", { after = phases.Health })
createPhase("Economy", { after = phases.Inventory })

-- Networking (order matters for batching)
createPhase("NetworkDelta", { after = phases.Economy })
createPhase("NetworkReliable", { after = phases.NetworkDelta })

-- Cleanup
createPhase("Cleanup", { after = phases.NetworkReliable })
createPhase("LateUpdate", { after = phases.Cleanup })

-- Independent chains (run on Heartbeat)
createPhase("WorldManagement", { after = phases.Heartbeat })
createPhase("Spawning", { after = phases.WorldManagement })
createPhase("Environment", { after = phases.WorldManagement })  -- Weather, day/night

-- Client-only phases
if RunService:IsClient() then
    createPhase("ClientInput", { after = phases.PreRender })
    createPhase("ClientUI", { after = phases.ClientInput })
    createPhase("ClientEffects", { after = phases.ClientUI })
    createPhase("ClientSound", { after = phases.ClientEffects })
    createPhase("ClientRendering", { after = phases.ClientSound })
end

-- Debug phase (always last)
createPhase("Debug", { after = phases.LateUpdate })

-- Freeze to prevent accidental modification
table.freeze(phases)

-- ===== Validation & Documentation =====
if _G.__DEV__ then
    print("=== Phase Execution Order ===")
    print("PreSimulation → EarlyUpdate → Input → GameLogic")
    print("→ Physics → PhysicsKnockback → PhysicsGravity → PhysicsTerrain → PhysicsCollision")
    print("→ AIBehavior → AIStateMachine → AIMovement → AICombat") 
    print("→ Combat → Health → Inventory → Economy")
    print("→ NetworkDelta → NetworkReliable → Cleanup → LateUpdate → Debug")
    print("\nHeartbeat Branch: WorldManagement → Spawning/Environment")
    print("PreRender Branch (Client): ClientInput → ClientUI → ClientEffects → ClientSound → ClientRendering")
    print("========================")
end

return phases]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039c</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="10">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ref</string>
					<string name="ScriptGuid">{87563D56-372D-4BBF-A539-56E7F0B5A65C}</string>
					<ProtectedString name="Source"><![CDATA[local world = require(script.Parent.world)
local jecs = require(game:GetService("ReplicatedStorage").ecs)
local refs: {[any]: jecs.Entity} = {}

local function fini(key): () -> ()
	return function()
		refs[key] = nil
	end
end

local function noop() end

local function ref(key): (jecs.Entity, () -> ())
	if not key then
		return world:entity(), noop
	end
	local e = refs[key]
	if not e then
		e = world:entity()
		refs[key] = e
	end
	-- Cannot cache handles because they will get invalidated
	return e, fini(key)
end

return ref
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039d</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="11">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">scheduler</string>
					<string name="ScriptGuid">{24899957-8018-45CC-A99B-5245F297C799}</string>
					<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local jabby = require(ReplicatedStorage.Packages.jabby)
local jecs = require(ReplicatedStorage.ecs)
local pair = jecs.pair
local Name = jecs.Name

type World = jecs.World
type Entity<T = nil> = jecs.Entity<T>
type Id<T = unknown> = jecs.Id<T>

type System = {
	callback: (world: World) -> (),
	id: number,
}

type Systems = { System }

type Events = {
	RenderStepped: Systems,
	Heartbeat: Systems,
}

local world = require(script.Parent.world)
local Disabled = world:entity()
local System = world:component() :: Id<{ callback: (any) -> (), name: string}>
local DependsOn = world:entity()
local Event = world:component() :: Id<RBXScriptSignal>
local Phase = world:entity()

local PreRender = world:entity()
local Heartbeat = world:entity()
local PreAnimation = world:entity()
local PreSimulation = world:entity()

local sys: System
local dt: number

local jabby_scheduler = jabby.scheduler.create("Scheduler")

local a, b, c, d
local function run()
	local id = sys.id
	jabby_scheduler:run(id, sys.callback, a, b, c, d)
	return nil
end

world:add(Heartbeat, Phase)
world:set(Heartbeat, Event, RunService.Heartbeat)

world:add(PreSimulation, Phase)
world:set(PreSimulation, Event, RunService.PreSimulation)

world:add(PreAnimation, Phase)
world:set(PreAnimation, Event, RunService.PreAnimation)

jabby.register({
	applet = jabby.applets.world,
	name = "MyWorld",
	configuration = {
	world = world,
	},
})

jabby.register({
	applet = jabby.applets.scheduler,
	name = "Scheduler",
	configuration = {
		scheduler = jabby_scheduler,
	},
})

if RunService:IsClient() then 
	world:add(PreRender, Phase)
	world:set(PreRender, Event, (RunService :: RunService).PreRender)
end

local function begin(events: { [RBXScriptSignal]: Systems })
	local connections = {}
	for event, systems in events do
		if not event then
			continue
		end
		local event_name = tostring(event)
		connections[event] = event:Connect(function(...)
			debug.profilebegin(event_name)
			for _, s in systems do
				sys = s
				a, b, c, d = ...

				for _ in run do
					break
				end

			end
			debug.profileend()
		end)
	end
	return connections
end

local function scheduler_collect_systems_under_phase_recursive(systems, phase: Entity)
	local phase_name = world:get(phase, Name)
	for _, s in world:query(System):with(pair(DependsOn, phase)) do
		table.insert(systems, {
			id = jabby_scheduler:register_system({
				name = s.name,
				phase = phase_name,
			} :: any),
			callback = s.callback,
		})
	end
	for after in world:query(Phase):with(pair(DependsOn, phase)):iter() do
		scheduler_collect_systems_under_phase_recursive(systems, after)
	end
end

local function scheduler_collect_systems_under_event(event)
	local systems = {}
	scheduler_collect_systems_under_phase_recursive(systems, event)
	return systems
end

local function scheduler_collect_systems_all()
	local events = {}
	for phase, event in world:query(Event):with(Phase) do
		events[event] = scheduler_collect_systems_under_event(phase)
	end
	return events
end

local function scheduler_phase_new(d: { after: Entity?, event: RBXScriptSignal? })
	local phase = world:entity()
	world:add(phase, Phase)
	local after = d.after
	if after then 
		local dependency = pair(DependsOn, after :: Entity)
		world:add(phase, dependency)
	end
	
	local event = d.event
	if event then 
		world:set(phase, Event, event)
	end
	return phase
end

local function scheduler_systems_new(callback: (any) -> (), phase: Entity?) 
	local system = world:entity()
	world:set(system, System, { callback = callback, name = debug.info(callback, "n") })
	local depends_on = DependsOn :: jecs.Entity
	local p: Entity = phase or Heartbeat
	world:add(system, pair(depends_on, p))
	
	return system
end

return {
	SYSTEM = scheduler_systems_new,
	BEGIN = begin,
	PHASE = scheduler_phase_new, 
	COLLECT = scheduler_collect_systems_all,
	phases = {
		Heartbeat = Heartbeat,
		PreSimulation = PreSimulation,
		PreAnimation = PreAnimation,
		PreRender = PreRender
	}
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039e</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="12">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">world</string>
					<string name="ScriptGuid">{7F0E15BF-A356-44ED-9073-B5EAB8CBA738}</string>
					<ProtectedString name="Source"><![CDATA[local jecs = require(game:GetService("ReplicatedStorage").ecs)

-- I like the idea of only having the world be a singleton.
local world = jecs.World.new() :: jecs.World
return world]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000039f</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX521FEC94D2E84F809367FEC97F43863B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">mailbox</string>
					<string name="ScriptGuid">{E1B69070-9A61-4B0F-960D-8D012D875EB4}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local std = ReplicatedStorage.std
-- Mailbox.lua (singleton)
local world = require(std.world)
local C     = require(std.components)

local M = { sys = nil, bufByComp = {} }  -- one global mailbox

local function ensureSYS(comp)
    if M.sys then return M.sys end
    for e in world:query(comp):cached() do
        M.sys = e;
        return e
    end
    -- (optional) create it:
    local e = world:entity()
    M.sys = e
    return e
end

function M.getBuf(comp)
    local buf = M.bufByComp[comp]
    if buf then return buf end
    local sys = ensureSYS(comp)
    buf = world:get(sys, comp)

    if not buf then
        buf = table.create(128);
        world:set(sys, comp, buf)
    end

    M.bufByComp[comp] = buf
    return buf
end

function M.push(comp, item)
    local b = M.getBuf(comp)
    b[#b+1] = item
end

function M.drain(comp, fn)
    local b = M.getBuf(comp)
    for i=1,#b do
        fn(b[i])
    end
    table.clear(b)
end

function M.invalidate()  -- for hot-reload
    M.sys = nil
    table.clear(M.bufByComp)
end

return M
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002549</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="13">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Packages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a0</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="14">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Lyra</string>
					<string name="ScriptGuid">{BA758FEB-2744-454A-B039-06ACFEE2FA88}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["paradoxum-games_lyra@0.6.0"]["lyra"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a1</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="15">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Quid</string>
					<string name="ScriptGuid">{778E6C57-53E1-4229-97F7-A2404A64EC52}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["6531503070_quid@1.0.1"]["quid"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a2</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="16">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal</string>
					<string name="ScriptGuid">{A26770D8-F77F-4C1B-AA07-A34F1F25CD78}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_signal@1.5.0"]["signal"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a3</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="17">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TableUtil</string>
					<string name="ScriptGuid">{A93EE45F-4A3A-488D-A761-F70B1AF87D85}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["sleitnick_table-util@1.2.1"]["table-util"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a4</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="18">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a5</UniqueId>
				</Properties>
				<Item class="Folder" referent="19">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">6531503070_quid@1.0.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a6</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="20">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">quid</string>
							<string name="ScriptGuid">{415B2C18-EC66-42FE-A5C1-6085BF5D66FC}</string>
							<ProtectedString name="Source"><![CDATA[-- Quid
-- Ratchanon Suwatsiriphol

--!native
--!optimize 2

--[=[
	@class Quid
	A suitable uid for representing entity uniqueness. While providing version-detectability, k-sortability and human-readability
]=]

-- [Base64url](https://base64.guru/standards/base64url)
-- [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648)

-- stylua: ignore
local BASE_64_URL_CHARACTER = {
	"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",
	"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z",
	"0","1","2","3","4","5","6","7","8","9", "-", "_"
}

-- stylua: ignore
local BASE_64_URL_VALUE_MAP = {} do
	for i, character in ipairs(BASE_64_URL_CHARACTER) do
		BASE_64_URL_VALUE_MAP[character] = i - 1
	end
end

local BASE_LENGTH = #BASE_64_URL_CHARACTER
local MAX_SAFE_INTEGER = 9007199254740991
local MASK_NORMALIZED_U32 = 4294967295 -- 2^32 - 1

--[=[
	@class Config
	A configuration object for quid generation
]=]
local DEFAULT_CONFIG = {}

--- :::tip
--- It's can be used as a number for comparing version and then apply to item / entity schema or data-transformation.
--- :::
---
--- @prop version number
--- @within Config
DEFAULT_CONFIG.version = game.PlaceVersion

--- :::tip
--- It's can be represent as a `machine-id`, `place-id`, `job-id`, etc. for better randomness.
--- But it depends on your entropy factory function too.
--- :::
---
--- @prop fingerprint string
--- @within Config
DEFAULT_CONFIG.fingerprint = `{game.GameId}:{game.PlaceId}:{game.JobId}`

--- @prop _counter number
--- @within Config
--- @private
DEFAULT_CONFIG._counter = 0

--- A factory function for produce unix-timestamp in milliseconds as a integer.
---
--- :::tip
--- You can `overwrite` this, and implement your own clock function.
--- :::
---
--- @function clock
--- @within Config
--- @return number -- A unix-timestamp in milliseconds as a integer.
DEFAULT_CONFIG.clock = function()
	return (workspace:GetServerTimeNow() * 1000) // 1
end

--- A factory function for produce random number between [0, 1]
---
--- :::tip
--- You can `overwrite` this, and implement your own entropy function.
--- :::
---
--- @function entropy
--- @within Config
--- @param version number
--- @param timestamp number
--- @param fingerprint string
--- @param counter number
--- @return number -- A random number between [0, 1]
DEFAULT_CONFIG.entropy = function(version: number, timestamp: number, fingerprint: string, counter: number)
	-- Implement randomness with using `math.random` (Weak entropy)
	return bit32.bxor(math.random() * MASK_NORMALIZED_U32, counter) / MASK_NORMALIZED_U32
end

export type Config = typeof(DEFAULT_CONFIG)

-- Bucket cache for generating quid improve performance
local cache_quid = table.create(3 + 8 + 15)

local function decode(integer_base: string): number
	local integer = 0
	local base = integer_base

	for i = 1, #base do
		local c = string.sub(base, i, i)
		local val = BASE_64_URL_VALUE_MAP[c]
		integer = integer * BASE_LENGTH + val
	end

	return integer
end

local function generate(config: Config, version: number?, timestamp: number?)
	local version = version or config.version
	local timestamp = timestamp or config.clock()

	version %= BASE_LENGTH ^ 3
	timestamp %= BASE_LENGTH ^ 8

	-- Version (Padding: 4)
	local version_state = version
	for i = 3, 1, -1 do
		local remainder = (version_state % BASE_LENGTH) // 1
		version_state = version_state // BASE_LENGTH
		cache_quid[i] = BASE_64_URL_CHARACTER[remainder + 1]
	end

	-- Timestamp (Padding: 8)
	local timestamp_state = timestamp
	for i = 11, 4, -1 do
		local remainder = (timestamp_state % BASE_LENGTH) // 1
		timestamp_state = timestamp_state // BASE_LENGTH
		cache_quid[i] = BASE_64_URL_CHARACTER[remainder + 1]
	end

	-- Uniqueness (Padding: 12)
	config._counter %= MAX_SAFE_INTEGER
	for i = 26, 12, -1 do
		-- pointer: [0, #BASE_64_URL_CHARACTER]
		local pointer = (
			#BASE_64_URL_CHARACTER
			* config.entropy(config.version, timestamp, config.fingerprint, config._counter) -- noise: [0, 1]
			// 1
		) + 1
		cache_quid[i] = BASE_64_URL_CHARACTER[pointer]
	end

	local quid = table.concat(cache_quid)
	table.clear(cache_quid)
	config._counter += 1

	return quid
end

local Quid = { config = DEFAULT_CONFIG }
Quid.__index = Quid

--- Generate a new quid with global config state
---
--- @within Quid
--- @param version number?
--- @param timestamp number?
--- @return string -- [quid](../docs/intro#-quids-data-structure)
function Quid.next(version: number?, timestamp: number?)
	return generate(DEFAULT_CONFIG, version, timestamp)
end

--- Parse a quid string into its components
---
--- @within Quid
--- @param quid string
--- @return number -- Version
--- @return number -- Timestamp
--- @return number -- Uniqueness
function Quid.parse(quid: string)
	local version = string.sub(quid, 1, 3)
	local timestamp = string.sub(quid, 4, 11)
	local uniqueness = string.sub(quid, 12, 26)

	-- stylua: ignore
	return
		decode(version), 
		decode(timestamp),
		decode(uniqueness)
end

--- Check if x is a valid [quid](../docs/intro#-quids-data-structure)
---
--- @within Quid
--- @param x any | string?
--- @return boolean
function Quid.is(x: any | string?): boolean
	-- stylua: ignore
	return 
		type(x) == "string" and 
		string.find(x, "^[A-Za-z0-9%-_]+$") ~= nil and
		#x == 26
end

--- Update a version of [quid](../docs/intro#-quids-data-structure)
---
--- @error "Invalid quid" -- quid is a base64url string and must be 28 characters
--- @within Quid
--- @param quid string
--- @param target_version number? -- If nil: increment +1 (Can be decrease or increase)
--- @return string -- Updated [quid](../docs/intro#-quids-data-structure)
--- @return number? -- Target version (If nil: not updated)
function Quid.update(quid: string, target_version: number?)
	if not Quid.is(quid) then error("Invalid quid") end

	local current_version = decode(string.sub(quid, 1, 3))
	local component = string.sub(quid, 4)
	local new_version = target_version or current_version + 1
	new_version %= BASE_LENGTH ^ 3

	-- Version (Padding: 4)
	local bucket = table.create(3)
	local version_state = new_version
	for i = 3, 1, -1 do
		local remainder = (version_state % BASE_LENGTH) // 1
		version_state = version_state // BASE_LENGTH
		bucket[i] = BASE_64_URL_CHARACTER[remainder + 1]
	end

	local updated_quid = table.concat(bucket) .. component
	local result_version = new_version ~= current_version and new_version or nil

	-- stylua: ignore
	return 
		updated_quid,
		result_version
end

--- Create a new quid object with custom config state
---
--- @within Quid
--- @param config Config?
--- @return Quid<Config> -- Quid object
function Quid.new(config: Config?)
	local self = setmetatable({}, Quid)
	self.config = config or DEFAULT_CONFIG
	self.config._counter = MAX_SAFE_INTEGER
		* self.config.entropy(self.config.version, self.config.clock(), self.config.fingerprint, self.config._counter)
		// 1

	return self
end

export type Quid = typeof(Quid)

--- Generate a new quid with local config state
---
--- @within Quid
--- @param version number?
--- @param timestamp number?
--- @return string -- [quid](../docs/intro#-quids-data-structure)
function Quid:Next(version: number?, timestamp: number?)
	local self = self :: Quid
	return generate(self.config, version, timestamp)
end

return Quid
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a7</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">alicesaidhi_jabby@0.2.2</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a8</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="22">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">jabby</string>
							<string name="ScriptGuid">{D49D6656-EFE6-4ED2-8869-3F8364402E4B}</string>
							<ProtectedString name="Source"><![CDATA[local jecs = require(script.Parent.jecs)
local traffic_check = require(script.modules.traffic_check)
local types = require(script.modules.types)
local vm_id = require(script.modules.vm_id)
local server = require(script.server)
local public = require(script.server.public)
local scheduler = require(script.server.scheduler)

type Applet<T> = {
	--- this is currently a temporary measure, while i work on a more
	--- long-term solution for jabby 0.3.
	add_to_public: (name: string, config: T) -> ()
}

local world_applet = {
	add_to_public = function(
		name: string, config: { world: jecs.World, entities: {[Instance]: jecs.Entity<any>}?, get_entity_from_part: ((part: BasePart) -> (jecs.Entity<any>, Part?))? }
	)
		public.updated = true
		table.insert(public, {
			class_name = "World",
			name = name,
			world = config.world,
			entities = config.entities,
			get_entity_from_part = config.get_entity_from_part
		})
	end
}


local scheduler_applet = {
	add_to_public = function(
		name: string, config: { scheduler: types.Scheduler }
	)
		public.updated = true
		config.scheduler.name = name
		table.insert(public, config.scheduler)
	end
}

return {
	set_check_function = function(callback: (Player) -> boolean)
		traffic_check.can_use_jabby = callback 
	end,

	obtain_client = function()
		return require(script.client)
	end,

	vm_id = vm_id,
	scheduler = scheduler,

	broadcast_server = server.broadcast,

	applets = {
		world = world_applet,
		scheduler = scheduler_applet
	},

	register = function<T>(info: { name: string, applet: Applet<T>, configuration: T })
		info.applet.add_to_public(info.name, info.configuration)
	end,

}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003a9</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="23">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">client</string>
								<string name="ScriptGuid">{2BF93541-4307-4110-9497-92B6F6731CAF}</string>
								<ProtectedString name="Source"><![CDATA[local entity = require(script.apps.entity)
local home = require(script.apps.home)
local overview_scheduler = require(script.apps.overview_scheduler)
local registry = require(script.apps.registry)
local spawn_app = require(script.spawn_app)

return {

	apps = {
		home = home,
		entity = entity,
		scheduler = overview_scheduler,
		registry = registry,
	},

	spawn_app = spawn_app.spawn_app,
	unmount_all = spawn_app.unmount_all

}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003aa</UniqueId>
							</Properties>
							<Item class="Folder" referent="24">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">apps</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ab</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="25">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">entity</string>
										<string name="ScriptGuid">{8984EBF9-2446-4633-8AEB-7970FEC231BC}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local loop = require(script.Parent.Parent.Parent.modules.loop)
local widget = require(script.widget)

local source = vide.source
local cleanup = vide.cleanup

local overview_entity = {
	class_name = "app" :: "app",
	name = "Entity"
}

type props = {
	host: Player | "server",
	vm: number,
	id: number,
	entity: number,
}

function overview_entity.mount(props: props, destroy: () -> ())

	local keys = source({})
	local changes = source({})
	local enable_live_updates = source(true)
	local apply_changes = source(false)
	local deleting = source(false)

	-- check if the query and columns are properly
	local app_loop = loop (
		"app-client-entity",
		{
			host = props.host,
			vm = props.vm,
			id = props.id,
			entity = tonumber(props.entity),

			keys = keys,
			live_updates = enable_live_updates,
			changes = changes,
			apply_changes = apply_changes,
			deleting = deleting
		},

		{i = 1},
		script.systems.obtain_entity_data
	)

	cleanup(
		RunService.Heartbeat:Connect(app_loop)
	)

	return widget {
		host = props.host,
		vm = props.vm,
		id = props.id,
		entity = props.entity,

		components = keys,
		live_updates = enable_live_updates,
		changes = changes,
		apply_changes = apply_changes,

		delete = function()
			deleting(true)
		end,

		destroy = destroy
	}

end

return overview_entity]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ac</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="26">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">add_component</string>
											<string name="ScriptGuid">{42CD09A2-5980-490A-9912-981F80804912}</string>
											<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local query_parser = require(script.Parent.Parent.Parent.Parent.server.query_parser)

local create = vide.create
local source = vide.source
local show = vide.show

type props = {
	components: () -> {[string]: string},
	changes: vide.Source<{[string]: string}>,
	editing: vide.Source<false | string>,
	adding: vide.Source<false | string>,
	text: vide.Source<string>
}

return function(props: props)

	local component_edit_text = source("")
	local adding = props.adding
	local editing = props.editing
	local text = props.text

	return create "Folder" {
		Name = "Add Component",

		show(adding, function()
			return create "Frame" {
				ZIndex = 1000,
				Size = UDim2.new(1,16, 1, 16),
				Position = UDim2.fromScale(0.5, 0.5),
				AnchorPoint = Vector2.new(0.5, 0.5),

				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.5,

				Active = true,

				create "UIListLayout" {
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
					VerticalAlignment = Enum.VerticalAlignment.Center,
					Padding = UDim.new(0, 8)
				},

				pebble.padding {
					padding = UDim.new(0, 32)
				},

				pebble.textfield {
					size = UDim2.fromOffset(200, 30),

					placeholder = "Entity",

					oninput = component_edit_text,
				},

				create "Frame" {
					Size = UDim2.new(1, 0, 0, 30),
					BackgroundTransparency = 1,
					AutomaticSize = Enum.AutomaticSize.Y,

					create "UIListLayout" {
						HorizontalFlex = Enum.UIFlexAlignment.Fill,
						FillDirection = Enum.FillDirection.Horizontal,
						Padding = UDim.new(0, 8)
					},
					
					pebble.button {
						size = UDim2.fromOffset(150, 30),
						text = "Edit",
						activated = function()
							adding(false)
							text(
								props.components()[component_edit_text()] or ""
							)
							editing(component_edit_text())
						end,
						disabled = function()
							local ok, node = pcall(query_parser, component_edit_text())

							if not ok then return true end
							if not node[1] then return true end
							if node[2] then return true end
							local n = node[1]
							if n.type == "Relationship" then
								if n.left.type == "Wildcard" then return true end
								if n.right.type == "Wildcard" then return true end
							end

							return false
						end,
						accent = true
					},
					
					pebble.button {
						size = UDim2.fromOffset(150, 30),
						text = "Cancel",
						activated = function()
							adding(false)
						end
					},
				}

				
			}
		end)

	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ad</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="27">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">editor</string>
											<string name="ScriptGuid">{5F4FE795-6FE6-43E6-9CCD-AC3265FC54BE}</string>
											<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local show = vide.show

type props = {
	components: () -> {[string]: string},
	changes: vide.Source<{[string]: string}>,
	editing: vide.Source<false | string>,
	text: vide.Source<string>
}

return function(props: props)

	local editing = props.editing
	local text = props.text
	local changes = props.changes

	return create "Folder" {
		Name = "Text Editor",

		show(function()
			return editing()
		end, function()
			return create "Frame" {
				ZIndex = 1000,
				Size = UDim2.new(1,16, 1, 16),
				Position = UDim2.fromScale(0.5, 0.5),
				AnchorPoint = Vector2.new(0.5, 0.5),

				BackgroundColor3 = Color3.new(0, 0, 0),
				BackgroundTransparency = 0.5,

				Active = true,

				create "UIListLayout" {
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
					VerticalAlignment = Enum.VerticalAlignment.Center,
					VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly,
					Padding = UDim.new(0, 8)
				},

				pebble.padding {
					padding = UDim.new(0, 32)
				},

				pebble.typography {
					text = function()
						return `Editing {editing()}`
					end
				},

				create "Frame" {
					Size = UDim2.fromScale(1, 0),
					
					create "UIFlexItem" {
						FlexMode = Enum.UIFlexMode.Fill
					},
					
					BackgroundTransparency = 1,

					pebble.textfield {
						size = UDim2.fromScale(1, 1),
						position = UDim2.fromScale(0.5, 0.5),
						anchorpoint = Vector2.new(0.5, 0.5),

						multiline = true,
						code = true,

						text = text,
						oninput = text,
					},	
				},

				create "Frame" {
					Size = UDim2.new(1, 0, 0, 30),
					BackgroundTransparency = 1,
					AutomaticSize = Enum.AutomaticSize.Y,

					create "UIListLayout" {
						HorizontalFlex = Enum.UIFlexAlignment.Fill,
						FillDirection = Enum.FillDirection.Horizontal,
						Padding = UDim.new(0, 8)
					},
					
					pebble.button {
						size = UDim2.fromOffset(150, 30),
						text = "Save Changes",
						activated = function()
							local key = editing()
							changes()[key] = text()

							editing(false)
							changes(changes())

							if props.components()[key] ~= nil then return end
							props.components()[key] = text()
						end,
						accent = true
					},
					
					pebble.button {
						size = UDim2.fromOffset(150, 30),
						text = "Cancel Changes",
						activated = function()
							editing(false)
						end
					},
				}

				
			}
		end)

	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ae</UniqueId>
										</Properties>
									</Item>
									<Item class="Folder" referent="28">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">systems</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003af</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="29">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">obtain_entity_data</string>
												<string name="ScriptGuid">{99CCB811-F5B2-4BD5-BE2E-12845F74CAFF}</string>
												<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)

local effect = vide.effect
local cleanup = vide.cleanup
local batch = vide.batch

type Context = {
	host: Player | "server",
	vm: number,
	id: number,
	entity: number,

	keys: vide.Source<{[string]: string}>,
	changes: vide.Source<{[string]: string}>,
	apply_changes: vide.Source<boolean>,
	live_updates: () -> boolean,
	deleting: () -> boolean,

}

local function generate_random_query_id()
	return math.random(2 ^ 31 - 1)
end

return function(context: Context)

	local inspect_entity_update = queue(remotes.inspect_entity_update)
	
	local current_inspectid = generate_random_query_id()
	local outgoing = {
		host = context.host,
		to_vm = context.vm,
	}

	remotes.inspect_entity:fire(
		outgoing,	
		context.id,
		context.entity,
		current_inspectid
	)

	local settings_changed = false

	effect(function()
		context.live_updates()
		settings_changed = true
	end)

	cleanup(function()
		remotes.stop_inspect_entity:fire(
			outgoing,
			current_inspectid
		)
	end)

	return function()

		if context.apply_changes() then
			remotes.update_entity:fire(outgoing, current_inspectid, context.changes())
			context.apply_changes(false)
			context.changes({})
		end

		if context.deleting() then
			remotes.delete_entity:fire(outgoing, current_inspectid)
		end

		if settings_changed then
			remotes.update_inspect_settings:fire(
				outgoing,
				current_inspectid,
				{paused = not context.live_updates()}
			)
			settings_changed = false
		end

		batch(function()
			for incoming, inspectid, key, value in inspect_entity_update:iter() do
				if inspectid ~= current_inspectid then continue end
				context.keys()[key] = value
				context.keys(context.keys())
			end
		end)

	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b0</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="30">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">widget</string>
											<string name="ScriptGuid">{75A90AC0-9DA6-4154-A11A-FD9F395F9645}</string>
											<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local add_component = require(script.Parent.add_component)
local editor = require(script.Parent.editor)

local create = vide.create
local indexes = vide.indexes
local source = vide.source
local show = vide.show

type SystemId = number

type props = {
	host: Player | "server",
	vm: number,
	id: number,
	entity: number,

	components: vide.Source<{[string]: string}>,
	changes: vide.Source<{[string]: string}>,
	live_updates: vide.Source<boolean>,
	apply_changes: vide.Source<boolean>,

	destroy: () -> (),
	delete: () -> ()
}

local mouse_location = source(Vector2.zero)

RunService.PreRender:Connect(function()
	mouse_location(UserInputService:GetMouseLocation())
end)

return function(props: props)

	local live_updates = props.live_updates
	local changes = props.changes

	local text = source("")
	local adding = source(false)
	local editing = source(false :: false | string)

	local function components()
		local components = {}

		for key, value in props.components() do
			if value == "tag" then continue end
			components[key] = value
		end

		return components
	end

	local function tags()
		local tags = {}

		for key, value in props.components() do
			if value ~= "tag" then continue end
			tags[key] = value
		end

		return tags
	end
	
	local function is_removed(value: string)
		return value == "nil"
	end

	return pebble.widget {
		title = `Entity #{props.entity}`,
		subtitle = `host: {props.host} vm: {props.vm} id: {props.id}`,

		min_size = Vector2.new(300, 300),

		bind_to_close = props.destroy,

		create "Frame" {
			Size = UDim2.fromScale(1, 1),
			BackgroundTransparency = 1,
			
			create "UIListLayout" {
				VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly,
				Padding = UDim.new(0, 8)
			},

			editor {
				components = props.components,
				editing = editing,
				text = text,
				changes = changes
			},
			
			add_component {
				components = props.components,
				editing = editing,
				text = text,
				changes = changes,
				adding = adding
			},

			pebble.row {

				justifycontent = Enum.UIFlexAlignment.Fill,

				pebble.button {
					text = "Live Updates",
					activated = function()
						live_updates(not live_updates())
					end,

					create "UIListLayout" {
						FillDirection = Enum.FillDirection.Horizontal,
						VerticalAlignment = Enum.VerticalAlignment.Center,
						HorizontalFlex = Enum.UIFlexAlignment.SpaceBetween,
						Padding = UDim.new(0, 4)
					},

					pebble.checkbox {
						size = UDim2.fromOffset(16, 16),
						layoutorder = -1,
						checked = live_updates,

						create "UIFlexItem" {
							FlexMode = Enum.UIFlexMode.None,
						}
					}
					
				},

				pebble.button {
					size = UDim2.fromOffset(130, 30),
					text = function()
						local total = 0

						for _, change in changes() do
							total += 1
						end

						return `Apply {total} Edits`
					end,
					disabled = function()
						return next(changes()) == nil
					end,
					activated = function()
						props.apply_changes(true)
					end
				},

				pebble.button {
					create "UIFlexItem" {
						ItemLineAlignment = Enum.ItemLineAlignment.End,
					},
					size = UDim2.fromOffset(130, 30),

					text = "Cancel changes",
					disabled = function()
						return next(changes()) == nil
					end,
					activated = function()
						changes({})
					end
				}

			},

			create "ScrollingFrame" {
				Size = UDim2.fromScale(1, 0),
				CanvasSize = UDim2.new(),
				AutomaticCanvasSize = Enum.AutomaticSize.Y,

				BackgroundColor3 = pebble.theme.bg[-1],

				ScrollBarThickness = 6,
				VerticalScrollBarInset = Enum.ScrollBarInset.Always,

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				},
				
				create "UIListLayout" {
					Padding = UDim.new(0, 4)
				},

				pebble.typography {text = "Components"},

				pebble.container {
					Size = UDim2.fromScale(1, 0),
					AutomaticSize = Enum.AutomaticSize.Y,

					create "UIListLayout" {
						SortOrder = Enum.SortOrder.Name,
					},

					indexes(components, function(value, key)
						return pebble.button {
							{ Name = if not string.match(key, "^%a") then "zzzz" .. key else key },
							size = UDim2.new(1, 0, 0, 32),
							automaticsize = Enum.AutomaticSize.Y,
					
							text = "",
					
							corner = false,
	
							activated = function()
								editing(key)
								local current_value = props.changes()[key]
	
								if current_value then
									text(current_value)
								else
									text(value())
								end
							end,
					
							create "UIListLayout" {
								FillDirection = Enum.FillDirection.Horizontal,
								HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
								VerticalAlignment = Enum.VerticalAlignment.Center,
								Padding = UDim.new(0, 8)
							},
							
							pebble.padding {
								y = UDim.new(0, 4)
							},
					
							pebble.typography {
								size = UDim2.new(0, 100, 0, 18),
								automaticsize = Enum.AutomaticSize.Y,
								text = key,
								code = true,
								wrapped = true,
								truncate = Enum.TextTruncate.SplitWord,
								xalignment = Enum.TextXAlignment.Left,
							},
					
							pebble.typography {
								size = UDim2.fromOffset(0, 18),
								automaticsize = Enum.AutomaticSize.Y,
					
								yalignment = Enum.TextYAlignment.Top,
								xalignment = Enum.TextXAlignment.Left,
								text = value,
								wrapped = true,
								truncate = Enum.TextTruncate.AtEnd,
								code = true,
					
								create "UIFlexItem" {
									FlexMode = Enum.UIFlexMode.Fill
								},
	
							},
	
							show(function()
								return props.changes()[key] ~= nil
							end, function()
								return pebble.typography {
									text = function()
										local old = value()
										local change = props.changes()[key]
	
										return if old == nil then "(added)"
											elseif is_removed(change) then "(removed)"
											else "(changed)"
									end,
									disabled = true,
									textsize = 14,
								}
							end),

							create "UISizeConstraint" {
								MaxSize = Vector2.new(math.huge, 300)
							}
						}
					end),
				},

				pebble.typography {text = "Tags"},

				pebble.container {
					Size = UDim2.fromScale(1, 0),
					AutomaticSize = Enum.AutomaticSize.Y,

					create "UIListLayout" {
						SortOrder = Enum.SortOrder.Name,
					},

					indexes(tags, function(value, key)
						local function did_change()
							return changes()[key] ~= nil
						end

						return pebble.button {
							{ Name = if not string.match(key, "^%a") then "zzzz" .. key else key },
							size = UDim2.new(1, 0, 0, 24),
					
							text = "",
					
							corner = false,
	
							activated = function()
								if changes()[key] == "tag" then
									changes()[key] = nil
									props.components()[key] = nil

									-- notify about the change
									changes(changes())
									props.components(props.components())
								elseif changes()[key] then
									changes()[key] = nil
									
									-- notify about the change
									changes(changes())
								else
									changes()[key] = "nil"
									
									-- notify about the change
									changes(changes())
								end
							end,
					
							create "UIListLayout" {
								FillDirection = Enum.FillDirection.Horizontal,
								HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
								VerticalAlignment = Enum.VerticalAlignment.Center,
								Padding = UDim.new(0, 8)
							},
							
							pebble.padding {
								y = UDim.new(0, 4)
							},
					
							pebble.typography {
								size = UDim2.fromScale(0, 1),
								text = key,
								code = true,
								wrapped = true,
								truncate = Enum.TextTruncate.SplitWord,
								xalignment = Enum.TextXAlignment.Left,

								create "UIFlexItem" {
									FlexMode = Enum.UIFlexMode.Fill
								}
							},
	
							show(did_change, function()
								return pebble.typography {
									text = function()
										local old = value()
										local change = changes()[key]
	
										return if old == nil then "(added)"
											elseif is_removed(change) then "(removed)"
											else "(changed)"
									end,
									disabled = true,
									textsize = 14,
								}
							end)
						}
					end),
				}

			},

			pebble.row {

				justifycontent = Enum.UIFlexAlignment.Fill,

				pebble.button {
					size = UDim2.fromOffset(100, 30),
					text = "Delete Id",

					activated = props.delete
				},
				
				pebble.button {
					size = UDim2.fromOffset(200, 30),
					text = "Add Component",

					activated = function()
						adding(true)
					end
				},
				

			}

		}

	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b1</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="31">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">home</string>
										<string name="ScriptGuid">{94C3B06A-9CF4-4402-AA49-579D23CA68B6}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local loop = require(script.Parent.Parent.Parent.modules.loop)
local widget = require(script.widget)

local cleanup = vide.cleanup

local home = {
	class_name = "app" :: "app",
	name = "Home"
}

function home.mount(_: nil, destroy: () -> ())

	local servers = vide.source {} :: any
	local app_loop = loop (
		"app-client-home",
		servers,

		{i = 1},
		script.systems.get_core_data
	)

	cleanup(
		RunService.Heartbeat:Connect(app_loop)
	)

	return widget {
		servers = servers,
		destroy = destroy
	}

end

return home]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b2</UniqueId>
									</Properties>
									<Item class="Folder" referent="32">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">systems</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b3</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="33">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">get_core_data</string>
												<string name="ScriptGuid">{BBD42460-1BDC-4562-977F-590B28FED64C}</string>
												<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.Parent.Parent.modules.reverse_connector)

return function(data)

	for _, player in Players:GetPlayers() do
		remotes.ping:fire({
			host = player,
		})
	end
	remotes.ping:fire({
		host = "server"
	})

	local servers_responding = queue(remotes.new_server_registered)
	local server_update = queue(remotes.update_server_data)
	local player_removing = queue(Players.PlayerRemoving)

	local n = 0
	local servers = data :: any
	local map_to_idx = {
		server = {}
	}

	return function()

		for connector in servers_responding:iter() do
			local outgoing = reverse_connector(connector)
			remotes.bind_to_server_core:fire(outgoing)
		end

		for	player in player_removing:iter() do
			local indexes = map_to_idx[player]

			if not indexes then continue end

			for _, idx in indexes do
				servers()[idx] = nil
			end
			servers(servers())
		end

		for connector, packet in server_update:iter() do
			local outgoing = reverse_connector(connector)

			map_to_idx[outgoing.host] = map_to_idx[outgoing.host] or {}
			local idx = map_to_idx[outgoing.host][outgoing.to_vm]

			if not idx then
				-- print("new server")
				idx = n + 1; n += 1
				map_to_idx[outgoing.host][outgoing.to_vm] = idx
				servers()[idx] = {
					host = outgoing.host,
					vm = outgoing.to_vm,

					schedulers = vide.source {},
					worlds = vide.source {}
				}
				servers(servers())
				-- print("set worlds")
				-- print(servers())
			end

			local server = servers()[idx]
			local schedulers = server.schedulers()
			local worlds = server.worlds()

			table.clear(schedulers)
			table.clear(worlds)

			for index, data in packet.schedulers do
				local at = schedulers[index]
				if at and at.name == data.name and at.id == data.id then continue end
				schedulers[index] = data
			end

			for index, data in packet.worlds do
				local at = worlds[index]
				if at and at.name == data.name and at.id == data.id then continue end
				worlds[index] = data
			end

			server.schedulers(schedulers)
			server.worlds(worlds)

		end
	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b4</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="34">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">widget</string>
											<string name="ScriptGuid">{C8272E90-F12E-4E13-BFAF-1EE5B58CC015}</string>
											<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local spawn_app = require(script.Parent.Parent.Parent.spawn_app)
local overview_scheduler = require(script.Parent.Parent.overview_scheduler)
local registry = require(script.Parent.Parent.registry)

local create = vide.create
local derive = vide.derive
local source = vide.source
local values = vide.values
local show = vide.show

type props = {

	servers: () -> {
		{
			host: "server" | Player,
			vm: number,

			schedulers: () -> {
				{id: number, name: string}
			},
			worlds: () -> {
				{id: number, name: string}
			}
		}
	},

	destroy: () -> ()

}

return function(props: props)

	local selected = source(Players.LocalPlayer)

	local hosts = derive(function()
		local hosts = {}

		for _, server in props.servers() do
			local host = server.host
			hosts[host] = hosts[host] or {}
			table.insert(hosts[host], server)
		end

		hosts["all"] = props.servers()

		return hosts
	end)

	local options = derive(function()
		local options = {}

		for host, servers in hosts() do
			options[host] = if type(host) == "string" then host else `@{host.Name}`
		end	

		options[Players.LocalPlayer] = "localplayer"
		options["all"] = "all"

		return options
	end)

	local function objects()
		return hosts()[selected()] or {} :: never
	end

	local function is_empty()
		local no_objects = next(objects()) == nil
		if no_objects then return "No objects found. You may not have permissions to use this." end
		-- for _, object in objects() do
		-- 	if #object.worlds() == 0 then return "No worlds found. Did you forget to set updated?" end
		-- 	if #object.schedulers() == 0 then return "No schedulers found. Did you forget to set updated?" end
		-- end
		return false
	end

	return pebble.widget {
		title = "Home",
		min_size = Vector2.new(230, 200),
		bind_to_close = props.destroy,
	
		pebble.container {

			create "UIListLayout" {
				Padding = UDim.new(0, 2),
				VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly,
				HorizontalFlex = Enum.UIFlexAlignment.Fill
			},

			pebble.select {
				size = UDim2.new(1, 0, 0, 32),
				options = options :: any,
				selected = selected :: any,
				update_selected = selected
			},
	
			create "ScrollingFrame" {
				-- Size = UDim2.fromScale(1, 1),
				CanvasSize = UDim2.new(),
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
				BackgroundTransparency = 1,
				ScrollBarThickness = 6,
				HorizontalScrollBarInset = Enum.ScrollBarInset.Always,

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				},
	
				pebble.padding {
					x = UDim.new(0, 1),
					right = UDim.new(0, 8)
				},
	
				create "UIListLayout" {
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalFlex = Enum.UIFlexAlignment.Fill,
					Padding = UDim.new(0, 8),
					Wraps = true
				},

				show(is_empty, function()
					return pebble.typography {
						text = is_empty(),
						xalignment = Enum.TextXAlignment.Left,
						wrapped = true
					}
				end),

				values(objects, function(value, key)
					
					return pebble.pane{
						name = "",
						size = UDim2.fromOffset(200, 0),
						automaticsize = Enum.AutomaticSize.Y,
		
						create "UIListLayout" {
							Padding = UDim.new(0, 8)
						},
		
						pebble.typography {
							text = `host: {value.host}\tvm id: {value.vm}`,
							wrapped = true
						},
		
						values(value.worlds, function(world)
							return pebble.button {
								size = UDim2.new(1, 0, 0, 30),
								text = `World: {world.name}`,
	
								activated = function()
									spawn_app.spawn_app(registry, {
										host = value.host,
										vm = value.vm,
										id = world.id
									})
								end
							}
						end),
	
						values(value.schedulers, function(scheduler)
							return pebble.button {
								size = UDim2.new(1, 0, 0, 30),
								text = `Scheduler: {scheduler.name}`,
	
								activated = function()
									spawn_app.spawn_app(overview_scheduler, {
										host = value.host,
										vm = value.vm,
										id = scheduler.id
									})
								end
							}
						end)
					}
				end) 
			}
		}
	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b5</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="35">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">overview_scheduler</string>
										<string name="ScriptGuid">{C18B7AA7-8751-4AA4-9B10-8B42862B1CC5}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local loop = require(script.Parent.Parent.Parent.modules.loop)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local widget = require(script.widget)

local source = vide.source
local cleanup = vide.cleanup

local overview_scheduler = {
	class_name = "app" :: "app",
	name = "Scheduler"
}

type props = {
	host: Player | "server",
	vm: number,
	id: number
}

function overview_scheduler.mount(props: props, destroy: () -> ())

	local system_data = source {}
	local system_frames = source {}
	local system_ids = source {}

	local app_loop = loop (
		"app-client-scheduler",
		{
			host = props.host,
			vm = props.vm,
			id = props.id,

			system_ids = system_ids,
			system_data = system_data,
			system_frames = system_frames,
		},

		{i = 1},
		script.systems.get_scheduler_data
	)

	cleanup(
		RunService.Heartbeat:Connect(app_loop)
	)

	return widget {
		host = props.host,
		vm = props.vm,
		id = props.id,

		system_ids = system_ids,
		system_data = system_data,
		system_frames = system_frames,
		pause_system = function(system: number)
			remotes.scheduler_system_pause:fire({
				host = props.host,
				to_vm = props.vm
			}, props.id, system, not system_data()[system].paused)
		end,
		
		destroy = destroy
	}

end

return overview_scheduler]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b6</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="36">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">stack_bar</string>
											<string name="ScriptGuid">{7EB7BBB0-53BA-4AAD-AA79-D18F21D2CA9E}</string>
											<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local indexes = vide.indexes
local derive = vide.derive

type stack_bar = {
	values: () -> {{value: number, color: Color3}},
	selected: (number) -> ()
}

return function(props: stack_bar)

	local total = derive(function()
		local total = 0
		for _, value in props.values() do
			total += value.value
		end
		return total
	end)

	return create "Frame" {
		Name = "Graph",
		Size = UDim2.new(1, 0, 0, 32),

		indexes(props.values, function(value, index)
			return create "Frame" {

				Size = function()
					return UDim2.fromScale(value().value / total(), 1)
				end,

				BackgroundColor3 = function() return value().color end,

				MouseEnter = function()
					props.selected(index)
				end,
			}
		end),

		create "UIListLayout" {
			FillDirection = Enum.FillDirection.Horizontal,
		},
	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b7</UniqueId>
										</Properties>
									</Item>
									<Item class="Folder" referent="37">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">systems</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b8</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="38">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">get_scheduler_data</string>
												<string name="ScriptGuid">{F306572D-7BF6-413D-9E86-643F16D5EE87}</string>
												<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)
local types = require(script.Parent.Parent.Parent.Parent.Parent.modules.types)

local batch = vide.batch
local cleanup = vide.cleanup

type SystemId = types.SystemId
type SystemData = types.SystemData
type SystemFrame = types.SystemFrame

type context = {
	host: Player | "server",
	vm: number,
	id: number,
	
	system_ids: vide.Source<{[SystemId]: true}>,
	system_data: vide.Source<{[SystemId]: types.SystemData}>,
	system_frames: vide.Source<{[SystemId]: {types.SystemFrame}}>,
}

local MAX_BUFFER_SIZE = 50

return function(context: context)
	local outgoing = {
		host = context.host,
		to_vm = context.vm
	}

	remotes.request_scheduler:fire(outgoing, context.id)

	local scheduler_static_data_updated = queue(remotes.scheduler_system_static_update)
	local scheduler_frame_data_updated = queue(remotes.scheduler_system_update)

	cleanup(function()
		remotes.disconnect_scheduler:fire(outgoing, context.id)
	end)

	return function()

		batch(function()
			for incoming, scheduler, id, new_data in scheduler_static_data_updated:iter() do
				if incoming.host ~= context.host then continue end
				if incoming.from_vm ~= context.vm then continue end
				if scheduler ~= context.id then continue end

				if new_data == nil then
					context.system_ids()[id] = nil
					context.system_data()[id] = nil
					context.system_frames()[id] = nil

					context.system_ids(context.system_ids())
					context.system_data(context.system_data())
					context.system_frames(context.system_frames())
				else
					context.system_ids()[id] = true
					context.system_data()[id] = new_data
					context.system_frames()[id] = context.system_frames()[id] or {}

					context.system_ids(context.system_ids())
					context.system_data(context.system_data())
					context.system_frames(context.system_frames())
				end

			end

			for incoming, scheduler, id, f, s in scheduler_frame_data_updated:iter() do
				if incoming.host ~= context.host then continue end
				if incoming.from_vm ~= context.vm then continue end
				if scheduler ~= context.id then continue end
				if context.system_frames()[id] == nil then continue end

				-- look where to append the frame to
				local frames = context.system_frames()[id]
				local f_data = {i = f, s = s}
				local added = false

				--- since it's unreliable we have to constantly check if we arent out of order
				for i, frame in frames do
					if frame.i == f then frames[i] = f_data; continue end
					if frame.i > f then continue end
					table.insert(frames, i, f_data)
					table.remove(frames, MAX_BUFFER_SIZE + 1)
					added = true
					break
				end

				if #frames <= MAX_BUFFER_SIZE and added == false then
					table.insert(frames, f_data)
				end
				
				context.system_frames(context.system_frames())
			end
		end)

	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003b9</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="39">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">widget</string>
											<string name="ScriptGuid">{CD20FBB8-5EB7-4D69-8AF3-89C6A7014E64}</string>
											<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local convert_units = require(script.Parent.Parent.Parent.Parent.modules.convert_units)
local types = require(script.Parent.Parent.Parent.Parent.modules.types)
local spawn_app = require(script.Parent.Parent.Parent.spawn_app)
local system_widget = require(script.Parent.Parent.system)
local stack_bar = require(script.Parent.stack_bar)

local create = vide.create
local indexes = vide.indexes
local values = vide.values
local changed = vide.changed
local source = vide.source
local derive = vide.derive

type SystemId = number

type props = {
	host: Player | "server",
	vm: number,
	id: number,

	system_ids: () -> {[SystemId]: true},
	system_data: () -> {[SystemId]: types.SystemData},
	system_frames: () -> {[SystemId]: {types.SystemFrame}},

	pause_system: (SystemId) -> (),
	destroy: () -> ()

}

local function color(n: number)
	return Color3.fromHSV((0.15 * (n-1)) % 1, 1, 1)
end

local sort_by_options = {
	"Name",
	"Id",
	"Frame Time"
}

return function(props: props)

	local selected = source(0)
	local systems_query = source("")
	
	local sort_by = source(2)

	local max_frametime = derive(function()
		local max = 0
		for _, frames in props.system_frames() do
			local sum = 0

			for _, frame in frames do
				sum += frame.s
			end

			max = math.max(max, sum / #frames)
		end
		return max
	end)

	local map_phases_to_systems = derive(function()
		local phases: {[false | string]: {number}} = {[false] = {}}
		for id, data in props.system_data() do
			if phases[data.phase or false] == nil then phases[data.phase or false] = {} end
			table.insert(phases[data.phase or false], id)
		end
		return phases
	end)

	local function system(id: number)
		local gui_state = source(Enum.GuiState.Idle)

		local function frame_time()
			local sum = 0
			local frames = props.system_frames()[id]

			for _, frame in frames do
				sum += frame.s
			end

			return sum / #frames
		end

		local b = create "ImageButton" {
			Name = function()
				return props.system_data()[id].name
			end,
			Size = UDim2.new(1, 0, 0, 32),

			LayoutOrder = function()
				return if sort_by() == 3 then 1e9 - frame_time() * 1e8 else id
			end,

			BackgroundColor3 = function()
				return if gui_state() == Enum.GuiState.Press then
					pebble.theme.bg[-1]()
				elseif gui_state() == Enum.GuiState.Hover then
					pebble.theme.bg[6]()
				else
					pebble.theme.bg[3]()
			end,

			Visible = function()
				return not not string.match(props.system_data()[id].name, systems_query())
			end,

			changed("GuiState", gui_state),

			Activated = function()
				spawn_app.spawn_app(system_widget, {
					host = props.host,
					vm = props.vm,

					scheduler = props.id,
					system = id,
					name = props.system_data()[id].name
				})
			end,

			MouseButton2Click = function()
				props.pause_system(id)
			end,

			-- create a frame that ignores all rules!
			create "Folder" {
				create "Frame" {
					Position = UDim2.new(0, 0, 1, 4),
					AnchorPoint = Vector2.new(0, 1),
					Size = function()
						return UDim2.new(frame_time() / max_frametime(), 0, 0, 1)
					end,

					BackgroundColor3 = pebble.theme.fg_on_bg_high[0]

				}
			},

			create "UIStroke" {
				Color = pebble.theme.bg[-3]
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 4)
			},

			create "UIListLayout" {
				FillDirection = Enum.FillDirection.Horizontal,
				VerticalAlignment = Enum.VerticalAlignment.Center,
				HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
				Padding = UDim.new(0, 8)
			},

			pebble.padding {
				x = UDim.new(0, 8)
			},

			create "Frame" {
				Size = UDim2.fromOffset(16, 16),
				AnchorPoint = Vector2.new(0.5, 0.5),

				BackgroundColor3 = color(id),

				create "UICorner" {
					CornerRadius = UDim.new(1, 0)
				},
			},

			pebble.typography {
				automaticsize = Enum.AutomaticSize.None,
				text = function()
					return props.system_data()[id].name
				end,

				truncate = Enum.TextTruncate.SplitWord,
				xalignment = Enum.TextXAlignment.Left,
				disabled = function()
					return props.system_data()[id].paused
				end,

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill,
					GrowRatio = 1,
					ShrinkRatio = 1
				}
			},

			pebble.typography {
				automaticsize = Enum.AutomaticSize.XY,
				text = function()
					local sum = 0
					local frames = props.system_frames()[id]

					for _, frame in frames do
						sum += frame.s
					end

					return `{convert_units("s", sum / #frames)}`
				end,

				xalignment = Enum.TextXAlignment.Right,

				disabled = true,

			},

		}
		return b
	end

	return pebble.widget {
		title = "Scheduler",
		subtitle = `host: {props.host} vm: {props.vm} id: {props.id}`,

		min_size = Vector2.new(200, 300),

		bind_to_close = props.destroy,

		create "Frame" {
			Name = "Elements",
			Size = UDim2.fromScale(1, 1),
			AutomaticSize = Enum.AutomaticSize.Y,

			BackgroundTransparency = 1,

			create "UIListLayout" {
				VerticalAlignment = Enum.VerticalAlignment.Bottom,
				FillDirection = Enum.FillDirection.Vertical,
				VerticalFlex = Enum.UIFlexAlignment.SpaceBetween,
				Padding = UDim.new(0, 8)
			},

			create "Frame" {
				Size = UDim2.fromScale(1, 0),
				AutomaticSize = Enum.AutomaticSize.Y,

				BackgroundTransparency = 1,

				-- create "UIFlexItem" {
				-- 	FlexMode = Enum.UIFlexMode.Custom,
				-- 	GrowRatio = 0,
				-- 	ShrinkRatio = 0
				-- },

				pebble.pane {
					name = "Overview",
					size = UDim2.fromScale(1, 0),
		
					create "UIListLayout" {
						FillDirection = Enum.FillDirection.Vertical
					},
	
					pebble.typography {
						text = function()
							local run_time = 0
							for id, frames in props.system_frames() do
								if props.system_data()[id].paused then continue end
								local sum = 0

								for _, frame in frames do
									sum += frame.s
								end

								run_time += sum / #frames
							end
	
							return `Run time: {convert_units("s", run_time)}`
						end
					},
	
					stack_bar {
						values = function()
							local v = {}
	
							local system_ids = props.system_ids()
							local system_frames = props.system_frames()
	
							for i = 1, table.maxn(system_ids) do
								if system_ids[i] == nil then continue end
								if props.system_data()[i].paused then continue end

								local sum = 0
								local frames = system_frames[i]

								for _, frame in frames do
									sum += frame.s
								end
	
								table.insert(v, {value = sum / #frames, color = color(i)})
							end
	
							return v
						end,
						selected = selected
					},

					pebble.row {
						justifycontent = Enum.UIFlexAlignment.Fill,
						pebble.button {
							text = "Pause all",

							activated = function()
								for system, data in props.system_data() do
									if data.paused then continue end
									props.pause_system(system)
								end
							end
						},

						pebble.button {
							text = "Resume all",

							activated = function()
								for system, data in props.system_data() do
									if not data.paused then continue end
									props.pause_system(system)
								end
							end
						}
					}
				},

			},

			pebble.select {
				size = UDim2.new(1, 0, 0, 30),

				options = sort_by_options,
				selected = sort_by,
				update_selected = function(new)
					-- print(new)
					sort_by(new)
				end
			},

			pebble.textfield {
				size = UDim2.new(1, 0, 0, 36),

				placeholder = "System Match",
				
				oninput = systems_query,
			},

			create "ScrollingFrame" {
				Name = "Systems",

				Size = UDim2.fromScale(1, 0),
				CanvasSize = UDim2.new(),
				AutomaticCanvasSize = Enum.AutomaticSize.Y,

				BackgroundTransparency = 1,

				ScrollBarThickness = 6,
				VerticalScrollBarInset = Enum.ScrollBarInset.Always,
				ScrollBarImageColor3 = pebble.theme.fg_on_bg_low[3],

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				},

				create "UIListLayout" {
					FillDirection = Enum.FillDirection.Vertical,
					Padding = UDim.new(0, 8),

					SortOrder = function()
						return if sort_by() == 1 then Enum.SortOrder.Name else Enum.SortOrder.LayoutOrder
					end
				},

				pebble.padding {
					y = UDim.new(0, 1),
					x = UDim.new(0, 1)
				},

				values(function()
					return map_phases_to_systems()[false]
				end, system),

				indexes(map_phases_to_systems, function(systems, phase)
					if phase == false then return {} end
					local expanded = source(true)
					-- print(systems())
					return pebble.accordion {
						expanded = expanded,
						set_expanded = expanded,
						text = phase,
						
						pebble.container {
							Size = UDim2.fromScale(1, 0),

							create "UIListLayout" {
								FillDirection = Enum.FillDirection.Vertical,
								Padding = UDim.new(0, 8),
			
								SortOrder = function()
									return if sort_by() == 1 then Enum.SortOrder.Name else Enum.SortOrder.LayoutOrder
								end
							},
	
							values(systems, system)
						}
					}
				end),

			}

		}

	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ba</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="40">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">registry</string>
										<string name="ScriptGuid">{D6C2DF82-463F-4F37-9C4F-5AD59014D879}</string>
										<ProtectedString name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local loop = require(script.Parent.Parent.Parent.modules.loop)
local spawn_app = require(script.Parent.Parent.spawn_app)
local entity_widget = require(script.Parent.entity)
local widget = require(script.widget)

local source = vide.source
local effect = vide.effect
local cleanup = vide.cleanup

local overview_query = {
	class_name = "app" :: "app",
	name = "Query"
}

type props = {
	host: Player | "server",
	vm: number,
	id: number
}

function overview_query.mount(props: props, destroy: () -> ())

	-- the entity id
	local current_entity = source(nil)
	-- enables picking
	local enable_pick = source(false)
	-- the entity data as a string
	local entity_hovering_over = source()
	-- the part the player is hovering over
	local hovering_over = source()

	local validate_query = source("")
	local ok = source(false)
	local msg = source("")

	local query = source("")
	local columns = source({})
	local from = source(1)
	local upto = source(25)
	local total_entities = source(0)

	local paused = source(false)
	local refresh = source(false)

	-- check if the query and columns are properly
	local app_loop = loop (
		"app-client-registry",
		{
			host = props.host,
			vm = props.vm,
			id = props.id,

			enable_pick = enable_pick,
			entity_hovering_over = entity_hovering_over,
			hovering_over = hovering_over,
			set_entity = current_entity,

			columns = columns,
			query = query,
			paused = paused,
			refresh = refresh,

			total_entities = total_entities,

			from = from,
			upto = upto,

			validate_query = validate_query,
			ok = ok,
			msg = msg
		},

		{i = 1},
		script.systems.validate_query,
		script.systems.obtain_query_data,
		script.systems.send_workspace_entity,
		script.systems.highlight_workspace_entity
	)

	cleanup(RunService.Heartbeat:Connect(app_loop))

	local function open_entity_widget(_, state: Enum.UserInputState)
		local entity = current_entity()

		if state ~= Enum.UserInputState.Begin then return end
		if entity == nil then return end

		enable_pick(false)
		entity_hovering_over(nil)
		hovering_over(nil)

		spawn_app.spawn_app(entity_widget, {
			host = props.host,
			vm = props.vm,
			id = props.id,
			entity = entity
		})
	end

	effect(function()
		local picking = enable_pick()
		local key = `select entity:{props.host} {props.vm} {props.id}`

		if picking then
			ContextActionService:BindAction(key, open_entity_widget, false, Enum.UserInputType.MouseButton1)
		end

		cleanup(function()
			ContextActionService:UnbindAction(key)
		end)

	end)
	
	return widget {
		host = props.host,
		vm = props.vm,
		id = props.id,

		validate_query = validate_query,

		update_system_query = query,
		current_query = query,
		total_rows_per_page = source(25),
		set_rows_per_page = source(25),

		from = from,
		upto = upto,
		total_entities = total_entities,
		paused = paused,
		refresh = refresh,

		enable_pick = enable_pick,
		entity_hovering_over = entity_hovering_over,
		hovering_over = hovering_over,

		ok = ok,
		msg = msg,

		columns = columns,
		
		destroy = destroy
	}

end

return overview_query]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003bb</UniqueId>
									</Properties>
									<Item class="Folder" referent="41">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">systems</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003bc</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="42">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">highlight_workspace_entity</string>
												<string name="ScriptGuid">{86E88AC6-2745-43D6-BA0C-550AAD495FD6}</string>
												<ProtectedString name="Source"><![CDATA[local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)

type Context = {
	host: Player | "server",
	vm: number,
	id: number,

	enable_pick: () -> boolean,
	entity_hovering_over: (string) -> (),
	set_entity: (number) -> (),
	hovering_over: (BasePart) -> ()

}

return function(context: Context)

	local send_mouse_entity = queue(remotes.send_mouse_entity)

	return function()

		for incoming, id, to_highlight, entity, components in send_mouse_entity:iter() do
			if incoming.host ~= context.host then continue end
			if incoming.from_vm ~= context.vm then continue end
			if id ~= context.id then continue end
			if context.enable_pick() == false then continue end
			context.hovering_over(to_highlight)
			context.entity_hovering_over(components)
			context.set_entity(entity)
		end

	end
	
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003bd</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="43">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">obtain_query_data</string>
												<string name="ScriptGuid">{C0B8C45A-5B08-4526-9937-AC986CB114F3}</string>
												<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)

local effect = vide.effect
local batch = vide.batch
local cleanup = vide.cleanup

type Context = {
	host: Player | "server",
	vm: number,
	id: number,

	columns: vide.Source<{ { any } }>,
	query: () -> string,

	paused: () -> boolean,
	refresh: vide.Source<boolean>,

	total_entities: (number) -> (),

	from: () -> number,
	upto: () -> number,

}

local function generate_random_query_id()
	return math.random(2 ^ 31 - 1)
end

return function(context: Context)

	local query_changed = false
	local page_changed = false

	effect(function()
		if #context.query() > 0 then
			query_changed = true
		end
	end)

	effect(function()
		context.from()
		context.upto()
		page_changed = true
	end)

	local current_query_id = -1
	local query_last_frame = 0
	local update_query_result = queue(remotes.update_query_result)
	local count_updated = queue(remotes.count_total_entities)

	local columns = context.columns
	local outgoing = {
		host = context.host,
		to_vm = context.vm
	}

	cleanup(function()
		remotes.disconnect_query:fire(outgoing, current_query_id)
	end)

	local should_refresh = false
	effect(function()
		if context.refresh() ~= true then return end
		context.refresh(false)
		should_refresh = true
	end)

	local paused_state = context.paused()
	local paused_updated = false
	effect(function()
		paused_updated = true
		paused_state = context.paused()
	end)

	return function()

		if query_changed then
			columns({})
			remotes.disconnect_query:fire(outgoing, current_query_id)
			current_query_id = generate_random_query_id()
			-- print("requesting new query", current_query_id)
			remotes.request_query:fire(outgoing, context.id, current_query_id, context.query())
			remotes.advance_query_page:fire(outgoing, current_query_id, context.from(), context.upto())
			query_last_frame = 0
			query_changed = false

			remotes.pause_query:fire(outgoing, current_query_id, paused_state)
		end

		if page_changed then
			remotes.advance_query_page:fire(outgoing, current_query_id, context.from(), context.upto())
			page_changed = false
		end

		for incoming, query, value in count_updated:iter() do
			if query ~= current_query_id then continue end
			context.total_entities(value)
		end

		if paused_updated then
			remotes.pause_query:fire(outgoing, current_query_id, paused_state)
			paused_updated = false
		end

		if should_refresh then
			remotes.refresh_results:fire(outgoing, current_query_id)
			should_refresh = false
		end

		batch(function()
			for incoming, query, frame, column, row, value in update_query_result:iter() do
				if query ~= current_query_id then continue end
				if frame < query_last_frame - 10 then continue end
				query_last_frame = math.max(query_last_frame, frame)

				if columns()[column] == nil then
					columns()[column] = {}
				end

				columns()[column][row] = value
				columns(columns())
			end
		end)

	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003be</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="44">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">send_workspace_entity</string>
												<string name="ScriptGuid">{F5132A9A-5E65-495A-862E-D45537903490}</string>
												<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)

type Context = {
	host: Player | "server",
	vm: number,
	id: number,

	enable_pick: () -> boolean,

}

return function(context: Context)

	if context.enable_pick() == false then return end

	local location = UserInputService:GetMouseLocation()
	local camera = workspace.CurrentCamera

	local ray = camera:ViewportPointToRay(location.X, location.Y)
	
	remotes.send_mouse_pointer:fire(
		{
			host = context.host,
			to_vm = context.vm
		},
		context.id,
		ray.Origin,
		ray.Direction
	)

end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003bf</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="45">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">validate_query</string>
												<string name="ScriptGuid">{D95C88FA-6138-44E5-923E-4D9B0D91118B}</string>
												<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)

local effect = vide.effect

type Context = {
	host: Player | "server",
	vm: number,
	id: number,

	validate_query: () -> string,

	msg: (string) -> (),
	ok: (boolean) -> ()

}

return function(context: Context)

	local query_changed = false

	effect(function()
		context.validate_query()

		query_changed = true
	end)

	local n = 0
	local already_validated = false
	local MIN_DELAY_UNTIL_VALIDATE = 0

	local validate_result = queue(remotes.validate_result)

	if context.host == Players.LocalPlayer then
		MIN_DELAY_UNTIL_VALIDATE = 0.3
	elseif context.host == "server" then
		MIN_DELAY_UNTIL_VALIDATE = 0.5
	else
		MIN_DELAY_UNTIL_VALIDATE = 0.5
	end

	return function(dt)
		if query_changed then
			n = 0
			already_validated = false
			query_changed = false
			
			context.ok(false)
			context.msg("")
		end

		for incoming, world, query, ok, msg in validate_result:iter() do
			if incoming.host ~= context.host then continue end
			if incoming.from_vm ~= context.vm then continue end
			if world ~= context.id then continue end
			if query ~= context.validate_query() then continue end

			context.ok(ok)
			context.msg(msg or "")
		end

		n += dt
		if n < MIN_DELAY_UNTIL_VALIDATE then return end
		if already_validated then return end

		if context.validate_query() == "" then 
			context.ok(false)
			context.msg("empty query")
			return
		end
		
		already_validated = true

		remotes.validate_query:fire(
			{
				host = context.host,
				to_vm = context.vm
			},
			context.id,
			context.validate_query()
		)

	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c0</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="46">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">widget</string>
											<string name="ScriptGuid">{1147B817-1AB5-4C79-98DE-DD0FEF82C478}</string>
											<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local tooltip = require(script.Parent.Parent.Parent.components.tooltip)
local spawn_app = require(script.Parent.Parent.Parent.spawn_app)
local entity = require(script.Parent.Parent.entity)

local create = vide.create
local effect = vide.effect
local source = vide.source
local show = vide.show

type SystemId = number

type props = {
	host: Player | "server",
	vm: number,
	id: number,

	validate_query: (string) -> (),
	ok: () -> boolean,
	msg: () -> string,

	paused: vide.Source<boolean>,
	refresh: (boolean) -> (),

	from: vide.Source<number>,
	upto: vide.Source<number>,

	update_system_query: (query: string) -> (),
	current_query: () -> string,
	total_entities: () -> number,

	enable_pick: vide.Source<boolean>,
	entity_hovering_over: () -> string,
	hovering_over: () -> BasePart,

	columns: () -> {{any}},

	destroy: () -> ()
}

local mouse_location = source(Vector2.zero)

RunService.PreRender:Connect(function()
	mouse_location(UserInputService:GetMouseLocation())
end)

return function(props: props)

	local page_input = source("1")
	local rows_input = source("25")

	local page = source(1)
	local rows = source(20)

	effect(function()
		page_input(tostring(page()))
	end)

	effect(function()
		rows_input(tostring(rows()))
	end)

	effect(function()
		local page = page()
		local rows_per_page = rows()

		local from = (page - 1) * rows_per_page + 1
		local upto = from + rows_per_page - 1

		props.from(from)
		props.upto(upto)
	end)

	local row_template = {
		Size = UDim2.new(0, 0, 0, 26),
		AutomaticSize = Enum.AutomaticSize.X
	} :: any

	return pebble.widget {
		title = "Querying",
		subtitle = `host: {props.host} vm: {props.vm} id: {props.id}`,

		min_size = Vector2.new(300, 300),

		bind_to_close = props.destroy,

		create "Frame" {

			Size = UDim2.fromScale(1, 1),
			BackgroundTransparency = 1,

			tooltip {
				transparency = 0.3,
				visible = function()
					return props.entity_hovering_over() and #props.entity_hovering_over() > 0 or false
				end,

				pebble.typography {
					automaticsize = Enum.AutomaticSize.XY,

					text = function()
						return props.entity_hovering_over() or ""
					end,
					xalignment = Enum.TextXAlignment.Left,
					wrapped = true,
					code = true,
					
					{ RichText = true },

					create "UIStroke" {
						Thickness = 1,
						Color = pebble.theme.bg[-5]
					}
				}
			},

			create "Highlight" {
				DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
				OutlineColor = Color3.new(1, 1, 1),
				FillColor = pebble.theme.acc[0],
				FillTransparency = 0.5,
	
				Adornee = props.hovering_over
			},

			create "UIListLayout" {
				VerticalFlex = Enum.UIFlexAlignment.SpaceAround,
				Padding = UDim.new(0, 8)
			},

			create "Frame" {
				Name = "Query + Pick",
				Size = UDim2.new(1, 0, 0, 30),

				BackgroundTransparency = 1,
				
				create "UIListLayout" {
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalFlex = Enum.UIFlexAlignment.SpaceAround,
					VerticalFlex = Enum.UIFlexAlignment.SpaceAround,
					Padding = UDim.new(0, 8)
				},

				create "Frame" {

					Name = "Query",

					Size = UDim2.fromScale(0, 1),
					BackgroundTransparency = 1,

					create "UIFlexItem" {
						FlexMode = Enum.UIFlexMode.Fill
					},

					pebble.textfield {
						size = UDim2.new(1, 0, 0, 30),
						placeholder = "Query",
		
						code = true,
		
						oninput = function(text)
							props.validate_query(text)
						end,
		
						enter = function(text)
							props.update_system_query(text)
						end
					},

				},

				pebble.button {
					size = UDim2.fromOffset(30, 30),
	
					text = "",

					accent = props.enable_pick,

					activated = function()
						props.enable_pick(not props.enable_pick())
					end,
					
					create "ImageLabel" {
						Size = UDim2.fromOffset(24, 24),
						Position = UDim2.fromScale(0.5, 0.5),
						AnchorPoint = Vector2.new(0.5, 0.5),
	
						BackgroundTransparency = 1,

						ImageColor3 = pebble.theme.fg_on_bg_high[3],
	
						Image = "rbxassetid://10734898355"
					},
	
				},

			},

			create "Frame" {
				Size = UDim2.new(1, 0, 0, 24),

				BackgroundTransparency = 1,

				Visible = function()
					return not props.ok() and #props.msg() > 0
				end,
				
				pebble.typography {
					text = props.msg
				},

			},

			create "Frame" {
				
				Size = UDim2.new(1, 0, 0, 32),

				BackgroundColor3 = pebble.theme.bg[2],
				AutomaticSize = Enum.AutomaticSize.Y,

				create "UICorner" {
					CornerRadius = UDim.new(0, 8)
				},

				create "UIListLayout" {
					FillDirection = Enum.FillDirection.Horizontal,
					Padding = UDim.new(0, 8),
					HorizontalFlex = Enum.UIFlexAlignment.SpaceAround,
					VerticalAlignment = Enum.VerticalAlignment.Center,
					Wraps = true
				},

				pebble.row {
					spacing = UDim.new(0, 8),
					alignitems = Enum.ItemLineAlignment.Center,
					row_template,

					pebble.typography {
						text = "Page:"
					},
	
					pebble.textfield {
						size = UDim2.fromOffset(40, 26),
						placeholder = "1",
						
						text = function()
							return page_input()
						end,
	
						oninput = page_input,
	
						enter = function(text)
							local n = tonumber(text)
	
							if n == nil then
								page_input(tostring(page()))
							else
								page(n)
							end
						end
					},

					pebble.typography {
						text = function()
							return `/ {math.ceil(props.total_entities() / rows())}`
						end
					},
				},


				pebble.row {
					spacing = UDim.new(0, 8),
					alignitems = Enum.ItemLineAlignment.Center,
					row_template,

					pebble.typography {
						text = "Rows:"
					},

					pebble.textfield {
						size = UDim2.fromOffset(40, 26),
						placeholder = "Rows",

						text = function()
							return rows_input()
						end,

						oninput = rows_input,

						enter = function(text)
							local n = tonumber(text)

							if n == nil then
								rows_input(tostring(rows()))
							else
								rows(n)
							end
						end
					},
				},

				pebble.row {
					spacing = UDim.new(0, 4),
					row_template,
					
					pebble.button {
						size = UDim2.fromOffset(26, 26),
						text = "",

						accent = function()
							return not props.paused()
						end,

						activated = function()
							props.paused(not props.paused())
						end,

						{LayoutOrder = 10},
						
						create "ImageLabel" {
							Size = UDim2.fromOffset(24, 24),
							Position = UDim2.fromScale(0.5, 0.5),
							AnchorPoint = Vector2.new(0.5, 0.5),
		
							BackgroundTransparency = 1,

							ImageColor3 = pebble.theme.fg_on_bg_high[3],
		
							Image = function()
								return if props.paused() then "rbxassetid://10735024209"
							else "rbxassetid://10734923214"
							end
						},
		
					},

					show(props.paused, function()
						return pebble.button {
							size = UDim2.fromOffset(26, 26),
							text = "",
		
							activated = function()
								props.refresh(true)
							end,
							
							create "ImageLabel" {
								Size = UDim2.fromOffset(24, 24),
								Position = UDim2.fromScale(0.5, 0.5),
								AnchorPoint = Vector2.new(0.5, 0.5),
			
								BackgroundTransparency = 1,
		
								ImageColor3 = pebble.theme.fg_on_bg_high[3],
			
								Image = "rbxassetid://10734933222"
							},
			
						}
					end)
				}

			},


			pebble.background {
				size = UDim2.fromScale(1, 0),
				automaticsize = Enum.AutomaticSize.Y,

				create "UICorner" {
					CornerRadius = UDim.new(0, 8)
				},
				
				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				},
				
				pebble.tablesheet {
					size = UDim2.fromScale(1, 1),
					suggested_column_sizes = { 0.1 },

					column_sizes = function()
						local t = {}
						for i in props.columns() do
							t[i] = 200
						end
						t[1] = 50
						return t
					end,
					columns = props.columns,
	
					read_value = function(c, r)
						local column = props.columns()[c]
						if not column then return "" end
						return column[r] or ""
					end,
	
					on_click = function(c, r)
						if not props.columns()[1][r-1] then return end
						spawn_app.spawn_app(entity, {
							host = props.host,
							vm = props.vm,
							id = props.id,
							entity = props.columns()[1][r-1]
						})
					end,
					on_click2 = function() end,

					below = {

						pebble.padding {
							x = UDim.new(0, 4),
							y = UDim.new(0, 2)
						},

						create "UIListLayout" {
							FillDirection = Enum.FillDirection.Horizontal,
							VerticalAlignment = Enum.VerticalAlignment.Center,
							Padding = UDim.new(0, 8)
						},

						pebble.button {
							size = UDim2.fromOffset(70, 26),
							text = "Previous",

							activated = function()
								page(page() - 1)
							end,

							disabled = function()
								return page() == 1 or props.ok() == false
							end
						} :: Instance,

						pebble.button {
							size = UDim2.fromOffset(70, 26),
							text = "Next",

							activated = function()
								page(page() + 1)
							end,

							disabled = function()
								local max_pages = math.max(1, math.ceil(props.total_entities() / rows()))
								return page() == max_pages or props.ok() == false
							end
						} :: Instance,
						
						pebble.typography {
							position = UDim2.new(0, 4, 0.5, 0),
							anchorpoint = Vector2.new(0, 0.5),

							text = function()
								return `total entities: {props.total_entities()}\tfrom: {props.from()}\tuntil: {props.upto()}`
							end,
						} :: Instance,
					}
				}

			}

		}

	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c1</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="47">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">system</string>
										<string name="ScriptGuid">{57330B4B-F0AD-4171-BA8D-155108A76B51}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local loop = require(script.Parent.Parent.Parent.modules.loop)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local types = require(script.Parent.Parent.Parent.modules.types)
local widget = require(script.widget)

local cleanup = vide.cleanup

local system = {
	class_name = "app" :: "app",
	name = "System"
}

type props = {
	host: number,
	vm: number,
	scheduler: number,
	system: number,

	name: string

}

function system.mount(props: props, destroy: () -> ())

	local watch_id = math.random(2^31 - 1)
	local recording = vide.source(false)
	local watching_frame = vide.source(0)
	local per_frame_data = vide.source({} :: {[number]: number})
	local changes = vide.source({
		component = {},
		entities = {},
		types = {},
		values = {}
	} :: types.WatchLoggedChanges)

	local system_props_data = {
		watch_id = watch_id,
		host = props.host,
		vm = props.vm,
		scheduler = props.scheduler,
		system = props.system,
		name = props.name,

		changes = changes,
		recording = recording,
		per_frame_data = per_frame_data,
		watching_frame = watching_frame,
		destroy = destroy,
	}

	local app_loop = loop (
		"app-client-system",
		system_props_data,

		{i = 1},
		script.systems.replicate
	)

	local outgoing: types.OutgoingConnector = {
		host = system_props_data.host,
		to_vm = system_props_data.vm
	}

	remotes.create_watch:fire(outgoing, props.scheduler, props.system, watch_id)
	remotes.connect_watch:fire(outgoing, watch_id)

	cleanup(RunService.Heartbeat:Connect(app_loop))
	cleanup(function()
		remotes.disconnect_watch:fire(outgoing, watch_id)
		remotes.stop_watch:fire(outgoing, watch_id)
		remotes.remove_watch:fire(outgoing, watch_id)
	end)

	return widget(system_props_data)

end

return system]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c2</UniqueId>
									</Properties>
									<Item class="Folder" referent="48">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">systems</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c3</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="49">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">replicate</string>
												<string name="ScriptGuid">{4E87CF7C-BB7E-4CF5-8AB6-6AEE4C1626C3}</string>
												<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.Parent.Parent.vide)
local queue = require(script.Parent.Parent.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.Parent.Parent.modules.remotes)
local types = require(script.Parent.Parent.Parent.Parent.Parent.modules.types)

local batch = vide.batch

type Context = {
	host: "server" | Player,
	vm: number,

	watch_id: number,
	scheduler: number,
	system: number,
	name: string,

	recording: vide.Source<boolean>,
	watching_frame: vide.Source<number>,
	per_frame_data: vide.Source<{[number]: number}>,
	changes: (types.WatchLoggedChanges) -> (),
}

return function(context: Context)

	local watch_id = context.watch_id
	local outgoing: types.OutgoingConnector = {
		host = context.host,
		to_vm = context.vm
	}

	local recording_state_changed = false
	local recording = false

	vide.effect(function()
		recording_state_changed = true
		recording = context.recording()
	end)

	local watching_frame_changed = false
	local watching_frame = 1
	vide.effect(function()
		watching_frame_changed = true
		watching_frame = context.watching_frame()
	end)

	local receive_update_data = queue(remotes.update_watch_data)
	local receive_overview = queue(remotes.update_overview)

	return function()

		if recording_state_changed and recording then
			remotes.start_record_watch:fire(outgoing, watch_id)
			recording_state_changed = false
		elseif recording_state_changed and not recording then
			remotes.stop_watch:fire(outgoing, watch_id)
			recording_state_changed = false
		end

		if watching_frame_changed then
			remotes.request_watch_data:fire(outgoing, watch_id, watching_frame)
			watching_frame_changed = false
		end

		debug.profilebegin("receive update data")
		batch(function()
			for from, watch, frame, changes in receive_update_data:iter() do
				if watch ~= watch_id then continue end
				if frame ~= watching_frame then continue end
				if changes == nil then
					context.changes({
						types = {},
						entities = {},
						component = {},
						values = {},
						worlds = {}
					})
				else
					context.changes(changes)
				end
			end
		end)
		debug.profileend()

		debug.profilebegin("receive overview")
		batch(function()
			for from, watch, frame, value in receive_overview:iter() do
				if watch ~= watch_id then continue end
				local data = context.per_frame_data()
				if data[frame] == value then continue end
				data[frame] = value
				context.per_frame_data(data)
			end
		end)
		debug.profileend()
		
	end
end]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c4</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="ModuleScript" referent="50">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">watch_tracker</string>
											<string name="ScriptGuid">{E10F4A29-0552-4254-894D-47CC40B912C8}</string>
											<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local types = require(script.Parent.Parent.Parent.Parent.modules.types)
local tooltip = require(script.Parent.Parent.Parent.components.tooltip)
local virtualscroller_horizontal = require(script.Parent.Parent.Parent.components.virtualscroller_horizontal)

local create = vide.create
local source = vide.source

type props = {
	host: "server" | Player,
	vm: number,

	scheduler: number,
	system: number,
	name: string,

	recording: vide.Source<boolean>,
	watching_frame: vide.Source<number>,
	per_frame_data: () -> {[number]: number},
	changes: () -> types.WatchLoggedChanges,
}

local PROFILER_THICKNESS = 6

return function(props: props)

	local is_recording = props.recording
	local watching_frame = props.watching_frame
	local per_frame_data = props.per_frame_data
	local changes = props.changes

	local function sheet_changes()
		local changes = changes()

		return {
			{"type", unpack(changes.types)},
			{"entity", unpack(changes.entities)},
			{"component", unpack(changes.component)},
			{"value", unpack(changes.values)}
		}
	end

	local function max()
		return math.max(1, unpack(per_frame_data()))
	end
	
	local function total_changes()
		local sum = 0
		for _, value in per_frame_data() do
			sum += value
		end
		return sum
	end

	local hovering_over = source(false)

	return pebble.list {
		justifycontent = Enum.UIFlexAlignment.SpaceEvenly,
		spacing = UDim.new(0, 4),

		pebble.pane {
			virtualscroller_horizontal {
				item_size = PROFILER_THICKNESS,
				item = function(index)
					local function value()
						return per_frame_data()[index()] or 0
					end

					return create "TextButton" {
						Size = function()
							return UDim2.new(0, PROFILER_THICKNESS, 1, 0)
						end,
						BackgroundTransparency = function()
							return if hovering_over() == index() then 0.5 else 1
						end,
						BackgroundColor3 = pebble.theme.bg[10],
						
						MouseEnter = function()
							hovering_over(index())
						end,
						MouseLeave = function()
							if hovering_over() ~= index() then return end
							hovering_over(false)
						end,
						Activated = function()
							watching_frame(index())
						end,
						AutoLocalize = false,

						create "Frame" {
							Size = function()
								return UDim2.fromScale(1, value() / max())
							end,
							Position = UDim2.fromScale(1, 1),
							AnchorPoint = Vector2.new(1, 1),
							BackgroundColor3 = function()
								return if watching_frame() == index() then
									pebble.theme.acc[20]()
								elseif hovering_over() == index() then
									pebble.theme.acc[5]()
								else pebble.theme.acc[0]()
							end,
						}

					}
				end,
				max_items = function()
					return #per_frame_data()
				end,

				create "UIStroke" {Color = pebble.theme.bg[-3]},

				{
					Size = UDim2.new(1, 0, 0, 56),
					HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					BackgroundColor3 = pebble.theme.bg[-1],
					ScrollBarThickness = 6,

					CanvasPosition = function()
						per_frame_data()
						return Vector2.new(table.maxn(per_frame_data()) * PROFILER_THICKNESS)
					end,
				}
			},

			pebble.typography {
				text = function()
					return `Recorded {#per_frame_data()} frames and tracked {total_changes()} changes`
				end
			},

			pebble.typography {
				text = function()
					return `Currently viewing frame {watching_frame()}`
				end
			}
		},

		tooltip {
			transparency = 0,
			visible = function()
				return hovering_over() ~= false
			end,
			
			pebble.typography {
				automaticsize = Enum.AutomaticSize.XY,

				text = function()
					return `\z
					Frame: #{hovering_over()}\n\z
					Changes: {per_frame_data()[hovering_over()] or 0}`
				end,
				xalignment = Enum.TextXAlignment.Left,
				wrapped = true
			}
		},
		
		pebble.container {
			Size = UDim2.fromScale(1, 0),
			AutomaticSize = Enum.AutomaticSize.Y,
			BackgroundColor3 = pebble.theme.bg[1],
			BackgroundTransparency = 0,

			create "UIListLayout" {
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalFlex = Enum.UIFlexAlignment.SpaceEvenly,
				VerticalFlex = Enum.UIFlexAlignment.Fill,
				Padding = UDim.new(0, 8)
			},

			pebble.padding {
				x = UDim.new(0, 4),
				y = UDim.new(0, 4)
			},

			pebble.button {
				size = UDim2.new(0, 80, 0, 30),
				automaticsize = Enum.AutomaticSize.X,
				text = function()
					return if is_recording() then "Pause" else "Record"
				end,

				activated = function()
					is_recording(not is_recording())
				end
			},
			
			pebble.container {
				Size = UDim2.fromScale(0, 0),

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				},

				pebble.textfield {
					size = UDim2.new(1, 0, 1, 0),
					text = tostring(watching_frame()),
					placeholder = "frame",

					enter = function(text: string)
						if tonumber(text) == nil then return end
						watching_frame(tonumber(text)) 
					end
				}
			},

		},

		pebble.container {
			Size = UDim2.fromScale(1, 1),
			
			create "UIFlexItem" {
				FlexMode = Enum.UIFlexMode.Fill
			},

			pebble.tablesheet {
				size = UDim2.fromScale(1, 1),

				column_sizes = source {100, 80, 100, 200},
				read_value = function(column, row)
					local v = sheet_changes()[column][row]
					return if v == false then "" else v
				end,

				on_click = function() end,
				on_click2 = function() end,

				columns = sheet_changes
			}

		}
	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c5</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="51">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">widget</string>
											<string name="ScriptGuid">{5BD73231-E4BA-43D8-B458-433C7D93F9DB}</string>
											<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local types = require(script.Parent.Parent.Parent.Parent.modules.types)
local watch_tracker = require(script.Parent.watch_tracker)

type props = {
	host: "server" | Player,
	vm: number,

	scheduler: number,
	system: number,
	name: string,

	destroy: () -> (),

	recording: vide.Source<boolean>,
	watching_frame: vide.Source<number>,
	per_frame_data: () -> {[number]: number},
	changes: () -> types.WatchLoggedChanges,
}

return function(props: props)

	return pebble.widget {
		title = `system - {props.name}`,
		subtitle = `host: {props.host} vm: {props.vm} scheduler: {props.scheduler} system: {props.system}`,
		bind_to_close = props.destroy,
		size = Vector2.new(350, 400),
		min_size = Vector2.new(300, 300),

		watch_tracker(props)
	}

end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c6</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="52">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">components</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c7</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="53">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">tooltip</string>
										<string name="ScriptGuid">{B4DC31DA-B32B-488B-B5FD-5FB3E6F8CBDA}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local pebble = require(script.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local source = vide.source
local cleanup = vide.cleanup

type props = {
	visible: boolean | () -> boolean,
	transparency: number? | () -> number,
	[number]: any
}

return function(props: props)

	local mouse_location = source(Vector2.zero)

	cleanup(RunService.PreRender:Connect(function()
		mouse_location(UserInputService:GetMouseLocation())
	end))

	return create "ScreenGui" {
		Name = "Mouse Hover",
		IgnoreGuiInset = true,
		DisplayOrder = 1e9,
		Enabled = props.visible,

		create "Frame" {
			Position = function()
				return UDim2.fromOffset(
					mouse_location().X + 24,
					mouse_location().Y + 24
				)
			end,
			Size = UDim2.fromOffset(400, 0),
			AutomaticSize = Enum.AutomaticSize.XY,
			BackgroundColor3 = pebble.theme.bg[0],
			BackgroundTransparency = props.transparency or 0.5,

			pebble.padding {},

			create "UICorner" {
				CornerRadius = UDim.new(0, 8)
			},

			create "UIStroke" {
				Color = pebble.theme.bg[-10],
				Thickness = 2,
				Transparency = 0.8
			},

			unpack(props)
		}

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="54">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">virtualscroller_horizontal</string>
										<string name="ScriptGuid">{70C9975D-C2F2-40A5-8BCF-1E39388DC34B}</string>
										<ProtectedString name="Source"><![CDATA[local pebble = require(script.Parent.Parent.Parent.Parent.pebble)
local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local source = vide.source
local values = vide.values
local changed = vide.changed
local effect = vide.effect
local untrack = vide.untrack

type can<T> = T | () -> T
type props = {

	size: can<UDim2>?,
	position: can<UDim2>?,
	anchorpoint: can<UDim2>?,

	--- streams in items. when index is -1, should expect to be unused
	item: (index: () -> number) -> Instance,
	--- streams in separators. when index is -1, should expect to be unused
	separator: ((index: () -> number) -> Instance)?,

	item_size: number,
	separator_size: number?,

	max_items: (() -> number)?,

	[number]: any

}

return function(props: props)

	local items = source({} :: {vide.Source<number>})

	local absolute_size = source(Vector2.zero)
	local canvas_position = source(Vector2.zero)

	local item_size = props.item_size
	local separator_size = props.separator_size or 0

	local item = props.item
	local separator = props.separator

	local OVERFLOW_ONE_SIDE = 4

	effect(function()
		local absolute_size = absolute_size()
		local canvas_position = canvas_position()

		local child_size = item_size + separator_size
		local total_required = math.ceil(absolute_size.X / child_size) + OVERFLOW_ONE_SIDE * 2
		local sources = untrack(items)

		local min_index = math.floor(canvas_position.X / child_size)
		local max_index = math.ceil((canvas_position.X + absolute_size.X) / child_size)

		local max_items = math.huge
		if props.max_items then
			max_items = props.max_items()
		end

		untrack(function()
			-- mark any sources out of range as unused
			local unused = {}

			for i, s in sources do
				local index = s()

				if
					index >= math.max(min_index, 1)
					and index <= math.min(max_index, max_items)
				then continue end
				unused[i] = true
				s(-1)
			end

			-- add sources necessary
			if #sources < total_required then
				for i = #sources + 1, total_required do
					sources[i] = source(-1)
					unused[i] = true
				end
				items(sources)
			end

			-- update indexes of any sources that went unused
			local did_not_render = {}

			for i = math.max(min_index, 1), math.min(max_index, max_items) do
				did_not_render[i] = true
			end
			

			for _, s in sources do
				did_not_render[s()] = nil
			end

			for index in unused do
				local s = sources[index]
				local key = next(did_not_render)
				if not key then break end
				s(key)
				did_not_render[key] = nil
				unused[index] = nil
			end
			
			if next(did_not_render) then warn("missing source!", next(did_not_render)) end

			-- remove unnecessary sources
			if #sources > total_required then
				for i = #sources, 1, -1 do
					if unused[i] then
						table.remove(sources, i)
					end
					unused[i] = nil
					if #sources < total_required then break end
				end
				items(sources)
			end

		end)

	end)

	return create "ScrollingFrame" {

		Size = props.size or UDim2.fromScale(1, 1),
		Position = props.position,
		AnchorPoint = props.anchorpoint,

		BackgroundTransparency = 1,

		CanvasSize = function()
			if props.max_items then
				return UDim2.fromOffset(props.max_items() * (item_size + separator_size), 0)
			else
				local absolute_size = absolute_size()
				local canvas_position = canvas_position()
				local child_size = item_size + separator_size
				local max_index = math.ceil((canvas_position.X + absolute_size.X) / child_size) + OVERFLOW_ONE_SIDE
				return UDim2.fromOffset(max_index * child_size, 0)
			end
		end,

		values(items, function(index)
			return create "Frame" {
				Name = index,

				Position = function()
					if index() == -1 then UDim2.fromOffset(0, -1000) end
					return UDim2.fromOffset(
						(item_size + separator_size) * (index() - 1),
						0
					)
				end,
				Size = UDim2.new(0, item_size + separator_size, 1, 0),

				BackgroundTransparency = 1,

				pebble.container {
					Name = "Item",
					
					item(index),
				},

				if separator then
					pebble.container {
						Name = "Separator",

						separator(index)
					}
				else nil,
				
			}
		end),

		changed("AbsoluteSize", absolute_size),
		changed("CanvasPosition", canvas_position),

		unpack(props),

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003c9</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="55">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">spawn_app</string>
									<string name="ScriptGuid">{48C69F90-FD66-41F3-A3B4-A2C7F051E469}</string>
									<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local vide = require(script.Parent.Parent.Parent.vide)
local types = require(script.Parent.Parent.modules.types)

local destroy_fn = {}

local function unmount_all()
	for destroy in destroy_fn do
		destroy()
	end
end

local function spawn_app<T>(app: types.Application<T>, props: T): () -> ()
	return vide.root(function(destroy)

		local destroy = function()
			destroy_fn[destroy] = nil
			destroy()
		end

		local application = app.mount(props, destroy)
		application.Parent = Players.LocalPlayer.PlayerGui

		vide.cleanup(application)
		
		destroy_fn[destroy] = true
		
		return destroy
	end)
end

return {
	unmount_all = unmount_all,
	spawn_app = spawn_app
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ca</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">modules</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003cb</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="57">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">average</string>
									<string name="ScriptGuid">{6FC69A8C-C61C-4C7C-9148-0689AF6ED18F}</string>
									<ProtectedString name="Source"><![CDATA[

local function average(n: {number})
	local sum = 0
	for i, v in n do
		sum += v
	end
	return sum / #n
end

return average]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003cc</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="58">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">convert_units</string>
									<string name="ScriptGuid">{41977148-56D7-421A-85C8-81F898C99F0C}</string>
									<ProtectedString name="Source"><![CDATA[local function convert_units(unit: string, value: number): (string)
	local s = math.sign(value)
	value = math.abs(value)
    local prefixes = {
        [4] = "T",
        [3] ="G",
        [2] ="M",
        [1] = "k",
        [0] = " ",
        [-1] = "m",
        [-2] = "u",
        [-3] = "n",
        [-4] = "p"
    }

    local order = 0
    
    while value >= 1000 do
        order += 1
        value /= 1000
    end

    while value ~= 0 and value < 1 do
        order -= 1
        value *= 1000
    end

    if value >= 100 then
        value = math.floor(value)
    elseif value >= 10 then
        value = math.floor(value * 1e1) / 1e1
    elseif value >= 1 then
        value = math.floor(value * 1e2) / 1e2
    end

    return value * s .. prefixes[order] .. unit
end

return convert_units]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003cd</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="59">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">hash_connector</string>
									<string name="ScriptGuid">{15FB0393-F465-4A55-8581-1A2C60D75A0D}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.types)

return function(connector: types.IncomingConnector | types.OutgoingConnector)
	return `{connector.host}\0{connector.from_vm or connector.to_vm}`
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ce</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="60">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lon</string>
									<string name="ScriptGuid">{3356CDE1-2425-4CE0-AA01-C90AF90B42B2}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
local function stream(input: string)

	local pos = 0
	local line = 1
	local col = 1

	local function peek(): string
		return string.sub(input, pos+1, pos+1)
	end

	local function next(): string
		local char = peek()
		pos += 1

		if char == "\n" then line += 1; col = 1
		else col += 1 end

		return char
	end

	local function eof(): boolean
		return peek() == ""
	end

	local function position()
		return {
			pos = pos,
			line = line,
			col = col
		}
	end

	local function croak(msg)
		error(`{msg} ({line}:{col})`, 0)
	end

	return {
		peek = peek,
		next = next,
		eof = eof,
		croak = croak,
		pos = position
	}

end

export type String = {type: "string", s: string}
export type Number = {type: "number", s: number}
export type Identifier = {type: "identifier", s: string}
export type Keyword = {type: "keyword", s: "true" | "false" | "nil"}
export type Operator = {type: "operator", s: "="}
export type Symbol = {type: "symbol", s: "." | ":" | "[" | "]" | "{" | "}" | "(" | ")" | "," | ";"}

export type Token =
	| String
	| Number
	| Identifier
	| Keyword
	| Operator
	| Symbol

local digits = ("0123456789"):split("")
local alphabet = ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"):split("")
local symbols = ("[]{}(),;.:"):split("")

local escape_chars = {
	a = "\a",
	b = "\b",
	f = "\f",
	n = "\n",
	r = "\r",
	t = "\t",
	v = "\v",
	["\\"] = "\\",
	["\""] = "\"",
	["\'"] = "\'"
}
local keywords = {"true", "false"}

local function lex(source: string)

	local input = stream(source)

	local function is_whitespace(char: string): boolean
		return not not string.match(char, "%s")
	end

	local function is_digit(char: string): boolean
		return not not table.find(digits, char)
	end

	local function is_identifier(char: string): boolean
		return not not table.find(alphabet, char) or not not table.find(digits, char)
	end

	local function is_start_identifier(char: string): boolean
		return not not table.find(alphabet, char)
	end

	local function is_op_char(char: string): boolean
		return char == "="
	end

	local function is_punc(char: string): boolean
		return not not table.find(symbols, char)
	end

	local function read_while(predicate: (char: string) -> boolean)
		local str = ""
		while input.eof() == false and predicate(input.peek()) do
			str ..= input.next()
		end
		return str
	end

	local function skip_comment()
		read_while(function(char) return char ~= "\n" end)
	end

	local function skip_whitespace()
		read_while(is_whitespace)
	end

	local function read_string(): String
		local escaped = false
		local token = ""
		local eliminator = input.next()

		while input.eof() == false and (input.peek() ~= eliminator or escaped) do
			local char = input.next()
		
			if char == "\\" then
				escaped = true
			end

			if escaped then
				token ..= escape_chars[char] or input.croak(`cannot escape {char}`)
				escaped = false
			else
				token ..= char
			end
		end

		-- print("t", token, eliminator, input.peek())

		if input.peek() ~= eliminator then input.croak("unterminated string") end
		input.next()
		return {type = "string", s = token}
	end

	local function read_number(): Number
		local sign = 1
		if input.peek() == "-" then sign = -1; input.next() end

		local token = read_while(function(char)
			return is_digit(char) or char == "." or char == "e"
		end)

		local n = tonumber(token)

		if not n then
			input.croak(`could not read {token} as number`)
		end

		return {type = "number", s = assert(n) * sign}
	end

	local function read_identifier(): Identifier | Keyword
		local token = read_while(is_identifier)

		if table.find(keywords, token) then
			return {type = "keyword", s = token :: any}
		else
			return {type = "identifier", s = token}
		end
	end

	local function read_next(): Token
		skip_whitespace()
		local char = input.peek()

		if char == "#" then
			-- skip comment
			skip_comment()
			return read_next()
		end
		
		if char == "\"" or char == "'" then return read_string() end
		if is_digit(char) then return read_number() end
		if is_start_identifier(char) then return read_identifier() end
		if is_op_char(char) then return {type = "operator" :: "operator", s = input.next() :: any} end
		if is_punc(char) then return {type = "symbol" :: "symbol", s = input.next() :: any} end
		if char == "-" then return read_number() end

		input.croak(`cannot lex "{char}" {string.byte(char)}`)
		error("fail")
	end

	local current: {Token} = {}

	local function next()
		local token = table.remove(current, 1)
		token = if token == nil then read_next() else token
		skip_whitespace()
		return token
	end

	local function peek(n: number?)
		local n = n or 1
		while #current < n do
			table.insert(current, read_next())
		end
		return current[n]
	end

	return {

		peek = peek,
		next = next,
		eof = input.eof,
		croak = input.croak,
		pos = input.pos

	}

end

type NodeNumber = {
	type: "number",
	value: number
}

type NodeString = {
	type: "string",
	value: string
}

type NodeBoolean = {
	type: "boolean",
	value: boolean
}

type NodeVariable = {
	type: "variable",
	value: string
}

type NodeTable = {
	type: "table",
	value: {NodeExpression | NodeAssign}
}

type NodeAssign = {
	type: "assign",
	key: NodeVariable | NodeExpression,
	value: NodeExpression
}

type NodeIndex = {
	type: "index",
	value: NodeExpression,
	key: NodeExpression
}

type NodeFunctionCall = {
	type: "functioncall",
	value: NodeExpression,
	args: {NodeExpression}
}

type NodeMethodCall = {
	type: "methodcall",
	value: NodeExpression,
	args: {NodeExpression}
}

type NodeExpression =
	| NodeNumber
	| NodeString
	| NodeBoolean
	| NodeTable
	| NodeIndex
	| NodeFunctionCall
	| NodeMethodCall
	| NodeVariable

type Node =
	| NodeNumber
	| NodeString
	| NodeBoolean
	| NodeTable
	| NodeIndex
	| NodeFunctionCall
	| NodeMethodCall
	| NodeAssign
	| NodeVariable

local function parse(source: string)

	local stream = lex(source)

	local node: Node?

	local function set_node(t: Node)
		node = t
	end

	local function pop_node(): Node
		local stored = node
		node = nil
		if stored == nil then
			stream.croak("no available node")
			error("")
		end
		return stored
	end

	local function is_symbol(s: string)
		local node = stream.peek()
		return node.type == "symbol" and node.s == s
	end

	local function is_op(s: string)
		local node = stream.peek()
		return node.type == "operator" and node.s == s
	end

	local function is_keyword(s: string)
		local node = stream.peek()
		return node.type == "keyword" and node.s == s
	end

	local function skip_symbol(ch)
		if is_symbol(ch) then
			stream.next()
		else
			stream.croak(`expecting symbol: "{ch}" got "{stream.peek(1).s}"`)
			error("")
		end
	end

	local function skip_operator(ch)
		if is_op(ch) then
			stream.next()
		else
			stream.croak(`expecting op: "{ch}" got "{stream.peek().s}"`)
			error("")
		end
	end

	local function delimited(start, stop, separator: string | () -> (), parser: () -> ())
		local a = {}
		local first = true
		skip_symbol(start)
		while not stream.eof() do
			if is_symbol(stop) then break end
			if first then
				first = false
			elseif typeof(separator) == "string" then
				skip_symbol(separator)
			elseif typeof(separator) == "function" then
				separator()
			end
			if is_symbol(stop) then break end
			parser()
			table.insert(a, pop_node())
			-- print('next')
		end
		skip_symbol(stop)
		return a
	end

	local parse_functioncall
	local parse_identifier
	local parse_expression
	local parse_table
	local parse_index

	function parse_table()
		local values = delimited("{", "}", ",", function()
			
			if is_symbol("[") then
				skip_symbol("[")
				parse_expression()
				skip_symbol("]")

				local key = pop_node() :: NodeExpression
				
				skip_operator("=")
				parse_expression()

				local value = pop_node() :: NodeExpression

				set_node({
					type = "assign",
					key = key,
					value = value
				} :: NodeAssign)
			else
				if stream.peek(2).type == "operator" and stream.peek(2).s == "=" then
					parse_identifier "string"
					
					local key = pop_node() :: NodeString

					skip_operator("=")
					
					parse_expression()

					local value = pop_node() :: NodeExpression

					set_node ({
						type = "assign",
						key = key,
						value = value
					} :: NodeAssign)

				else
					parse_expression()
				end
			end

		end)

		set_node {
			type = "table",
			value = values
		}
	end

	function parse_functioncall(is_method: boolean)
		local value = pop_node()
		local arguments = delimited("(", ")", ",", function()
			parse_expression()
		end)

		set_node ({
			type = if is_method then "methodcall" else "functioncall",
			value = value,
			args = arguments
		} :: NodeFunctionCall | NodeFunctionCall)
	end

	function parse_index()
		if is_symbol(".") then
			local value = pop_node() :: NodeExpression

			skip_symbol(".")
			parse_identifier("string")

			local key = pop_node() :: NodeString

			set_node {
				type = "index",
				value = value,
				key = key
			}
		elseif is_symbol("[") then
			local value = pop_node() :: NodeExpression

			skip_symbol("[")
			parse_expression()
			skip_symbol("]")

			local key = pop_node() :: NodeExpression

			set_node {
				type = "index",
				value = value,
				key = key
			}
		elseif is_symbol(":") then
			local value = pop_node() :: NodeExpression

			skip_symbol(":")
			parse_identifier("string")

			local key = pop_node() :: NodeString

			set_node {
				type = "index",
				value = value,
				key = key
			}

			parse_functioncall(true)
		else
			stream.croak(`expected index or function call, got {stream.peek().s}`)
		end
	end

	function parse_identifier(as: "string" | "variable")
		local token = stream.next()
		if token == nil then
			stream.croak("expected identifier, got eof")
			error("")
		end

		if token.type == "identifier" then
			set_node({type = as, value = token.s} :: NodeVariable | NodeString)
		else
			stream.croak(`expected identifier, got {token.type}`)
		end
	end

	function parse_expression()
		local token = stream.peek()

		if token.type == "identifier" then
			parse_identifier "variable"

			while
				stream.eof() == false and
				(
					is_symbol(".") or
					is_symbol("[") or
					is_symbol("(") or is_symbol(":")
				)
			do
				if stream.eof() then break end
				if is_symbol("(") then
					parse_functioncall(false)
				else
					parse_index()
				end
				if stream.eof() then break end
			end
		elseif token.type == "string" then
			set_node {type = "string", value = assert(stream.next()).s :: string}
		elseif token.type == "number" then
			set_node {type = "number", value = assert(stream.next()).s :: number}
		elseif is_keyword("true") then
			set_node {type = "boolean", value = true}
			stream.next()
		elseif is_keyword("false") then
			set_node {type = "boolean", value = false}
			stream.next()
		elseif is_symbol("{") then
			parse_table()
		else
			stream.croak(`expected expression, got {token.type}" "{token.s}"`)
		end

	end

	parse_expression()

	return pop_node()

end

local tuple = {}

local lon_vars = {

	Vector3 = Vector3,
	CFrame = CFrame,
	Vector2 = Vector2,
	Color3 = Color3,
	BrickColor = BrickColor,
	Enum = Enum,

	NumberSequence = NumberSequence,
	NumberSequenceKeypoint = NumberSequenceKeypoint,
	NumberRange = NumberRange,

	ColorSequence = ColorSequence,
	ColorSequenceKeypoint = ColorSequenceKeypoint,

	Region3 = Region3,
	Rect = Rect,

	OverlapParams = function(properties)
		local params = OverlapParams.new()
		for key, value in properties do
			(params :: any)[key] = value
		end
		return params
	end,
	RaycastParams = function(properties)
		local params = RaycastParams.new()
		for key, value in properties do
			(params :: any)[key] = value
		end
		return params
	end,

	game = game,
	workspace = workspace,

}

local function compile(node: Node): any

	if node.type == "number" then
		return node.value
	elseif node.type == "string" then
		return node.value
	elseif node.type == "boolean" then
		return node.value
	elseif node.type == "variable" then
		return lon_vars[node.value]
	elseif node.type == "index" then
		return compile(node.value)[compile(node.key)]
	elseif node.type == "functioncall" then
		for i = 1, #node.args do
			tuple[i] = compile(node.args[i])
		end
		return compile(node.value)(unpack(tuple, 1, #node.args))
	elseif node.type == "methodcall" then
		for i = 1, #node.args do
			tuple[i] = compile(node.args[i])
		end
		local data = compile(node.value)
		return data(data, unpack(tuple, 1, #node.args))
	elseif node.type == "table" then
		local t = {}
		local i = 0

		for _, value in node.value do
			if value.type == "assign" then
				t[compile(value.key)] = compile(value.value)
			else
				t[i + 1] = compile(value); i += 1
			end
		end

		return t
	elseif node.type == "assign" then
		error("bad ast, you cannot generate this")
	end

	return nil
end

local output

do
	local max_size = 8192
	local buf = buffer.create(1024)
	local pos = 0
	local tbs = 0
	local enable_newlines = true
	local line_length = 0

	local cyclic_buffer = {}

	local function prealloc(bytes: number)
		local old_size = buffer.len(buf)

		if pos + bytes >= old_size then
			local new_size = old_size + old_size / 2
			while pos + bytes >= new_size do
				new_size = new_size + new_size / 2
			end

			local new_buf = buffer.create(new_size)
			buffer.copy(new_buf, 0, buf, 0, pos)
			buf = new_buf
		end
	end

	local function write_str(str: string)
		local old_size = buffer.len(buf)

		if pos + #str >= old_size then
			local new_size = old_size + old_size / 2
			while pos + #str >= new_size do
				new_size = new_size + new_size / 2
			end

			local new_buf = buffer.create(new_size)
			buffer.copy(new_buf, 0, buf, 0, pos)
			buf = new_buf
		end

		buffer.writestring(buf, pos, str, #str)
		pos += #str
		line_length += #str
	end

	local function write_low_prec_float(n: number)
		local s = string.format("%.7g", n)
		write_str(s)
		line_length += #s
	end

	local function char(c: string): number
		return (string.byte(c))
	end

	local function write_char(char: number)
		local old_size = buffer.len(buf)

		if pos + 1 >= old_size then
			local new_size = old_size + old_size / 2
			while pos + 1 >= new_size do
				new_size = new_size + new_size / 2
			end

			local new_buf = buffer.create(new_size)
			buffer.copy(new_buf, 0, buf, 0, pos)
			buf = new_buf
		end

		buffer.writeu8(buf, pos, char)
		line_length += 1
		pos += 1
	end

	export type Displayable = unknown-- number | string | boolean | { [Displayable]: Displayable }

	local function display_string(value: string)
		local f = string.format("%q", value)
		prealloc(#f)
		write_str(f)
	end

	local function write_line()
		if enable_newlines then
			write_char(char("\n"))
			write_str(string.rep("\t", tbs))
		else
			write_char(char(" "))
		end
	end

	local function display(value: Displayable)
		if max_size < pos then return end
		if type(value) == "number" then
			write_str(tostring(value))
		elseif type(value) == "string" then
			display_string(value)
		elseif type(value) == "boolean" then
			if value == true then
				write_str("true")
			else
				write_str("false")
			end
		elseif type(value) == "table" and not cyclic_buffer[value] then
			cyclic_buffer[value] = true
			tbs += 1
			write_char(char("{"))
			for index, value in value :: {[any]: any} do
				write_line()

				if type(index) == "string" and string.match(index, "^[a-zA-Z_][a-zA-Z0-9_]*$") then
					write_str(index)
				else
					write_char(char("["))
					display(index)
					write_char(char("]"))
				end

				write_char(char(" "))
				write_char(char("="))
				write_char(char(" "))
				
				display(value)
				write_char(char(","))
			end

			tbs -= 1
			write_line()
			write_char(char("}"))
		elseif type(value) == "table" and cyclic_buffer[value] then
			display_string(`*cyclic reference detected at {tbs}*`)
		elseif type(value) == "nil" then
			write_str("nil")
		-- ROBLOX DEVIATION START
		elseif typeof(value) == "BrickColor" then
			write_str("BrickColor.new(")
			write_str(value.Name)
			write_char(char(")"))
		elseif typeof(value) == "CFrame" then
			if value.Rotation == CFrame.new() then
				write_str("CFrame.new(")
				display(value.X)
				write_str(", ")
				display(value.Y)
				write_str(", ")
				display(value.Z)
				write_char(char(")"))
			else
				write_str("CFrame.fromMatrix(")
				display(value.Position)
				write_str(",\n")
				display(value.XVector)
				write_str(",\n")
				display(value.YVector)
				write_str(",\n")
				display(value.ZVector)
				write_str(",\n")
			end
		elseif typeof(value) == "EnumItem" then
			write_str(tostring(value))
		elseif typeof(value) == "Enum" then
			write_str("Enum.")
			write_str(tostring(value))
		elseif typeof(value) == "Enums" then
			write_str("Enum")
		elseif typeof(value) == "Color3" then
			write_str("Color3.fromHex(")
			display_string(value:ToHex())
			write_char(char(")"))
		elseif typeof(value) == "Vector3" then
			write_str("Vector3.new(")
			write_str(tostring(value))
			write_char(char(")"))
		elseif typeof(value) == "Vector2" then
			write_str("Vector2.new(")
			write_str(tostring(value))
			write_char(char(")"))
		elseif typeof(value) == "NumberSequence" then
			write_str("NumberSequence.new(")
			if #value.Keypoints == 2 then
				write_low_prec_float(value.Keypoints[1].Value)
				write_str(", ")
				write_low_prec_float(value.Keypoints[2].Value)
			else
				display(value.Keypoints)
			end
			write_char(char(")"))
		elseif typeof(value) == "NumberSequenceKeypoint" then
			write_str("NumberSequenceKeypoint.new(")
			write_low_prec_float(value.Time)
			write_str(", ")
			write_low_prec_float(value.Value)
			if value.Envelope > 0 then
				write_str(", ")
				write_low_prec_float(value.Envelope)
			end
			write_char(char(")"))
		elseif typeof(value) == "NumberRange" then
			write_str("NumberRange.new(")
			write_low_prec_float(value.Min)
			if value.Min ~= value.Max then
				write_str(", ")
				write_low_prec_float(value.Max)
			end
			write_char(char(")"))
		elseif typeof(value) == "ColorSequence" then
			write_str("ColorSequence.new(")
			if #value.Keypoints == 2 then
				display(value.Keypoints[1].Value)
				write_str(", ")
				display(value.Keypoints[2].Value)
			else
				display(value.Keypoints)
			end
			write_char(char(")"))
		elseif typeof(value) == "ColorSequenceKeypoint" then
			write_str("ColorSequenceKeypoint.new(")
			write_low_prec_float(value.Time)
			write_str(", ")
			display(value.Value)
			write_char(char(")"))
		elseif typeof(value) == "RaycastResult" then
			--note: since a RaycastResult can't be created, we convert it into a table
			display {
				Instance = value.Instance,
				Material = value.Material,
				Normal = value.Normal,
				Position = value.Position,
				Distance = value.Distance
			}
		elseif typeof(value) == "Region3" then
			local pos, size = value.CFrame.Position, value.Size
			local min = pos - size / 2
			local max = pos + size / 2
			write_str("Region3.new(")
			display(min)
			write_str(", ")
			display(max)
			write_char(char(")"))
		elseif typeof(value) == "Rect" then
			write_str("Rect.new(")
			write_low_prec_float(value.Min.X)
			write_str(", ")
			write_low_prec_float(value.Min.Y)
			write_str(", ")
			write_low_prec_float(value.Max.X)
			write_str(", ")
			write_low_prec_float(value.Max.Y)
			write_char(char(")"))
		elseif typeof(value) == "OverlapParams" then
			write_str("OverlapParams(")
			display({
				CollisionGroup = value.CollisionGroup,
				FilterType = value.FilterType,
				MaxParts = value.MaxParts,
				RespectCanCollide = value.RespectCanCollide,
			})
			write_char(char(")"))
		elseif typeof(value) == "RaycastParams" then
			write_str("RaycastParams(")
			display({
				CollisionGroup = value.CollisionGroup,
				FilterType = value.FilterType,
				RespectCanCollide = value.RespectCanCollide,
			})
			write_char(char(")"))
		elseif typeof(value) == "Instance" then
			write_str("game.")
			display_string(value:GetFullName())
		-- ROBLOX DEVIATION END
		else
			write_str(typeof(value))
			write_char(char("("))
			write_str(tostring(value))
			write_char(char(")"))
			warn(`unable to encode datatype "{typeof(value)}" into lua object notation`)
		end
	end

	output = function(value: Displayable, newlines: boolean?)
		enable_newlines = if newlines ~= nil then newlines else true

		pos = 0
		tbs = 0

		table.clear(cyclic_buffer)
		display(value)
		return buffer.readstring(buf, 0, pos)
	end
end

return {

	parse = parse,
	compile = function(node: Node, variables: {[string]: any})
		setmetatable(lon_vars, {__index = variables or nil})
		return compile(node)
	end,
	output = output

}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003cf</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="61">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">loop</string>
									<string name="ScriptGuid">{92C62B4D-BC83-49F4-B529-950E32CB6AEE}</string>
									<ProtectedString name="Source"><![CDATA[local scheduler = require(script.Parent.Parent.server.scheduler)
type Array<T> = { T }

export type System = (any, number) -> ...(any, number) -> ()

type GroupInfo = { i: number?, o: number? }

type SystemGroup = {
    interval: number,
    offset: number,
    dt: number,
    [number]: {
        id: number,
        name: string,
        type: number,
        fn: (...any) -> ...any
    }
}

local function loop_create(name: string, data: any, ...: ModuleScript | () -> () | GroupInfo)
    local jabby_scheduler = scheduler.create(name)
    
    local groups = {} :: Array<SystemGroup>

    local current_group: SystemGroup?

    local function process_systems(array: Array<any>)
        for i, v in array do
            if type(v) == "table" then
                if v.i then
                    if current_group then
                        table.insert(groups, current_group)
                    end

                    current_group = {
                        interval = v.i or 1,
                        offset = v.o or 0,
                        dt = 0
                    }
                else
                    process_systems(v)
                end
            elseif type(v) == "function" then 
                assert(current_group)

                table.insert(current_group, {
                    id = jabby_scheduler:register_system(),
                    name = "UNNAMED",
                    type = 0,
                    fn = v
                })
            else
                assert(current_group)

                local fn = (require :: any)(v) :: System
                local fn2 = fn(data, 0)

                table.insert(current_group, {
                    id = jabby_scheduler:register_system({name = `{v.Name}`}),
                    name = v.Name,
                    type = fn2 and 1 or 0,
                    fn = fn2 or fn
                })
            end
        end
    end

    process_systems { ... }

    assert(current_group)
    table.insert(groups, current_group)
    current_group = nil

    local frame_count = 0

    return function(dt)
        frame_count += 1

        debug.profilebegin("ECS LOOP")

        for _, group in groups do
            group.dt += dt

            if frame_count % group.interval == group.offset then
                for _, system in ipairs(group) do
                    debug.setmemorycategory(system.name)
                    debug.profilebegin(system.name)

                    if system.type == 0 then
                        jabby_scheduler:run(system.id, system.fn, data, group.dt)
                    else
                        jabby_scheduler:run(system.id, system.fn, group.dt)
                    end

                    debug.profileend()
                end

                group.dt = 0
            end
        end

        debug.resetmemorycategory()
        debug.profileend()
    end, jabby_scheduler
end

return loop_create]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="62">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">net</string>
									<string name="ScriptGuid">{8A515B11-704A-42DE-B0B7-FD27679A8757}</string>
									<ProtectedString name="Source"><![CDATA[--[[

	net is a utility library designed to handle connections to other actors and
	the server for me.

]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local signal = require(script.Parent.signal)
local vm_id = require(script.Parent.vm_id)
local traffic_check = require(script.Parent.traffic_check)
local types = require(script.Parent.types)

local local_host: "server" | Player
local MANAGER_VM = 0

if RunService:IsServer() then
	local_host = "server"
else
	local_host = Players.LocalPlayer
end

local function tincoming_connector(t: any): boolean
	if typeof(t) ~= "table" then return false end
	if not (t.host == "server" or (typeof(t.host) == "Instance" and t.host:IsA("Player"))) then return false end
	if typeof(t.from_vm) ~= "number" then return false end
	if t.to_vm ~= nil and typeof(t.to_vm) ~= "number" then return false end

	return true
end

local NAME = "JABBY_REMOTES"
local folder: Instance
if RunService:IsServer() then
	local existing = ReplicatedStorage:FindFirstChild(NAME)
	if existing then
		folder = existing
	else
		folder = Instance.new("Folder")
		folder.Name = NAME
		folder.Archivable = false
		folder.Parent = ReplicatedStorage
	end
else
	folder = ReplicatedStorage:WaitForChild(NAME)
end

local function get_remote_event(name: string, unreliable: boolean?): RemoteEvent & { actor: BindableEvent, peer: RemoteEvent }
	if RunService:IsServer() then
		return folder:FindFirstChild(name) :: RemoteEvent & { actor: BindableEvent }
			or (function()
				local remote = Instance.new(if unreliable then "UnreliableRemoteEvent" else "RemoteEvent")
				remote.Name = name
				remote.Parent = folder

				local fire_actor = Instance.new("BindableEvent")
				fire_actor.Name = "actor"
				fire_actor.Parent = remote
				
				local peer = Instance.new("RemoteEvent")
				peer.Name = "peer"
				peer.Parent = remote

				return remote :: RemoteEvent & { actor: BindableEvent, peer: RemoteEvent }
			end)()
	else
		return folder:WaitForChild(name) :: RemoteEvent & { actor: BindableEvent }
	end
end

local function create_event<T...>(name: string, unreliable: boolean?, do_not_block_traffic: boolean?)
	local remote = get_remote_event(name, unreliable)
	local on_event_fire, fire = signal()

	local event = {
		type = "event",

		fire = function(_, connector: types.OutgoingConnector, ...)
			--- if the host is within this vm, we can fire it straight to
			if not traffic_check.check(local_host, connector.host, true) then return end
			
			-- same host, same vm.
			if
				connector.host == local_host
				and connector.to_vm == vm_id
			then

				local incoming = {
					host = local_host,
					from_vm = vm_id,
					to_vm = connector.to_vm
				}

				fire(incoming, ...)
			--- if the host is the same, but in a separate actor
			--- we have to fire the actor
			elseif
				connector.host == local_host
				and connector.to_vm ~= vm_id
			then
				local incoming = {
					host = local_host,
					from_vm = vm_id,
					to_vm = connector.to_vm
				}

				remote.actor:Fire(incoming, ...)
			--- we need to fire the server
			elseif connector.host == "server" then
				local incoming = {
					host = "server",
					from_vm = vm_id,
					to_vm = connector.to_vm
				}

				remote:FireServer(incoming, ...)
			--- we need to fire the client
			elseif local_host == "server" then
				local incoming = {
					host = "server",
					from_vm = vm_id,
					to_vm = connector.to_vm
				}

				remote:FireClient(connector.host, incoming, ...)
			--- we need to tell the server to redirect this to the client
			else
				local incoming = {
					host = connector.host,
					from_vm = vm_id,
					to_vm = connector.to_vm
				}

				remote:FireServer(incoming, ...)
			end

		end,

		connect = function(_, callback: (types.IncomingConnector, T...) -> ())
			on_event_fire:connect(callback :: any)
		end
	}

	if RunService:IsServer() then
		remote.OnServerEvent:Connect(function(player, target: types.IncomingConnector, ...)
			--- check if the player is allowed to send this
			if not do_not_block_traffic and not traffic_check.check(player, target.host) then
				return
			end

			--- check if its a proper connector
			if not tincoming_connector(target) then return end
	
			if target.host == "server" and (target.to_vm == vm_id or target.to_vm == nil) then
				target.host = player
				fire(target, ...)
			elseif target.host ~= "server" and vm_id == MANAGER_VM then
				local to = target.host
				target.host = player
				remote:FireClient(
					to,
					target,
					...
				)
			end
		end)
	else
		remote.OnClientEvent:Connect(function(incoming: types.IncomingConnector, ...)
			-- print("receive", remote.Name, "from", incoming.host)
			if tincoming_connector(incoming) == false then return end
			if incoming.to_vm ~= vm_id and incoming.to_vm ~= nil then return end
			traffic_check._whitelist(local_host, incoming.host)

			fire(incoming, ...)
		end)
	end

	remote:WaitForChild("actor").Event:Connect(function(incoming: types.IncomingConnector, ...)
		if incoming.to_vm ~= vm_id and incoming.to_vm ~= nil then return end
		fire(incoming, ...)
	end)

	return (event :: any) :: types.NetEvent<T...>
end

return {
	create_event = create_event,
	local_host = local_host
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="63">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">queue</string>
									<string name="ScriptGuid">{1E847AEB-0D26-4446-9507-D2F0D5C41A63}</string>
									<ProtectedString name="Source"><![CDATA[--- Licensed under MIT from centau_ri
export type Queue<T...> = typeof(setmetatable(
	{} :: {
		add: (self: Queue<T...>, T...) -> (),
		clear: (self: Queue<T...>) -> (),
		iter: (self: Queue<T...>) -> () -> T...,
	},
	{} :: {
		__len: (self: Queue<T...>) -> number,
		__iter: (self: Queue<T...>) -> () -> T...,
	}
))

type Array<T> = { T }

local Queue = {}
do
	Queue.__index = Queue

	type _Queue = Queue<...any> & {
		size: number,
		columns: Array<Array<unknown>>,
	}

	function Queue.new<T...>(): Queue<T...>
		local self: _Queue = setmetatable({
			size = 0,
			columns = {},
		}, Queue) :: any

		setmetatable(self.columns, {
			__index = function(columns: Array<Array<unknown>>, idx: number)
				columns[idx] = {}
				return columns[idx]
			end,
		})

		return self :: Queue<T...>
	end

	function Queue.add(self: _Queue, ...: unknown)
		-- iteration will stop if first value is `nil`
		assert((...) ~= nil, "first argument cannot be nil")

		local columns = self.columns
		local n = self.size + 1
		self.size = n

		for i = 1, select("#", ...) do
			columns[i][n] = select(i, ...)
		end
	end

	function Queue.clear(self: _Queue)
		self.size = 0
		for _, column in next, self.columns do
			table.clear(column)
		end
	end

	local function iter(self: _Queue)
		local columns = self.columns
		local n = self.size
		local i = 0

		if #columns <= 1 then
			local column = columns[1]
			return function()
				i += 1
				local value = column[i]
				if i == n then self:clear() end
				return value
			end
		else
			local tuple = table.create(#columns)
			return function()
				i += 1
				for ci, column in next, columns do
					tuple[ci] = column[i]
				end
				if i == n then self:clear() end
				return unpack(tuple)
			end
		end
	end

	Queue.iter = iter
	Queue.__iter = iter

	function Queue.__len(self: _Queue)
		return self.size
	end
end

type ISignal<T...> = {
	connect: (self: any, listener: (T...) -> ()) -> (),
} | {
	Connect: (self: any, listener: (T...) -> ()) -> (),
}

local queue_create = function<T...>(signal: ISignal<T...>?): Queue<T...>
	local queue = Queue.new()

	if signal then
		local connector = (signal :: any).connect or (signal :: any).Connect
		assert(connector, "signal has no member `connect()`")
		connector(signal, function(...)
			queue:add(...)
		end)
	end

	return queue
end :: (<T...>() -> Queue<T...>) & (<T...>(signal: ISignal<T...>) -> Queue<T...>)

return queue_create]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d2</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">remotes</string>
									<string name="ScriptGuid">{CF3FA7CA-8960-47C6-8571-2A55A6DC2752}</string>
									<ProtectedString name="Source"><![CDATA[local net = require(script.Parent.net)
local types = require(script.Parent.types)

--todo: redo this file
return {

	--[=[
	Broadcasts to clients that a new server has been registered.
	Accepts no params.
	]=]
	new_server_registered = net.create_event("server_registered", false, true)
		:: types.NetEvent<>,

	--[=[
	Pings all servers and make them respond with new_server_registered
	]=]
	ping = net.create_event("ping", false, true)
		:: types.NetEvent<>,

	--[=[
	Broadcasts to servers that a new client has been registered
	Accepts no params.
	]=]
	bind_to_server_core = net.create_event("client_registered")
		:: types.NetEvent<>,

	--[=[
	Sends a update to a client about a new server
	]=]
	update_server_data =
		net.create_event("update_server_data")
		:: types.NetEvent<{
			worlds: {{id: number, name: string}},
			schedulers: {{id: number, name: string}}	
		}>,

	--[=[
	The client will use this to send the mouse pointer to the server
	]=]
	send_mouse_pointer =
		net.create_event("send_mouse_pointer")
		:: types.NetEvent<number, Vector3, Vector3>,

	--[[
	
	
	]]
	send_mouse_entity = 
		net.create_event("send_mouse_entity", true)
		:: types.NetEvent<number, Part?, number?, string?>,

	--[=[
	Requests the server to validate a query
	world: number
	query: string
	]=]
	validate_query =
		net.create_event("validate_query")
		:: types.NetEvent<number, string>,

	--[=[
	Result of the validation
	world: number query: string, ok: boolean, message: string?
	]=]
	validate_result =
		net.create_event("validate_result")
		:: types.NetEvent<number, string, boolean, string?>,

	--[=[
	Requests a server to initiate replication of a query.
	
	world: number
	id: number
	query_id: number
	query: string
	]=]
	request_query =
		net.create_event("replicate_query")
		:: types.NetEvent<number, number, string>,

	--[=[
	Disconnects query

	query_id: number
	]=]
	disconnect_query =
		net.create_event("disconnect_query")
		:: types.NetEvent<number>,
	
	--[=[
	Changes the offsets to query for

	query_id: number
	from: number
	to: number
	]=]
	advance_query_page =
		net.create_event("advance_query_page")
		:: types.NetEvent<number, number, number>,

	--- pause the query
	--- query id
	--- should pause
	pause_query = 
		net.create_event("pause_query")
		:: types.NetEvent<number, boolean>,

	--- refreshes query results
	--- query_id
	refresh_results = 
		net.create_event("refresh_query")
		:: types.NetEvent<number>,

	--[=[
	Updates a single result
	
	query_id: number
	frame: number
	column: number
	row: number
	value: any
	]=]
	update_query_result =
		net.create_event("update_query_result", true)
		:: types.NetEvent<(number, number, number, number, any)>,

	--[=[
	Counts the total number of entities

	query id: number
	count: number
	]=]

	count_total_entities =
		net.create_event("count_total_entities", true)
		:: types.NetEvent<number, number>,

	--[=[
	Requests a server to initiate replication of a scheduler
	]=]
	request_scheduler =
		net.create_event("initiate_replicate_scheduler") ::
		types.NetEvent<number>,

	--[=[
	Requests the server to stop replicating a scheduler
	]=]
	disconnect_scheduler =
		net.create_event("disconnect_replicate_scheduler") ::
		types.NetEvent<number>,

	--[=[
	Updates any static data about systems (like new systems)

	systemid: number
	static_data: {}
	]=]
	scheduler_system_static_update =
		net.create_event("scheduler_system_update_static") ::
		types.NetEvent<number, number, types.SystemData?>,

	--[=[
	Appends a frame to a system
	
	systemid: number
	frame_count: number
	time_took: number
	]=]
	scheduler_system_update =
		net.create_event("append_frame_system", true) ::
		types.NetEvent<number, number, number, number>,

	--[=[
	Pauses a system
	
	scheduler: number
	systemid: number
	paused: boolean
	]=]
	scheduler_system_pause =
		net.create_event("scheduler_pause") ::
		types.NetEvent<number, number, boolean>,

	--[[
	Validates a component

	world: number
	component: string
	]]
	validate_entity_component =
		net.create_event("validate_entity_component") ::
		types.NetEvent<number, string>,

	--[[
	entity component reslt
	
	world: number
	component: string
	ok: boolean
	reason: string
	]]
	validate_entity_component_result =
		net.create_event("validate_entity_component_result") ::
		types.NetEvent<number, string, boolean, string>,

	--[[
	Inspect a entity's components

	world: number
	entity: number,
	inspectid: number
	]]

	inspect_entity =
		net.create_event("inspect_entity") ::
		types.NetEvent<number, number, number>,

	--[[
	Delete entity
	
	inspectid: number
	]]
	delete_entity =
		net.create_event("delete_entity") ::
		types.NetEvent<number>,
	
	--[[
	Stops inspecting a entity

	inspectid: number
	]]
	stop_inspect_entity =
		net.create_event("stop_inspect_entity") ::
		types.NetEvent<number>,

	--[[
	Updates a entity
	
	inspectid: number
	changes: {[component]: string}
	]]
	update_entity =
		net.create_event("update_entity") ::
		types.NetEvent<number, {[string]: string}>,

	--[[
	Update the settings when dealing with inspecting
	
	inspectid: nuimber,
	settings: {}
	]]
	update_inspect_settings =
		net.create_event("inspect_entity_settings_update") ::
		types.NetEvent<number, {paused: boolean}>,

	--[[
	Inspector update
	
	inspectid: number
	key: string
	value: string
	]]
	inspect_entity_update =
		net.create_event("inspect_entity_update") ::
		types.NetEvent<number, string, string?>,
	
	--[[
	Creates a watch on a system
	
	scheduler: number,
	system: number
	watchid: number
	]]
	create_watch =
		net.create_event("create_watch") ::
		types.NetEvent<number, number, number>,
	
	--[[
	Removes a watch on a system

	watchid: number
	]]
	remove_watch =
		net.create_event("remove_watch") ::
		types.NetEvent<number>,
	
	--[[
	Retrieves data about a frame for a watch
	
	watchid: number
	frame: number
	]]
	request_watch_data =
		net.create_event("request_watch_data") ::
		types.NetEvent<number, number>,

	--[[
	Updates watch data for a frame
	
	watchid: number
	frame: number
	changes: types.WatchLoggedChanges
	]]
	update_watch_data =
		net.create_event("update_watch_data") ::
		types.NetEvent<number, number, types.WatchLoggedChanges?>,

	start_record_watch =
		net.create_event("start_record_watch") ::
		types.NetEvent<number>,

	stop_watch =
		net.create_event("stop_watch") ::
		types.NetEvent<number>,

	clear_watch =
		net.create_event("clear_watch") ::
		types.NetEvent<number>,

	connect_watch =
		net.create_event("connect_to_watch") ::
		types.NetEvent<number>,
	
	disconnect_watch = 
		net.create_event("disconnect_watch") ::
		types.NetEvent<number>,

	update_overview =
		net.create_event("update_watch_overview", true) ::
		types.NetEvent<number, number, number>
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d3</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="65">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">reverse_connector</string>
									<string name="ScriptGuid">{64F612C7-730A-4650-BB2C-2F38B3160851}</string>
									<ProtectedString name="Source"><![CDATA[--!nocheck
local types = require(script.Parent.types)

local function reverse(connector: types.IncomingConnector): types.OutgoingConnector
	return {
		host = connector.host,
		to_vm = connector.from_vm,
	}
end

return reverse]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d4</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="66">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">signal</string>
									<string name="ScriptGuid">{637B0C1B-0E9F-4B4B-9257-977D2F147E8E}</string>
									<ProtectedString name="Source"><![CDATA[--[[

	A rudimentary signal class. Yielding may cause bugs.

]]

local signal = {}
signal.__index = signal

type Connection = { disconnect: (any?) -> (), reconnect: (any?) -> () }
export type Signal<T... = ...unknown> = {

	class_name: "Signal",

	connect: (Signal<T...>, callback: (T...) -> ()) -> Connection,
	wait: (Signal<T...>) -> T...,
	once: (Signal<T...>, callback: (T...) -> ()) -> Connection,

	callbacks: { [(T...) -> ()]: true },
}
export type SignalInternal<T... = ...unknown> = Signal<T...> & {
	fire: (SignalInternal<T...>, T...) -> (),
}

function signal.connect<T...>(self: Signal<T...>, callback: (T...) -> ())
	assert(type(callback) == "function")
	self.callbacks[callback] = true

	return {
		disconnect = function() self.callbacks[callback] = nil end,
		reconnect = function() self.callbacks[callback] = true end,
	}
end

function signal.fire<T...>(self: Signal<T...>, ...: T...)
	for callback in self.callbacks do
		callback(...)
	end
end

function signal.once<T...>(self: Signal<T...>, callback: (T...) -> ())
	local connection
	connection = self:connect(function(...)
		connection:disconnect()
		callback(...)
	end)

	return connection
end

function signal.wait<T...>(self: Signal<T...>)
	local thread = coroutine.running()

	local connection = self:connect(function(...) coroutine.resume(thread, ...) end)
	local packed = { coroutine.yield() }
	connection:disconnect()
	return unpack(packed)
end

local function new_signal<T...>(): (Signal<T...>, (T...) -> ())
	local self = setmetatable({
		class_name = "Signal",
		callbacks = {},
	}, signal)

	local function fire(...)
		for callback in self.callbacks :: any do
			callback(...)
		end
	end

	return self :: any, fire
end

return new_signal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d5</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">traffic_check</string>
									<string name="ScriptGuid">{2C4C26C2-4D52-4FCC-ABDE-00DFA524C4CE}</string>
									<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
--[[

a utility library to handle checking traffic and determining if the sender is
permitted to send the given data.

]]

local signal = require(script.Parent.signal)

local traffic_check = {}

local whitelist_player_to = {}

local on_fail, fire = signal()

--- A function that needs to be overwritten by the user.
--- This function is used to find out what permissions a user may have.
traffic_check.can_use_jabby = function(player: Player)
	local is_studio = game:GetService("RunService"):IsStudio()

	return is_studio --is_owner or is_studio
end

--- Runs a callback defined by the developer to determine if a player is allowed
--- to use a given function
local function communication_is_allowed(from: "server" | Player, to: "server" | Player, dont_whitelist: boolean?)
	if from == "server" then return true end
	
	whitelist_player_to[from] = whitelist_player_to[from] or {}
	whitelist_player_to[to] = whitelist_player_to[to] or {}

	if traffic_check.can_use_jabby(from) or whitelist_player_to[from][to] then
		if dont_whitelist then return true end
		whitelist_player_to[to][from] = from
		return true
	else
		return false
	end
end

--- Runs the given check and fires the on_fail signal if the player fails the
--- check.
local function check(from: "server" | Player, to: "server" | Player, dont_whitelist: boolean?)
	if communication_is_allowed(from, to, dont_whitelist) then
		return true
	else
		fire(from)
		return false
	end
end

local function check_no_wl(from: "server" | Player)
	if from == "server" then return true end
	if traffic_check.can_use_jabby(from) then
		return true
	else
		-- print(from, "cant use jabby")
		fire(from)
		return false
	end
end

local function _whitelist(from: "server" | Player, to: "server" | Player)
	whitelist_player_to[from] = whitelist_player_to[from] or {}
	whitelist_player_to[to] = whitelist_player_to[to] or {}
	whitelist_player_to[from][to] = from
end

traffic_check.communication_is_allowed = communication_is_allowed
traffic_check.check_no_wl = check_no_wl
traffic_check.check = check

traffic_check._whitelist = _whitelist

traffic_check.on_fail = on_fail

Players.PlayerRemoving:Connect(function(player)
	whitelist_player_to[player] = nil
end)

return traffic_check]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d6</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="68">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">types</string>
									<string name="ScriptGuid">{075D942B-331B-437F-9CAD-1C6FEEF5A098}</string>
									<ProtectedString name="Source"><![CDATA[local jecs = require(script.Parent.Parent.Parent.jecs)
type host = "client" | "server"

export type IncomingConnector = {
	host: Player | "server",
	from_vm: number,
	to_vm: number
}

export type OutgoingConnector = {
	host: Player | "server",
	to_vm: number?, -- not specifying a vm makes it received by all
	from_vm: nil
}

export type NetEvent<T...> = {

	type: "event",

	fire: (any, connector: OutgoingConnector, T...) -> (),
	connect: (any, callback: (connector: IncomingConnector, T...) -> ()) -> RBXScriptConnection,
}

export type NetCallback<T..., U...> = {

	type: "callback",

	invoke: (any, connector: OutgoingConnector, T...) -> U...,
	set_callback: (any, callback: (connector: IncomingConnector, T...) -> U...) -> (),
}

export type SystemId = number

export type SystemTag = "processing" | "finished" | "paused"
export type SystemSettingData = {
	name: string?,
	phase: string?,
	layout_order: number?,
	paused: boolean?
}
export type SystemData = {
	name: string,
	phase: string?,
	layout_order: number,
	paused: boolean
}

type ChangeTypes = "remove" | "clear" | "delete" | "add" | "set" | "entity" | "component"
export type WatchLoggedChanges = {
	types: {ChangeTypes},
	entities: {jecs.Entity<any>},
	component: {jecs.Entity<any>},
	values: {string},
	worlds: {jecs.World}
}

export type SystemWatch = {
	--- enables Lua Object Notation.
	--- incurs a significant performance penalty.
	enable_lon: boolean,
	--- the current frame to process
	frame: number,

	frames: {[number]: WatchLoggedChanges}
}

export type SystemLabel = {}

export type SystemFrame = {
	i: number,
	s: number
}

type WatchData = {active: boolean, watch: SystemWatch, untrack: () -> ()}

export type Scheduler = {
	class_name: "Scheduler",
	name: string,

	valid_system_ids: {[SystemId]: true},
	system_data: {[SystemId]: SystemData},
	system_data_updated: {[SystemId]: true},
	system_frames: {[SystemId]: SystemFrame},
	system_frames_updated: {[SystemId]: {[SystemFrame]: true}},
	system_watches: {[SystemId]: {WatchData}},

	register_system: (Scheduler, settings: SystemSettingData?) -> SystemId,
	set_system_data: (Scheduler, system: SystemId, settings: SystemSettingData) -> (),
	get_system_data: (Scheduler, system: SystemId) -> SystemSettingData,
	create_watch_for_system: (Scheduler, system: SystemId) -> WatchData,
	remove_system: (Scheduler, system: SystemId) -> (),

	-- mark_system_frame_start: (Scheduler, system: SystemId) -> (),
	-- mark_system_frame_end: (Scheduler, system: SystemId, s: number?) -> (),
	-- append_extra_frame_data: (Scheduler, system: SystemId, label: SystemLabel) -> (),
	--- this should call mark_system_frame_start and mark_system_frame_end for you
	run: <T...>(Scheduler, system: SystemId, system: () -> (), T...) -> (),

}

export type World = {
	class_name: "World",
	name: string,
	world: jecs.World,

	entities: {[Instance]: jecs.Entity<any>}?,
	get_entity_from_part: ((part: BasePart) -> (jecs.Entity<any>?, Part?))?
}

export type Application<T> = {
	class_name: "app",
	name: string,

	mount: (props: T, destroy: () -> ()) -> Instance
}

return nil]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d7</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="69">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">videx</string>
									<string name="ScriptGuid">{C5D630A1-BA7F-44A8-9551-875F36DF4D4F}</string>
									<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
-- videx/store.luau
--------------------------------------------------------------------------------
local vide = require(script.Parent.Parent.Parent.vide)
local source = vide.source

local NULL = newproxy()

local Store = {}

--[=[
Creates a new store object that receives some initial state and then returns
a table with the same structure, but all keys of the given table will be reactive.

When accessed inside a reactive scope, the reactive scope will update whenever
the key that is accessed is changed.

@param initial_state `T : {[string]: any}` The initial state the store will start in.
@param mutations `() -> {[string]: (T, ...any) -> ...any}?` A list of functions that mutate the data.
@return `T & U` A resulting table that 
]=]
function Store.new<T, U>(
    initial_state: T & {},
    mutations: (T & U) -> U
): T & U
    local sources = {}

    for i, v in initial_state :: any do
        local src = source(v ~= NULL and v or nil)
        sources[i] = src
    end

    local internal_proxy = {}

    setmetatable(internal_proxy, {
        __index = function(_, index)
            return sources[index]()
        end,
        __newindex = function(_, index, value)
            sources[index](value)
        end
    })

    local external_proxy = {}

    setmetatable(external_proxy :: any, {
        __index = function(_, index)
            local src = sources[index]
            if src == nil then error(`invalid index {index}`, 2) end
            return src()
        end,

        __newindex = function(_, index, value)
            sources[index](value)
        end
    })

    for i, v in next, mutations(internal_proxy :: any) :: any do
        if rawget(external_proxy, i) then
            error(`duplicate field "{i}"`, 2)
        end
        rawset(external_proxy, i, v)
    end

    return external_proxy :: T & U & {}
end

--- A special symbol used to indicate that a value should be nil within a Store.
Store.null = NULL :: nil

return Store]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d8</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="70">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">vm_id</string>
									<string name="ScriptGuid">{9A85FE75-A9A4-4DD4-80F0-39B630C1AB1E}</string>
									<ProtectedString name="Source"><![CDATA[--[[

Provides a unique identifier for a VM.

This currently cannot be tested unless there is some parallel system for jest.

]]

local SharedTableRegistry = game:GetService("SharedTableRegistry")

local shared_table = SharedTableRegistry:GetSharedTable("_gorp_common_vm_count")
shared_table.id = shared_table.id or 0

return SharedTable.increment(shared_table, "id", 1)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003d9</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="71">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">server</string>
								<string name="ScriptGuid">{D577037B-DE30-4C2B-ABC3-5C9BDEE01794}</string>
								<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local loop = require(script.Parent.modules.loop)
local remotes = require(script.Parent.modules.remotes)
local traffic_check = require(script.Parent.modules.traffic_check)
local vm_id = require(script.Parent.modules.vm_id)
local function broadcast()
	for _, player in Players:GetPlayers() do
		if not traffic_check.can_use_jabby(player) then continue end
		remotes.new_server_registered:fire({
			host = player,
		})
	end
end

task.delay(0, broadcast)

local systems = script.systems
local loop = loop (
	`jabby-host:{
		if RunService:IsServer() then "server" else "client"
	}-vm:{vm_id}`,
	nil,
	{i = 1},

	systems.ping,
	systems.replicate_core,
	systems.replicate_scheduler,
	systems.replicate_registry,
	systems.replicate_system_watch,
	systems.mouse_pointer,
	systems.entity
)

RunService.PostSimulation:Connect(loop)

return {

	broadcast = broadcast

}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003da</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="72">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">public</string>
									<string name="ScriptGuid">{2467E1DF-E95F-46B7-AE44-1154A73842E2}</string>
									<ProtectedString name="Source"><![CDATA[--[[

anything in here is considered "public" and will be visible to jabby clients

]]

local self = {

	updated = false,

} :: {
	updated: boolean,
	[number]: any
}

return self]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003db</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="73">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">query_parser</string>
									<string name="ScriptGuid">{012642E6-480E-4D70-97F6-72D649B7A8D0}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

local escape_chars = {
	a = "\a",
	b = "\b",
	f = "\f",
	n = "\n",
	r = "\r",
	t = "\t",
	v = "\v",
	["\\"] = "\\",
	["\""] = "\"",
	["\'"] = "\'"
}

export type Position = {
	line: number,
	pos: number,
	col: number
}

export type String = {type: "string", s: string}
export type Number = {type: "number", s: number}
export type Identifier = {type: "identifier", s: string}
export type Operator = {type: "operator", s: "#" | "!" | "*" | "$"}
export type Symbol = {type: "symbol", s: "(" | ")" | ";" | ","}
export type EOF = {type: "eof", s: "eof"}

export type Token =
	String
	| Number
	| Identifier
	| Symbol
	| Operator
	| EOF


export type Stream = {
	next: () -> Token,
	peek: (n: number?) -> Token,
	eof: () -> boolean,
	croak: (msg: string) -> (),
	pos: () -> Position
}

local function stream(input: string)

	local pos = 0
	local line = 1
	local col = 1

	local function peek(): string
		return string.sub(input, pos+1, pos+1)
	end

	local function next(): string
		local char = peek()
		pos += 1

		if char == "\n" then line += 1; col = 1
		else col += 1 end

		return char
	end

	local function eof(): boolean
		return peek() == ""
	end

	local function position()
		return {
			pos = pos,
			line = line,
			col = col
		}
	end

	local function croak(msg)
		error(`{msg} ({line}:{col})`, 0)
	end

	return {
		peek = peek,
		next = next,
		eof = eof,
		croak = croak,
		pos = position
	}

end

local function lex(source: string): Stream
	
	local input = stream(source)

	local function is_whitespace(char: string)
		return not not string.match(char, "[\t ]")
	end

	local function is_digit(char: string)
		return not not (char == "." or string.match(char, "%d"))
	end
	
	local function is_start_identifier(char: string)
		return not not string.match(char, "[%a_]")
	end

	local function is_identifier(char: string)
		return not not string.match(char, "[%a_:]")
	end
	
	local function is_op_char(char: string)
		return char == "#" or char == "!" or char == "*" or char == "$"
	end

	local function is_punc(char: string)
		return not not string.match(char, "[%(%);,]")
	end

	local function read_while(predicate: (char: string) -> boolean)
		local str = ""
		while input.eof() == false and predicate(input.peek()) do
			str ..= input.next()
		end
		return str
	end

	local function skip_whitespace()
		read_while(is_whitespace)
	end

	local function read_string(): String
		local escaped = false
		local token = ""
		local eliminator = input.next()
		local from = input.pos()

		while input.eof() == false and (input.peek() ~= eliminator or escaped) do
			local char = input.next()
		
			if char == "\\" then
				escaped = true
			end

			if escaped then
				token ..= escape_chars[char] or input.croak(`cannot escape {char}`)
				escaped = false
			else
				token ..= char
			end
		end

		local to = input.pos()

		-- print("t", token, eliminator, input.peek())

		if input.peek() ~= eliminator then input.croak("unterminated string") end
		input.next()
		return {type = "string", s = token, from = from, to = to}
	end

	local function read_number(): Number
		local decimal_pointer = false
		local from = input.pos()
		local token = read_while(function(char)
			if decimal_pointer and char == "." then return false end
			if char == "." then decimal_pointer = true end
			return is_digit(char)
		end)
		local to = input.pos()

		local n = tonumber(token)

		if not n then
			input.croak(`could not read {token} as number`)
		end

		return {type = "number", s = assert(n), from = from, to = to}
	end

	local function read_identifier(): Identifier
		local from = input.pos()
		local token = read_while(is_identifier)
		local to = input.pos()

		-- if table.find(keywords, token) then
		-- 	return {type = "keyword", s = token :: any, from = from, to = to}
		-- else
		return {type = "identifier", s = token, from = from, to = to}
		-- end
	end
	
	local function read_next(): Token
		skip_whitespace()
		if input.eof() then return {type = "eof", s = "eof"} end

		local char = input.peek()

		if char == "\"" or char == "'" then return read_string() end
		if is_digit(char) then return read_number() end
		if is_start_identifier(char) then return read_identifier() end
		if is_op_char(char) then return {type = "operator", s = input.next() :: any} end
		if is_punc(char) then return {type = "symbol", s = input.next() :: any} end

		input.croak(`cannot lex {char}`)
		error("fail")
	end

	local current: {Token} = {}

	local function next()
		local token = table.remove(current, 1)
		return if token == nil then read_next() else token
	end

	local function peek(n: number?)
		local n = n or 1
		while #current < n do
			table.insert(current, read_next())
		end
		return current[n]
	end

	local function eof()
		return peek().type == "eof"
	end

	return {

		peek = peek,
		next = next,
		eof = eof,
		croak = input.croak,
		pos = input.pos

	}
end

type Wildcard = {
	type: "Wildcard",
	name: "*"
}

export type Value = {
	type: "Name",
	name: string
} | {
	type: "Entity",
	entity: number
}

export type PureComponent = {
	type: "Component",
	query: boolean,
	exclude: boolean,
	value: Value,
}

export type Relationship = {
	type: "Relationship",
	query: boolean,
	exclude: boolean,
	left: PureComponent | Wildcard,
	right: PureComponent | Wildcard
}

type Component = Relationship | PureComponent | Wildcard

local function parse(input: string): {PureComponent | Relationship}
	local lexer = lex(input)

	local result: {PureComponent | Relationship} = {}

	local should_query = true
	local should_exclude = false
	local should_relationship = false
	local interpret_pointer = false
	local components: {Component} = {}

	while true do
		local symbol = lexer.peek()
		-- print2(symbol)
		if symbol.type == "eof" then
			break
		elseif interpret_pointer or symbol.type == "number" then
			if not interpret_pointer then
				lexer.croak("expected $")
			elseif symbol.type ~= "number" then
				lexer.croak("expected number")
				error("")
			end

			table.insert(components, {
				type = "Component",
				query = should_query,
				exclude = should_exclude,
				value = {type = "Entity", entity = tonumber(lexer.next().s) :: number}
			})

			should_query = if should_relationship then should_query else true
			should_exclude = if should_relationship then should_exclude else false
			interpret_pointer = false
			if lexer.peek().type ~= "symbol" and lexer.peek().type ~= "eof" then lexer.croak("expected symbol or eof after identifier") end
		elseif symbol.type == "operator" then
			if symbol.s == "#" then
				if should_relationship then lexer.croak("cannot tag inside relationship") end
				should_query = false
				lexer.next()
			elseif symbol.s == "!" then
				if should_relationship then lexer.croak("cannot exclude in relationship") end
				should_exclude = true
				should_query = false
				lexer.next()
			elseif symbol.s == "$" then
				interpret_pointer = true
				lexer.next()
			elseif symbol.s == "*" then
				if not should_relationship then lexer.croak("cannot use wildcards outside relationship") end
				table.insert(components, {
					type = "Wildcard",
					name = "*"
				})
				lexer.next()
			end
		elseif symbol.type == "symbol" then
			if symbol.s == "(" then
				if should_relationship == true then lexer.croak("relationship within relationship") end
				should_relationship = true
				lexer.next()
			elseif symbol.s == ")" then
				if should_relationship == false then lexer.croak("missing (") end
				if #components == 2 then
					local right = table.remove(components) :: Component
					local left = table.remove(components) :: Component

					if left.type == "Wildcard" and right.type == "Wildcard" then
						lexer.croak("both components are wildcards")
					end

					components = {{
						type = "Relationship",
						query = should_query,
						exclude = should_exclude,
						left = left :: any,
						right = right :: any
					}}

					should_query = true
					should_exclude = false
					should_relationship = false
					lexer.next()
				else
					lexer.croak(`expected 2 components, got {#components}`)
				end
			elseif symbol.s == "," or symbol.s == ";" then
				if should_relationship then
					lexer.next()
					continue
				end

				local ctype = table.remove(components)
				if ctype == nil then
					lexer.croak("no component provided")
					error("")
				end

				table.insert(result, ctype :: any)

				should_query = true
				should_exclude = false
				lexer.next()
			end
		elseif symbol.type == "identifier" then
			table.insert(components, {
				type = "Component",
				query = should_query,
				exclude = should_exclude,
				value = {type = "Name", name = lexer.next().s :: string}
			})

			should_query = if should_relationship then should_query else true
			should_exclude = if should_relationship then should_exclude else false
			if lexer.peek().type ~= "symbol" and lexer.peek().type ~= "eof" then lexer.croak("expected symbol or eof after identifier") end
		elseif symbol.type == "string" then
			table.insert(components, {
				type = "Component",
				query = should_query,
				exclude = should_exclude,
				value = {type = "Name", name = lexer.next().s :: string}
			})
			should_query = if should_relationship then should_query else true
			should_exclude = if should_relationship then should_exclude else false
			if lexer.peek().type ~= "symbol" and lexer.peek().type ~= "eof" then lexer.croak("expected symbol or eof after string") end
		end
	end

	table.insert(result, table.remove(components) :: any)

	return result
end

return parse]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003dc</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="74">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">scheduler</string>
									<string name="ScriptGuid">{B7884008-3E50-4715-BC04-7D58CE497D88}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.modules.types)
local watch = require(script.Parent.watch)

type SystemId = types.SystemId
type SystemSettingData = types.SystemSettingData
type SystemTag = types.SystemTag

type SystemData = types.SystemData
type ProcessingFrame = {
	started_at: number
}
type SystemFrame = types.SystemFrame

local MAX_BUFFER_SIZE = 50

local n = 0
local schedulers = {}

local function unit() end

local function create_scheduler()

	local count = 1
	local frames = 0

	local scheduler = {
		class_name = "Scheduler",
		name = "Scheduler",

		--- contains a map of valid system ids
		valid_system_ids = {} :: {[SystemId]: true},
		--- contains a list of static system data that is updated infrequently
		system_data = {} :: {[SystemId]: SystemData},
		--- list of system data that has updated
		system_data_updated = {} :: {[SystemId]: true},
		--- contains a buffer of the last couple frames of system data that is
		--- refreshed constantly
		system_frames = {} :: {[SystemId]: {SystemFrame}},
		--- stores the frames that have been updated
		system_frames_updated = {} :: {[SystemId]: {[SystemFrame]: true}},
		--- contains the current frame that a system is processing
		processing_frame = {} :: {[SystemId]: ProcessingFrame},
		--- contains a list of watches for each system
		system_watches = {} :: {[SystemId]: {{active: boolean, watch: types.SystemWatch}}}

	}

	local function ENABLE_WATCHES(id: SystemId)
		local watches = scheduler.system_watches[id]
		local cleanup = {}

		for i, system_watch in watches do
			if system_watch.active == false then continue end
			watch.step_watch(system_watch.watch)
			cleanup[i] = watch.track_watch(system_watch.watch)
		end

		return function()
			for _, stop in cleanup do
				stop()
			end
		end
	end

	local function ASSERT_SYSTEM_VALID(id: SystemId)
		assert(scheduler.valid_system_ids[id], `attempt to use unknown system with id #{id}`)
	end

	function scheduler:register_system(settings: types.SystemSettingData?)
		local id = count; count += 1
		scheduler.valid_system_ids[id] = true
		scheduler.system_data[id] = {
			name = "UNNAMED",
			phase = nil,
			layout_order = 0,
			paused = false
		}
		scheduler.system_frames[id] = {}
		scheduler.system_frames_updated[id] = {}
		
		if settings then
			scheduler:set_system_data(id, settings)
		end

		return id
	end

	function scheduler:set_system_data(id: SystemId, settings: types.SystemSettingData)
		ASSERT_SYSTEM_VALID(id)

		for key, value in settings do
			scheduler.system_data[id][key] = value
		end
		scheduler.system_data_updated[id] = true
	end

	function scheduler:get_system_data(id: SystemId)
		ASSERT_SYSTEM_VALID(id)
		return scheduler.system_data[id]
	end

	function scheduler:remove_system(id: SystemId)
		scheduler.valid_system_ids[id] = nil
		scheduler.system_data[id] = nil
		scheduler.system_frames[id] = nil
		scheduler.system_frames_updated[id] = nil
		scheduler.system_data_updated[id] = true
		scheduler.system_watches[id] = nil
	end

	function scheduler:_mark_system_frame_start(id: SystemId)
		ASSERT_SYSTEM_VALID(id)

		scheduler.processing_frame[id] = {
			started_at = os.clock()
		}
	end

	function scheduler:_mark_system_frame_end(id: SystemId, s: number?)
		ASSERT_SYSTEM_VALID(id)
		local now = os.clock()
		local pending_frame_data = scheduler.processing_frame[id]
		assert(pending_frame_data ~= nil, "no processing frame")
		local frame = {
			i = frames,
			s = now - pending_frame_data.started_at
		}

		frames += 1

		scheduler.processing_frame[id] = nil
		scheduler.system_frames_updated[id][frame] = true
		local last_frame = scheduler.system_frames[id][MAX_BUFFER_SIZE]
		if last_frame then
			scheduler.system_frames_updated[id][last_frame] = nil
		end

		table.insert(scheduler.system_frames[id], 1, frame)
		table.remove(scheduler.system_frames[id], MAX_BUFFER_SIZE + 1)
	end

	function scheduler:append_extra_frame_data(id: SystemId, label: {})
		--todo
		error("todo")
	end

	function scheduler:run<T...>(id: SystemId, system: (T...) -> (), ...: T...)
		ASSERT_SYSTEM_VALID(id)
		local system_data = scheduler.system_data[id]

		if system_data.paused then return end
		
		local watches = scheduler.system_watches[id]
		local cleanup_watches = unit

		if watches then
			cleanup_watches = ENABLE_WATCHES(id)
		end

		scheduler:_mark_system_frame_start(id)
		system(...)
		scheduler:_mark_system_frame_end(id)

		cleanup_watches()
	end

	function scheduler:create_watch_for_system(id: SystemId)
		ASSERT_SYSTEM_VALID(id)

		local new_watch = watch.create_watch()
		local watch_data
		scheduler.system_watches[id] = scheduler.system_watches[id] or {} :: never

		local function untrack()
			local idx = table.find(scheduler.system_watches[id], watch_data)
			table.remove(scheduler.system_watches[id], idx)
		end

		watch_data = {active = false, watch = new_watch, untrack = untrack}
		table.insert(scheduler.system_watches[id], watch_data)

		return watch_data
	end

	schedulers[n + 1] = scheduler
	n = n + 1

	return scheduler

end

return {

	create = create_scheduler,
	schedulers = schedulers

}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003dd</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="75">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">systems</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003de</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="76">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">entity</string>
										<string name="ScriptGuid">{47D341E5-A627-4AA5-9CC3-BBD8C2BD316E}</string>
										<ProtectedString name="Source"><![CDATA[local jecs = require(script.Parent.Parent.Parent.Parent.jecs)
local lon = require(script.Parent.Parent.Parent.modules.lon)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)
local types = require(script.Parent.Parent.Parent.modules.types)
local public = require(script.Parent.Parent.public)
local query_parser = require(script.Parent.Parent.query_parser)

local entity_index_try_get = jecs.entity_index_try_get
local IS_PAIR = jecs.IS_PAIR
local pair = jecs.pair
local pair_first = jecs.pair_first
local pair_second = jecs.pair_second
local empty_table = {}

local function get_all_components(world, entity): {}
	local record = entity_index_try_get(world.entity_index, entity)

	if not record then return empty_table end
	local archetype = record.archetype
	if not archetype then return empty_table end

	local components = {}
	for _, ty in archetype.types do 
		table.insert(components, ty)
	end
	return components
end

local function convert_component(world, debug, entity): string
 	if IS_PAIR(entity) then
		local left = convert_component(world, debug, pair_first(world, entity))
		local right = convert_component(world, debug, pair_second(world, entity))
		return `({left}, {right})`
	else
		return world:get(entity, debug) or `${tostring(entity)}`
	end
end

--- Indicates a value is a tag
local TAG = newproxy()
--- Indicates a value is set to nil; this is not allowed in 0.3.0
local BAD_VALUE = newproxy()

local function get_component(ctype_name: string, map_components: {[string]: number})

	local function get_entity(ctype: query_parser.PureComponent)
		local value = ctype.value

		if value.type == "Entity" then
			return value.entity
		elseif value.type == "Name" then
			return map_components[value.name]
		end
		error("bad")
	end

	local entity_to_set
	local parse = query_parser(ctype_name)[1]
	if parse.type == "Component" then
		entity_to_set = get_entity(parse)
	elseif parse.type == "Relationship" then
		local left, right = jecs.Wildcard, jecs.Wildcard

		if parse.left.type == "Component" then
			left = get_entity(parse.left)
		end

		if parse.right.type == "Component" then
			right = get_entity(parse.right)
		end

		entity_to_set = pair(left, right)
	end

	return entity_to_set
end

return function()

	local inspect_entity = queue(remotes.inspect_entity)
	local update_inspect_settings = queue(remotes.update_inspect_settings)
	local stop_inspect_entity = queue(remotes.stop_inspect_entity)
	local update_entity = queue(remotes.update_entity)
	local delete_entity = queue(remotes.delete_entity)

	local validate_entity = queue(remotes.validate_entity_component)

	local inspectors = {}
	
	return function()

		for incoming, world_id, ctype_name in validate_entity:iter() do
			local world: types.World = public[world_id]
			local outgoing = reverse_connector(incoming)

			if not traffic_check.check_no_wl(incoming.host) then continue end
			if not world or world.class_name ~= "World" then continue end

			local map_components = {}
			for id, name in world.world:query(jecs.Name):iter() do
				map_components[name] = id
			end

			local ok, reason = pcall(get_component, ctype_name, map_components)

			remotes.validate_entity_component_result:fire(
				outgoing, world_id, ctype_name, ok, not ok and reason or nil
			)
		end

		for incoming, world_id, entity, inspect_id in inspect_entity:iter() do
			local world: types.World = public[world_id]
			local outgoing = reverse_connector(incoming)

			if not traffic_check.check_no_wl(incoming.host) then continue end
			if not world or world.class_name ~= "World" then continue end

			inspectors[inspect_id] = {
				outgoing = outgoing,
				world = world,
				entity = entity,
				paused = false,

				new_values = {},
				old_values = {}
			}
		end

		for incoming, inspect_id in stop_inspect_entity:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			inspectors[inspect_id] = nil
		end

		for incoming, inspect_id in delete_entity:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local inspect_data = inspectors[inspect_id]
			local world_data = inspect_data.world
			local world = world_data.world
			local entity = inspect_data.entity

			world:delete(entity)
		end

		for incoming, inspect_id, settings in update_inspect_settings:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local inspect_data = inspectors[inspect_id]
			if not inspect_data then continue end
			inspect_data.paused = settings.paused
		end

		for incoming, inspect_id, changes in update_entity:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local inspect_data = inspectors[inspect_id]
			local world_data = inspect_data.world
			local world = world_data.world
			local entity = inspect_data.entity

			local map_components = {}
			for id, name in world:query(jecs.Name):iter() do
				map_components[name] = id
			end

			for ctype_name, value in changes do

				-- get the component we need to set
				local ok, entity_to_set = pcall(get_component, ctype_name, map_components)

				if not ok then
					warn("attempted to set", ctype_name, "to", value)
					warn(entity_to_set)
					continue
				end

				local ok, result = pcall(lon.parse, value)

				if not ok then
					warn("attempted to set", ctype_name, "to", value)
					warn(result)
					continue
				end

				local ok, data = pcall(
					lon.compile,
					result,
					{tag = TAG}
				)

				if not ok then
					warn("attempted to set", ctype_name, "to", value)
					warn(data)
					continue
				end

				if data == nil then
					world:remove(entity, entity_to_set)
				elseif data == TAG then
					-- tag is handled separately, as its still just "nil"
					-- the difference is that entities used as tags arent allowed to store data
					world:set(entity, entity_to_set)
				else
					world:set(entity, entity_to_set, data)
				end
			end
		end

		for inspect_id, inspector_data in inspectors do
			local world = inspector_data.world.world
			local entity = inspector_data.entity

			if inspector_data.paused then continue end
			if world:contains(entity) == false then continue end

			local new_values = inspector_data.new_values
			local old_values = inspector_data.old_values

			local components = get_all_components(world, entity)

			local function is_tag(id: jecs.Entity<any>)
				return if IS_PAIR(id) then not world:has(jecs.pair_first(world, id), jecs.Component)
					else not world:has(id, jecs.Component)

			end

			for _, component in components do
				local name = convert_component(world, jecs.Name, component)
				local is_tag = is_tag(component)

				if is_tag then
					new_values[name] = TAG
				else
					local value = world:get(entity, component)
					new_values[name] = if value == nil then BAD_VALUE else value
				end
			end

			for name, new_value in new_values do
				local old_value = old_values[name]

				if old_value == new_value and typeof(new_value) ~= "table" then continue end
				remotes.inspect_entity_update:fire(
					inspector_data.outgoing,
					inspect_id,
					name,
					if new_value == TAG then "tag"
					--todo: figure out a better way to say that you are not allowed to store nil in a component
					elseif new_value == BAD_VALUE then "nil (not allowed)"
					else lon.output(new_value, true)
				)
			end

			for name, value in old_values do
				local new_value = new_values[name]

				if new_value ~= nil then continue end
				remotes.inspect_entity_update:fire(
					inspector_data.outgoing,
					inspect_id,
					name,
					nil
				)
			end
			
			table.clear(old_values)

			inspector_data.new_values = old_values
			inspector_data.old_values = new_values
		end
	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003df</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="77">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">mouse_pointer</string>
										<string name="ScriptGuid">{9D691E79-7711-44A3-9D88-D34342574B5B}</string>
										<ProtectedString name="Source"><![CDATA[local jecs = require(script.Parent.Parent.Parent.Parent.jecs)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)
local types = require(script.Parent.Parent.Parent.modules.types)
local public = require(script.Parent.Parent.public)

local entity_index_try_get = jecs.entity_index_try_get
local IS_PAIR = jecs.IS_PAIR
local pair_first = jecs.pair_first
local pair_second = jecs.pair_second
local empty_table = {}


local function convert_component(world, debug, entity): string
	if IS_PAIR(entity) then
	   local left = convert_component(world, debug, pair_first(world, entity))
	   local right = convert_component(world, debug, pair_second(world, entity))
	   return `({left}, {right})`
   else
	   return world:get(entity, debug) or `${tostring(entity)}`
   end
end

local function get_type(t: { [any]: any }): string
	local key, value = next(t)
	if key == nil then return "" end
	return `[{typeof(key)}]: {typeof(value)}`
end

local function get_string_keys(t: { [any]: any }): ({ string }, boolean)
	local keys = {}
	local i = 0
	for key in t do
		if i > 3 then return keys, true end
		if typeof(key) ~= "string" then continue end
		table.insert(keys, key)
		i += 1
	end
	return keys, false
end

local function is_tag(world: jecs.World, id: jecs.Entity<any>)
	return not
		if IS_PAIR(id) then
			world:has(pair_first(world, id), jecs.Component) or
			world:has(pair_second(world, id), jecs.Component)
		else
			world:has(id, jecs.Component)
end

local function get_all_components(world, entity): {}
	local record = entity_index_try_get(world.entity_index, entity)

	if not record then return empty_table end
	local archetype = record.archetype
	if not archetype then return empty_table end

	local components = {}
	for _, ty in archetype.types do 
		table.insert(components, ty)
	end

	table.sort(components, function(a, b)
		return if is_tag(world, a) and is_tag(world, b) then a < b
			elseif is_tag(world, a) then true
			elseif is_tag(world, b) then false
			else a < b
	end)

	return components
end

local function obtain_string(entity: jecs.Entity<any>, world: jecs.World)
	local MAX_SIZE = 840
	local has_more = false
	local entity_name = world:get(entity, jecs.Name)
	local strings = {`<b>{if entity_name then `{entity_name} #` else "#"}{entity}</b>\n`}
	local n = #strings[1]

	for _, id in get_all_components(world, entity) do
		if id == jecs.Name then continue end
		local name = convert_component(world, jecs.Name, id)
		local value = if is_tag(world, id) then nil else world:get(entity, id)
		local to_append

		if typeof(value) == "table" then
			local string_keys = get_string_keys(value)

			if #string_keys > 0 then
				local temp_b = {`<b>{name}</b>:`}
				local temp_n = #temp_b[1]

				for key, value in pairs(value) do
					if #temp_b > 0 then
						table.insert(temp_b, "\n")
					end

					local str_of_v = if type(value) == "string" then `{value}`
						elseif typeof(value) == "table" then get_type(value)
						else tostring(value)
					if #str_of_v > 32 then
						str_of_v = `{string.sub(str_of_v, 1, 30)}..`
					end

					local str = `{key}: {str_of_v}`

					if temp_n + #str + 2 > 32 then
						table.insert(temp_b, "...")
						break
					else
						table.insert(temp_b, str)
					end
				end

				to_append = `{table.concat(temp_b)}`
			else
				to_append = `<b>{name}</b>: {get_type(value)}`
			end
		elseif is_tag(world, id) then
			to_append = `<b>{name}</b>`
		else
			local value = tostring(value)
			if #value > 32 then
				to_append = `<b>{name}</b>: {string.sub(value, 1, 30)}..`
			else
				to_append = `<b>{name}</b>: {value}`
			end
		end
		
		if MAX_SIZE > n + #to_append then
			n += #to_append
			table.insert(strings, to_append)
		else
			has_more = true
		end
	end

	local str = table.concat(strings, "\n")
	if has_more then str = str .. "..." end

	return str
end

return function()

	local send_mouse_pointer = queue(remotes.send_mouse_pointer)

	return function()

		for incoming, world_id, pos, dir in send_mouse_pointer:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local world_data: types.World = public[world_id]
			local world = world_data.world
			local outgoing = reverse_connector(incoming)

			if world_data.entities == nil and world_data.get_entity_from_part == nil then continue end
			if not world_data or world_data.class_name ~= "World" then continue end

			local result = workspace:Raycast(pos, dir * 1000)
			
			if not result then
				remotes.send_mouse_entity:fire(
					outgoing,
					world_id
				)
				continue
			end

			local part = result.Instance
			local entity

			-- no way to obtain the entity
			if world_data.get_entity_from_part == nil and world_data.entities == nil then
				remotes.send_mouse_entity:fire(
					outgoing,
					world_id
				)
				continue
			end

			if world_data.get_entity_from_part == nil then
				entity = world_data.entities[part]

				while entity == nil and part.Parent ~= game do
					part, entity = part.Parent, world_data.entities[part]
				end
			else
				entity, part = world_data.get_entity_from_part(part)
			end

			if not entity then 
				remotes.send_mouse_entity:fire(
					outgoing,
					world_id
				)
				continue
			end

			local str = obtain_string(entity, world, jecs.Name)

			remotes.send_mouse_entity:fire(
				outgoing,
				world_id,
				part,
				entity,
				str
			)

		end

	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="78">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ping</string>
										<string name="ScriptGuid">{41D18284-8945-43CB-986B-2A2C1F543B65}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local net = require(script.Parent.Parent.Parent.modules.net)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)


return function()

	local ping = queue(remotes.ping)

	for _, player in Players:GetPlayers() do
		if traffic_check.communication_is_allowed(net.local_host, player, true) then
			remotes.new_server_registered:fire({
				host = player,
			})
		end
	end

	return function()
		for connector in ping:iter() do
			local outgoing = reverse_connector(connector)
			remotes.new_server_registered:fire(outgoing)
		end
	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="79">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replicate_core</string>
										<string name="ScriptGuid">{0B565A13-2628-482B-9AF7-986D408548F5}</string>
										<ProtectedString name="Source"><![CDATA[local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)
local public = require(script.Parent.Parent.public)

return function()

	local connected = {}

	local bind_to_core = queue(remotes.bind_to_server_core)

	return function()

		for connector in bind_to_core:iter() do
			local outgoing = reverse_connector(connector)
			
			if not traffic_check.check_no_wl(connector.host) then continue end
			-- print("help")

			table.insert(connected, outgoing)
			local schedulers = {}
			local worlds = {}

			for idx, data in ipairs(public) do

				if data.class_name == "Scheduler" then
					table.insert(schedulers, {
						name = data.name :: string,
						id = idx
					})
				elseif data.class_name == "World" then
					table.insert(worlds, {
						name = data.name :: string,
						id = idx
					})
				end

			end

			remotes.update_server_data:fire(outgoing, {
				schedulers = schedulers,
				worlds = worlds
			})
		end

		if public.updated == false then return end
		public.updated = false
		
		local schedulers = {}
		local worlds = {}

		for idx, data in ipairs(public) do

			if data.class_name == "Scheduler" then
				table.insert(schedulers, {
					name = data.name :: string,
					id = idx
				})
			elseif data.class_name == "World" then
				table.insert(worlds, {
					name = data.name :: string,
					id = idx
				})
			end

		end

		local fired_to = {}
		for _, connector in connected do
			if fired_to[connector] then return end
			fired_to[connector] = true
			remotes.update_server_data:fire(connector, {
				schedulers = schedulers,
				worlds = worlds
			})
		end

	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="80">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replicate_registry</string>
										<string name="ScriptGuid">{A1A8D49D-D746-4A6A-8A6F-60BE2E137292}</string>
										<ProtectedString name="Source"><![CDATA[local jecs = require(script.Parent.Parent.Parent.Parent.jecs)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)
local types = require(script.Parent.Parent.Parent.modules.types)
local public = require(script.Parent.Parent.public)
local query_parser = require(script.Parent.Parent.query_parser)

type Connection = {

	outgoing: types.OutgoingConnector,
	query_id: number,
	frame: number,

	paused: boolean,
	refresh: boolean,

	world: types.World,

	include: {jecs.Entity<any>},
	exclude: {jecs.Entity<any>},
	with: {jecs.Entity<any>},

	new_columns: {{any}},
	old_columns: {{any}},	
	
	from: number,
	upto: number

}

local NIL = newproxy() -- NULL is displayed if the value exists, buth as no value

local function clear_columns(columns: {{any}})
	for _, column in columns do
		local name = column[1]
		table.clear(column)
		column[1] = name
		assert(column[1] == name)
	end
	return columns
end

local function reverse_columns(columns: {{any}}, size: number)
	for _, column in columns do
		for i = 0, size // 2 - 1 do
			column[i + 2], column[(size + 1) - i] = column[(size + 1) - i], column[i + 2]
		end
	end
	return columns
end

return function()

	local processing_queries: {[number]: Connection} = {}

	local validate_query = queue(remotes.validate_query)
	local request_query = queue(remotes.request_query)
	local disconnect_query = queue(remotes.disconnect_query)
	local advance_query_page = queue(remotes.advance_query_page)
	local pause_query = queue(remotes.pause_query)
	local refresh_query = queue(remotes.refresh_results)

	local function check_if_query_valid(world: types.World, query: string): (boolean, string)
		local map_components = {}
		local ok, result = pcall(query_parser, query)
		local msg = nil

		if not ok then
			return ok, result :: any
		end

		for id, name in world.world:query(jecs.Name):iter() do
			map_components[name] = id
		end

		local total_to_query = 0

		for _, ctype in result do
			if not ok then break end

			if ctype.query and not ctype.exclude then
				total_to_query += 1
			end

			if ctype.type == "Component" then
				if ctype.value.type == "Entity" then
					if world.world:contains(ctype.value.entity) then continue end
					return false, "entity does not exist"
				elseif ctype.value.type == "Name" then
					if map_components[ctype.value.name] then continue end
					return false, `unknown component called {ctype.value.name}`
				else
					return false, "what"
				end
			elseif ctype.type == "Relationship" then
				local both_wildcard = ctype.left.type == "Wildcard" and ctype.right.type == "Wildcard"
				if both_wildcard then
					return false, `(*, *) is not a valid relationship`
				end

				local left = ctype.left
				local right = ctype.right

				if left.type == "Component" then
					if left.value.type == "Entity" then
						if world.world:contains(left.value.entity) then continue end
						return false, "entity does not exist"
					elseif left.value.type == "Name" then
						if map_components[left.value.name] then continue end
						return false, `unknown component called {left.value.name}`
					else
						return false, "what"
					end
				end

				if right.type == "Component" then
					if right.value.type == "Entity" then
						if world.world:contains(right.value.entity) then continue end
						return false, "entity does not exist"
					elseif right.value.type == "Name" then
						if map_components[right.value.name] then continue end
						return false, `unknown component called {right.value.name}`
					else
						return false, "what"
					end
				end
			end
		end

		if total_to_query > 26 then
			warn("attempting to observe too many values")
			return false, "attempting to observe too many entities"
		end

		return ok, msg
	end

	--fixme: contains is missing from types
	local function check_if_still_valid(world: any, entities: {any})
		for _, id in entities do
			if jecs.IS_PAIR(id) then
				if not (world:contains(jecs.pair_first(world, id) and jecs.pair_second(world, id))) then
					return false
				end
			elseif not world:contains(id) then
				return false
			end
		end
		return true
	end

	return function()

		for incoming, world_id, query in validate_query:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end

			local world: types.World = public[world_id]
			local outgoing = reverse_connector(incoming)

			if not world or world.class_name ~= "World" then
				remotes.validate_result:fire(outgoing, world_id, query, false, "world does not exist")
				continue
			end

			local ok, message = check_if_query_valid(world, query)
			remotes.validate_result:fire(outgoing, world_id, query, ok, message)
		end

		for incoming, query_id in disconnect_query:iter() do
			processing_queries[query_id] = nil
		end
		
		for incoming, world_id, query_id, query in request_query:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end

			local world: types.World = public[world_id]
			local outgoing = reverse_connector(incoming)

			if not world or world.class_name ~= "World" then continue end

			local ok = check_if_query_valid(world, query)
			
			if not ok then continue end

			local result = query_parser(query)
			local include = {}
			local exclude = {}
			local with = {}

			local new_columns = {}
			local old_columns = {}

			table.insert(new_columns, {})
			table.insert(old_columns, {})

			local map_components = {}
			local map_entity: {[any]: any} = {}
			for id, name in world.world:query(jecs.Name):iter() do
				map_components[name] = id
			end

			local function get_entity(ctype: query_parser.PureComponent)
				local value = ctype.value

				if value.type == "Entity" then
					return value.entity
				elseif value.type == "Name" then
					return map_components[value.name]
				end
				error("bad")
			end

			for _, ctype in result do
				if ctype.type == "Component" then
					map_entity[ctype] = get_entity(ctype)
				elseif ctype.type == "Relationship" then
					local left, right = jecs.Wildcard, jecs.Wildcard

					if ctype.left.type == "Component" then
						left = get_entity(ctype.left)
					end

					if ctype.right.type == "Component" then
						right = get_entity(ctype.right)
					end

					local pair = jecs.pair(left, right)
					map_entity[ctype] = pair
				end
			end

			for _, ctype in result do
				local entity = map_entity[ctype]
				if ctype.exclude then
					table.insert(exclude, entity)
				elseif ctype.query then
					-- local name = if ctype.type == "Component" then ctype.name else `({ctype.left.name}, {ctype.right.name})`
					table.insert(include, entity)
					table.insert(new_columns, {})
					table.insert(old_columns, {})
				else
					table.insert(with, entity)
				end
			end

			if processing_queries[query_id] then
				local connection = processing_queries[query_id]

				connection.outgoing = outgoing
				connection.query_id = query_id
				connection.world = world
				connection.refresh = true

				connection.include = include
				connection.exclude = exclude
				connection.with = with

				connection.new_columns = new_columns
				connection.old_columns = old_columns
				connection.from = 1
				connection.upto = 25
			else
				local connection: Connection = {

					outgoing = outgoing,
					query_id = query_id,
					frame = 0,
	
					world = world,

					paused = false,
					refresh = false,
	
					include = include,
					exclude = exclude,
					with = with,
	
					new_columns = new_columns,
					old_columns = old_columns,
	
					from = 1,
					upto = 25
				}
	
				processing_queries[query_id] = connection
			end
		end

		for incoming, query_id in refresh_query:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local query = processing_queries[query_id]
			if not query then continue end
			query.refresh = true
		end

		for incoming, query_id, state in pause_query:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local query = processing_queries[query_id]
			if not query then continue end
			query.paused = state
		end

		for incoming, query_id, from, to in advance_query_page:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local query = processing_queries[query_id]
			if not query then continue end

			query.refresh = true
			query.from = from
			query.upto = to
		end

		for query_id, query_data in processing_queries do
			if query_data.paused and query_data.refresh ~= true then continue end
			debug.profilebegin("process query")
			query_data.refresh = false
			local world_data = query_data.world
			local world = world_data.world
			local debug_trait = jecs.Name

			if
				not (check_if_still_valid(world, query_data.include)
				and check_if_still_valid(world, query_data.exclude)
				and check_if_still_valid(world, query_data.with))
			then
				-- query is no longer valid!
				--todo: query is invalid, notify the client about this
				debug.profileend()
				continue
			end

			local query = world:query(unpack(query_data.include))

			if #query_data.exclude > 0 then
				query = query:without(unpack(query_data.exclude))
			end

			if #query_data.with > 0 then
				query = query:with(unpack(query_data.with))
			end

			local from = query_data.from
			local upto = query_data.upto
			
			local new_columns = query_data.new_columns
			local old_columns = query_data.old_columns
			-- set the names of each column
			--todo: fix type
			local function get_name(entity: any)
				if jecs.IS_PAIR(entity) then
					local left = jecs.pair_first(world, entity)
					local right = jecs.pair_second(world, entity)
					return `({get_name(left)}, {get_name(right)})`
				elseif entity == jecs.Wildcard :: any then
					return "*"
				elseif world:has(entity, debug_trait) then
					return world:get(entity, debug_trait)
				else
					return `${entity}`
				end
			end

			-- set column names
			for index, column in new_columns do
				local e = query_data.include[index - 1]

				if e then
					column[1] = get_name(e)
				else
					column[1] = "id"
				end
			end

			-- process the data into columns
			-- we inline the query here, as jecs queries are in reverse to prevent iterator invalidation
			-- this is usually fine, but it's annoying, as now entities are added to the first page.
			--todo: pause button
			local total_entities = 0
			local archetypes = query:archetypes()

			for _, archetype: jecs.Archetype in archetypes do
				total_entities += #archetype.entities
			end

			local entities = table.create(total_entities)
			local at = total_entities
			local row_entity = 1

			for _, archetype: jecs.Archetype in archetypes do
				for row = #archetype.entities, 1, -1 do
					local entity = archetype.entities[row]
					table.insert(entities, entity)
				end
			end

			table.sort(entities)

			for i = from, upto do
				row_entity += 1
				local entity = entities[i]
				if not entity then continue end
				new_columns[1][row_entity] = entity
				for idx, ctype in query_data.include do
					local value = world:get(entity, ctype)
					new_columns[idx + 1][row_entity] = if value == nil then NIL else value
				end
			end

			--- reverse the order of each array

			remotes.count_total_entities:fire(
				query_data.outgoing,
				query_id,
				total_entities
			)

			-- diff the columns and replicate any new values
			for column = 1, math.max(#new_columns, #old_columns) do
				for row = 1, upto do
					local new_value = new_columns[column][row]
					local old_value = old_columns[column][row]

					if new_value ~= old_value or typeof(new_value) == "table" then
						-- todo: improve replication of the new value
						-- ideally, we would figure out if the value is a certain type and needs special replication
						-- if we for example determine a value is a string, or table, we cap it at MAX_CHARACTERS
						-- or we tostring a couple keys of the table until we reach MAX_CHARACTERS.
						-- we wanna be able to replicate every single. value

						local MAX_CHARS = 750
						local str

						if typeof(new_value) == "string" then
							str = `"{string.sub(new_value, 1, MAX_CHARS-2)}"`
						elseif typeof(new_value) == "table" then
							local temp_n = 0
							local temp_b = {}

							for key, value in new_value do
								if #temp_b > 0 then
									table.insert(temp_b, "; ")
								end
								
								local str_of_v = if type(value) == "string" then `"{value}"` else tostring(value)
								local str = `{key}: {str_of_v}`

								if temp_n + #str + 2 > MAX_CHARS then
									table.insert(temp_b, "...")
									break
								else
									table.insert(temp_b, str)
								end
							end

							str = `\{{table.concat(temp_b)}\}`
						elseif new_value == NIL then
							str = "" -- important distinction, this is still a valid component
						elseif new_value == nil then
							str = nil -- but this isnt
						else
							str = string.sub(tostring(new_value), 1, MAX_CHARS-2)
						end

						if row == 1 then str = new_value end
						remotes.update_query_result:fire(
							query_data.outgoing,
							query_id,
							query_data.frame,
							column,
							row,
							str
						)
					end
				end
			end

			query_data.new_columns = clear_columns(old_columns)
			query_data.old_columns = new_columns
			query_data.frame += 1
			debug.profileend()
		end

	end

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="81">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replicate_scheduler</string>
										<string name="ScriptGuid">{5D27BAF2-33A4-48F7-A559-4B4DB73E8981}</string>
										<ProtectedString name="Source"><![CDATA[--!nolint LocalShadow
local hash = require(script.Parent.Parent.Parent.modules.hash_connector)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local traffic_check = require(script.Parent.Parent.Parent.modules.traffic_check)
local types = require(script.Parent.Parent.Parent.modules.types)
local public = require(script.Parent.Parent.public)

return function()

	local connected = {}

	local request_scheduler = queue(remotes.request_scheduler)
	local disconnect_scheduler = queue(remotes.disconnect_scheduler)
	local schedule_pause = queue(remotes.scheduler_system_pause)

	return function()

		for incoming, id in request_scheduler:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end

			local scheduler = public[id]

			if scheduler.class_name ~= "Scheduler" then continue end
			if scheduler == nil then continue end

			local outgoing = reverse_connector(incoming)
			connected[id] = connected[id] or {}
			table.insert(connected[id], outgoing)
			-- print("connected")
			
			for system_id, data in scheduler.system_data do
				remotes.scheduler_system_static_update:fire(outgoing, id, system_id, data)
			end

			for system_id, frames in scheduler.system_frames do
				local frame = frames[1]
				if not frame then continue end
				remotes.scheduler_system_update:fire(outgoing, id, system_id, frame.i, frame.s)
			end
		end

		for incoming, id in disconnect_scheduler:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end

			if not connected[id] then continue end

			local scheduler_connected = connected[id]

			for i = #scheduler_connected, 1, -1 do
				local connector = scheduler_connected[i]
				if connector.host ~= incoming.host then continue end
				if connector.to_vm ~= incoming.from_vm then continue end
				scheduler_connected[i] = scheduler_connected[#scheduler_connected]
				scheduler_connected[#scheduler_connected] = nil
				break
			end
		end

		for incoming, id, system, paused in schedule_pause:iter() do
			if not traffic_check.check_no_wl(incoming.host) then continue end
			local scheduler: types.Scheduler = public[id]

			if not scheduler then return end

			scheduler:set_system_data(system, {
				paused = paused
			})
		end

		for id, connected in connected do
			local scheduler: types.Scheduler = public[id]
			if #connected == 0 then continue end
			
			for system_id in scheduler.system_data_updated do
				local map = {}
				local data = scheduler.system_data[system_id]

				for _, connector in connected do
					if map[hash(connector)] then continue end
					map[hash(connector)] = true
					remotes.scheduler_system_static_update:fire(connector, id, system_id, data)
				end
				
				scheduler.system_data_updated[system_id] = nil
			end

			for system_id, frames in scheduler.system_frames_updated do
				local map = {}
				for frame in frames do
					for _, connector in connected do
						if map[hash(connector)] then continue end
						map[hash(connector)] = true
						remotes.scheduler_system_update:fire(connector, id, system_id, frame.i, frame.s)
					end
				end
				table.clear(frames)
			end

		end

	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="82">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replicate_system_watch</string>
										<string name="ScriptGuid">{0C1C7A46-7B6C-4557-A798-CEC1DB915E0B}</string>
										<ProtectedString name="Source"><![CDATA[--[[

Handles the API for the system watch.
Users will be able to add watches to their systems to track changes.

Users will be able to learn about what actions a system performs on a jecs world
through this.

Hooked API's:

component()
entity()
remove()
clear()
delete()
add()
set()

]]

local jecs = require(script.Parent.Parent.Parent.Parent.jecs)
local hash_connector = require(script.Parent.Parent.Parent.modules.hash_connector)
local lon = require(script.Parent.Parent.Parent.modules.lon)
local queue = require(script.Parent.Parent.Parent.modules.queue)
local remotes = require(script.Parent.Parent.Parent.modules.remotes)
local reverse_connector = require(script.Parent.Parent.Parent.modules.reverse_connector)
local types = require(script.Parent.Parent.Parent.modules.types)
local public = require(script.Parent.Parent.public)
local watch = require(script.Parent.Parent.watch)

local NIL = watch.NIL

return function()

	local stored_watches = {}
	local connected_watches = {}

	local function create_watch_for_id(
		scheduler: types.Scheduler,
		system: types.SystemId,
		watch_id: number
	)
		local watch = scheduler:create_watch_for_system(system)
		stored_watches[watch_id] = watch
	end

	local function send_watch_data_to(host: types.OutgoingConnector, watch_id: number, frame: number)
		local map_worlds_to_name = {}
		local watch = stored_watches[watch_id]
		local frames = watch.watch.frames
		local data = frames[frame]

		if not data then
			remotes.update_watch_data:fire(host, watch_id, frame, nil)
			return
		end

		for _, world in ipairs(public) do
			if world.world == nil then continue end
			map_worlds_to_name[world.world] = jecs.Name
		end

		local to_send = {
			types = data.types,
			entities = data.entities,
			component = table.clone(data.component),
			values = table.clone(data.values)
		}

		for idx, ctype in to_send.component do
			local world = data.worlds[idx]
			to_send.component[idx] = world:get(ctype, map_worlds_to_name[world]) or ctype
		end

		for idx, value in to_send.values do
			if value == NIL then to_send.values[idx] = "" end
			to_send.values[idx] = lon.output(value, false)
		end

		remotes.update_watch_data:fire(host, watch_id, frame, to_send :: any)
	end

	local function remove_watch_id(watch_id: number)
		if not stored_watches[watch_id] then return end
		stored_watches[watch_id].untrack()
		stored_watches[watch_id] = nil
		connected_watches[watch_id] = nil
	end

	local function start_record_watch(watch_id: number)
		local watch = stored_watches[watch_id]
		watch.active = true
	end

	local function stop_record_watch(watch_id: number)
		local watch = stored_watches[watch_id]
		watch.active = false
	end

	local function connect_watch(host: types.OutgoingConnector, watch_id: number)
		connected_watches[watch_id] = connected_watches[watch_id] or {}
		connected_watches[watch_id][hash_connector(host)] = host

		local watch = stored_watches[watch_id]
		for i, frame in watch.watch.frames do
			remotes.update_overview:fire(host, watch_id, i, #frame.types)
		end
	end

	local function disconnect_watch(host: types.OutgoingConnector, watch_id: number)
		if not connected_watches[watch_id] then return end
		connected_watches[watch_id][hash_connector(host)] = nil
	end

	local request_create_watch = queue(remotes.create_watch)	
	local request_remove_watch = queue(remotes.remove_watch)
	local request_watch_data = queue(remotes.request_watch_data)
	local request_stop_watch = queue(remotes.stop_watch)
	local request_record_watch = queue(remotes.start_record_watch)
	local request_connect_watch = queue(remotes.connect_watch)
	local request_disconnect_watch = queue(remotes.disconnect_watch)
	-- local set_lon_enabled = queue(remotes.set_lon_enabled)

	return function()

		for from, scheduler_id, system, watch_id in request_create_watch:iter() do
			local scheduler = public[scheduler_id]

			if scheduler.class_name ~= "Scheduler" then continue end
			if scheduler == nil then continue end
			
			create_watch_for_id(scheduler, system, watch_id)
		end

		for from, watch_id in request_stop_watch:iter() do
			stop_record_watch(watch_id)
		end

		for from, watch_id in request_remove_watch:iter() do
			remove_watch_id(watch_id)
		end

		for from, watch_id, frame in request_watch_data:iter() do
			send_watch_data_to(
				reverse_connector(from),
				watch_id,
				frame
			)
		end

		for from, watch_id in request_record_watch:iter() do
			start_record_watch(watch_id)
		end

		for from, watch_id in request_connect_watch:iter() do
			connect_watch(reverse_connector(from), watch_id)
		end

		for from, watch_id in request_disconnect_watch:iter() do
			disconnect_watch(from, watch_id)
		end

		for watch_id, hosts in connected_watches do
			local watch = stored_watches[watch_id]
			local current_frame = watch.watch.frame
			local frame_data = watch.watch.frames[current_frame] or {types = {}}
			local changes = #frame_data.types

			for _, host in hosts do
				remotes.update_overview:fire(host, watch_id, current_frame, changes)
			end
		end

	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e5</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="83">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">watch</string>
									<string name="ScriptGuid">{172961B1-EAE6-450D-BEC3-CC514E6D86F7}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.modules.types)
local world_hook = require(script.Parent.world_hook)

local NIL = newproxy()

type ChangeTypes = "remove" | "clear" | "delete" | "add" | "set" | "entity" | "component"
type Changes = types.WatchLoggedChanges

export type SystemWatch = {
	--- enables Lua Object Notation.
	--- incurs a significant performance penalty.
	enable_lon: boolean,
	--- the current frame to process
	frame: number,

	frames: {[number]: Changes}
}

local function create_changes()
	return {
		types = {},
		entities = {},
		component = {},
		values = {},
		worlds = {}
	}
end

local function step_watch(watch: SystemWatch)
	watch.frame += 1
	watch.frames[watch.frame] = create_changes()
end

local function track_watch(watch: SystemWatch)

	local hooks = {

		world_hook.hook_onto("remove", function(self, id, component)
			local frame = watch.frames[watch.frame]
			
			table.insert(frame.types, "remove")
			table.insert(frame.entities, id)
			table.insert(frame.component, component)
			table.insert(frame.values, NIL)
			table.insert(frame.worlds, self)
		end),
	
		world_hook.hook_onto("clear", function(self, id)
			local frame = watch.frames[watch.frame]
			
			table.insert(frame.types, "clear")
			table.insert(frame.entities, id)
			table.insert(frame.component, NIL)
			table.insert(frame.values, NIL)
			table.insert(frame.worlds, self)
		end),
	
		world_hook.hook_onto("delete", function(self, id)
			local frame = watch.frames[watch.frame]
			
			table.insert(frame.types, "delete")
			table.insert(frame.entities, id)
			table.insert(frame.component, NIL)
			table.insert(frame.values, NIL)
			table.insert(frame.worlds, self)
		end),
	
		world_hook.hook_onto("add", function(self, id, component)
			local frame = watch.frames[watch.frame]
			
			table.insert(frame.types, "add")
			table.insert(frame.entities, id)
			table.insert(frame.component, component)
			table.insert(frame.values, NIL)
			table.insert(frame.worlds, self)
		end),
		
		world_hook.hook_onto("set", function(self, entity, component, value)
			if self:has(entity, component) then
				local frame = watch.frames[watch.frame]
				
				table.insert(frame.types, "change")
				table.insert(frame.entities, entity)
				table.insert(frame.component, component)
				table.insert(frame.values, value)
				table.insert(frame.worlds, self)
			else
				local frame = watch.frames[watch.frame]
				
				table.insert(frame.types, "move")
				table.insert(frame.entities, entity)
				table.insert(frame.component, component)
				table.insert(frame.values, value)
				table.insert(frame.worlds, self)
			end
		end)

	}
	
	--- stops all hooks
	local function stop_hook()
		for _, destroy in hooks do
			destroy()
		end
	end

	return stop_hook
end

local function create_watch()
	local watch: SystemWatch = {
		enable_lon = false,

		frame = 0,
		frames = {}
	}

	return watch
end

return {

	create_watch = create_watch,
	track_watch = track_watch,
	step_watch = step_watch,

	NIL = NIL

}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e6</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="84">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">world_hook</string>
									<string name="ScriptGuid">{C15C91ED-223B-4AE1-8BBD-36CB6DC3B95B}</string>
									<ProtectedString name="Source"><![CDATA[
local jecs = require(script.Parent.Parent.Parent.jecs)
local world = jecs.World.new()

local function i_hook_onto(key: string, hooks: {(...any) -> ()})

	local method: any = world[key]

	assert(typeof(method) == "function", "can only hook onto functions")

	-- create a new wrapper function
	local function run_hook(...)
		for _, hook in hooks do
			hook(...)
		end
		return method(...)
	end

	-- print(debug.info(world[key], "s"))
	world.__index[key] = run_hook

	local function unhook()
		world.__index[key] = method
	end
	
	return unhook
end

local hooks = {}

local function find_swap_pop<T>(list: {T}, value: T)
	local idx = table.find(list, value)
	if not idx then return end
	list[idx] = list[#list]
	list[#list] = nil
end

local function hook_onto(key: string, hook: (...any) -> ())

	if hooks[key] == nil then
		local callbacks = {}
		local cleanup = i_hook_onto(key, callbacks)
		hooks[key] = {
			cleanup = cleanup,
			callbacks = callbacks
		}
	end

	local hook_info = hooks[key]
	local dead = false
	table.insert(hook_info.callbacks, hook)

	local function unhook()
		if dead then return end
		dead = true
		find_swap_pop(hook_info.callbacks, hook)
		
		if hook_info.callbacks[1] == nil then
			hook_info.cleanup()
			hooks[key] = nil
		end
	end

	return unhook
end

return {
	hook_onto = hook_onto
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e7</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="85">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">jecs</string>
							<string name="ScriptGuid">{D717C1A2-6527-4E94-A4A8-D65173ECE0C6}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["ukendio_jecs@0.9.0"]["jecs"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e8</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="86">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">pebble</string>
							<string name="ScriptGuid">{51D59742-E331-4CCA-AA53-24E3D53F026E}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["alicesaidhi_pebble@0.1.2"]["pebble"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003e9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="87">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">vide</string>
							<string name="ScriptGuid">{97747522-28E3-4269-BDFC-2EA28ED2F0C4}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["centau_vide@0.3.1"]["vide"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ea</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="88">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">alicesaidhi_pebble@0.1.2</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003eb</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="89">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">pebble</string>
							<string name="ScriptGuid">{859104BD-F3A5-41CB-BCB3-78D6366A9796}</string>
							<ProtectedString name="Source"><![CDATA[local accordion = require(script.components.display.accordion)
local background = require(script.components.display.background)
local checkbox = require(script.components.display.checkbox)
local divider = require(script.components.display.divider)
local pages = require(script.components.display.pages)
local pane = require(script.components.display.pane)
local snapping = require(script.components.display.snapping)
local tablesheet = require(script.components.display.tablesheet)
local typography = require(script.components.display.typography)
local widget = require(script.components.display.widget)
local bargraph = require(script.components.graph.bargraph)
local graph = require(script.components.graph.graph)
local linegraph = require(script.components.graph.linegraph)
local button = require(script.components.interactable.button)
local select = require(script.components.interactable.select)
local textfield = require(script.components.interactable.textfield)
local container = require(script.components.util.container)
local gap = require(script.components.util.gap)
local list = require(script.components.util.list)
local padding = require(script.components.util.padding)
local rounded_frame = require(script.components.util.rounded_frame)
local row = require(script.components.util.row)
local shadow = require(script.components.util.shadow)
local virtualscroller = require(script.components.util.virtualscroller)
local anim = require(script.util.anim)
local oklch = require(script.util.oklch)
local theme = require(script.util.theme)

return {

	widget = widget,
	background = background,
	pane = pane,
	snapping = snapping,
	typography = typography,
	tablesheet = tablesheet,
	accordion = accordion,
	divider = divider,
	checkbox = checkbox,

	bargraph = bargraph,
	graph = graph,
	linegraph = linegraph,

	button = button,
	textfield = textfield,
	select = select,

	pages = pages,

	theme = theme,
	anim = anim,
	
	container = container,
	rounded_frame = rounded_frame,
	list = list,
	row = row,
	shadow = shadow,
	
	padding = padding,

	virtualscroller = virtualscroller,
	gap = gap,

	oklch = oklch,

}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ec</UniqueId>
						</Properties>
						<Item class="Folder" referent="90">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">components</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ed</UniqueId>
							</Properties>
							<Item class="Folder" referent="91">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">display</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ee</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="92">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">accordion</string>
										<string name="ScriptGuid">{2EB87F4A-C1FF-4B65-AA3B-DF67D875AE8B}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.util.container)
local padding = require(script.Parent.Parent.util.padding)
local typography = require(script.Parent.typography)

local create = vide.create
local source = vide.source
local changed = vide.changed
local spring = vide.spring

local CHEVRON_DOWN = "rbxassetid://10709790948"
local CHEVRON_UP = "rbxassetid://10709791523"

type can<T> = T | () -> T
type props = {
	text: can<string>,
	expanded: () -> boolean,
	set_expanded: (boolean) -> (),

	[any]: any
}

return function(props: props)

	local gui_state = source(Enum.GuiState.Idle)
	local container_size = source(Vector2.zero)

	return container {
		Name = "Accordion",
		Size = spring(function()
			if props.expanded() == false then return UDim2.new(1, 0, 0, 32) end
			return UDim2.new(1, 0, 0, 40 + container_size().Y)
		end, 0.1),
		ClipsDescendants = true,

		create "ImageButton" {
			Name = "Accordion",
			AutoLocalize = false,
			Size = UDim2.new(1, 0, 0, 32),

			BackgroundColor3 = spring(function()
				return if gui_state() == Enum.GuiState.Press then
					theme.bg[-1]()
				elseif gui_state() == Enum.GuiState.Hover then 
					theme.bg[3]()
				else
					theme.bg[0]()
			end, 0.1),

			padding {x = UDim.new(0, 8)},
			create "UIListLayout" {
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalFlex = Enum.UIFlexAlignment.SpaceBetween,
				VerticalAlignment = Enum.VerticalAlignment.Center,
				Padding = UDim.new(0, 8)
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 8)
			},

			container {
				Size = UDim2.fromOffset(16, 16),
				create "ImageLabel" {
					Size = UDim2.fromOffset(16, 16),
					BackgroundTransparency = 1,
					AutoLocalize = false,
					Image = CHEVRON_DOWN,
	
					Rotation = spring(function()
						return if props.expanded() then 180 else 0
					end, 0.1)
				},
			},

			typography {
				size = UDim2.fromScale(0, 1),
				text = props.text,
				truncate = Enum.TextTruncate.SplitWord,
				xalignment = Enum.TextXAlignment.Left,

				create "UIFlexItem" {
					FlexMode = Enum.UIFlexMode.Fill
				}
			},

			Activated = function()
				props.set_expanded(not props.expanded())
			end,

			changed("GuiState", gui_state)

		},

		container {
			Name = "Children",

			Position = UDim2.fromOffset(0, 40),
			AutomaticSize = Enum.AutomaticSize.None,
			Size = function()
				return UDim2.new(1, 0, 0, container_size().Y)
			end,
			BackgroundColor3 = theme.bg[3],

			ClipsDescendants = true,

			container {
				Size = UDim2.fromScale(1, 0),
				AutomaticSize = Enum.AutomaticSize.Y,

				unpack(props),

				changed("AbsoluteSize", container_size)
			}

		}

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ef</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="93">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">background</string>
										<string name="ScriptGuid">{0D7A5BF3-ECE8-45AE-8D3D-1DA7EA8B9D8D}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)

local create = vide.create
local read = vide.read

type can<T> = (() -> T) | T

type Background = {
    position: can<UDim2>?,
    size: can<UDim2>?,
    anchorpoint: can<UDim2>?,
    automaticsize: can<Enum.AutomaticSize>?,

    layoutorder: can<number>?,
    zindex: can<number>?,

    depth: can<number>?,
    accent: can<boolean>?,

    [number]: any
}

return function(props: Background)

    return create "Frame" {
        Position = props.position,
        Size = props.size or UDim2.fromScale(1, 1),
        AnchorPoint = props.anchorpoint,
        AutomaticSize = props.automaticsize,
        AutoLocalize = false,

        LayoutOrder = props.layoutorder,

        ZIndex = props.zindex,

        BackgroundColor3 = function()
            return
                if read(props.accent) then theme.acc[read(props.depth) or 0]()
                else theme.bg[read(props.depth) or 0]()
        end,

        unpack(props)
        
    }
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="94">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">checkbox</string>
										<string name="ScriptGuid">{7F825A42-FB07-4A8E-9B85-E48F4EF94C00}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local anim = require(script.Parent.Parent.Parent.util.anim)
local theme = require(script.Parent.Parent.Parent.util.theme)

local create = vide.create
local read = vide.read

type can<T> = (() -> T) | T

type Background = {
    position: can<UDim2>?,
    size: can<UDim2>?,
    anchorpoint: can<UDim2>?,
    automaticsize: can<Enum.AutomaticSize>?,

    layoutorder: can<number>?,
    zindex: can<number>?,

    checked: can<boolean>,

    [number]: any
}

return function(props: Background)

    return create "Frame" {
        Position = props.position,
        Size = props.size or UDim2.fromOffset(24, 24),
        AnchorPoint = props.anchorpoint or Vector2.new(0.5, 0.5),
        AutomaticSize = props.automaticsize,
        AutoLocalize = false,

        LayoutOrder = props.layoutorder,

        ZIndex = props.zindex,

        BackgroundColor3 = anim(function()
            return if read(props.checked) then theme.acc[3]() else theme.bg[1]()
        end),

        create "UIStroke" {
            Color = function()
                return if read(props.checked) then theme.acc[0]() else theme.bg[-3]()
            end
        },

        create "UICorner" {
            CornerRadius = UDim.new(0, 4)
        },

        create "ImageLabel" {
            Size = UDim2.fromScale(1, 1),
            BackgroundTransparency = 1,

            Image = "rbxassetid://100188624502987",
            ImageTransparency = anim(function()
                return if read(props.checked) then 0 else 1
            end)
        },

        unpack(props)
        
    }
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="95">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">divider</string>
										<string name="ScriptGuid">{62C446BE-AC13-4A93-8F40-7F7FCFF32331}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)

local create = vide.create
local read = vide.read

type can<T> = T | () -> T
type props = {
	thickness: can<number>?,
	position: can<UDim2>?,
}

return function(props: props)
	
	return create "Frame" {
		BackgroundColor3 = theme.bg[-2],
		Position = props.position,
		AutoLocalize = false,
		Size = function()
			return UDim2.new(1, 0, 0, read(props.thickness) or 1)
		end,
	}
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="96">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">pages</string>
										<string name="ScriptGuid">{9E3C49FA-0F93-4E75-9925-1E4B7B09CA5B}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local anim = require(script.Parent.Parent.Parent.util.anim)
local theme = require(script.Parent.Parent.Parent.util.theme)
local button = require(script.Parent.Parent.interactable.button)
local container = require(script.Parent.Parent.util.container)
local list = require(script.Parent.Parent.util.list)
local padding = require(script.Parent.Parent.util.padding)
local rounded_frame = require(script.Parent.Parent.util.rounded_frame)
local divider = require(script.Parent.divider)
local typography = require(script.Parent.typography)

local create = vide.create
local source = vide.source
local changed = vide.changed
local indexes = vide.indexes
local untrack = vide.untrack
local cleanup = vide.cleanup

type can<T> = T | () -> T
type props = {
	labels: () -> {
		{
			title: string,
			ui: () -> Instance | {Instance}
		}
	}
}

return function(props: props)

	local selected = source(1)

	return list {
		justifycontent = Enum.UIFlexAlignment.Fill,
		spacing = UDim.new(),

		create "Frame" {
			Size = UDim2.new(1, 0, 0, 32),
			AutoLocalize = false,
			BackgroundColor3 = theme.bg[3],

			divider {
				position = UDim2.fromScale(0, 1),
			},

			container {
				create "UIListLayout" {
					FillDirection = Enum.FillDirection.Horizontal
				},
	
				indexes(props.labels, function(value, key)
					local guistate = source(Enum.GuiState.Idle)
	
					return rounded_frame {
						name = key,
						size = UDim2.fromOffset(50, 30),
						automaticsize = Enum.AutomaticSize.X,
						topleft = UDim.new(0, 4),
						topright = UDim.new(0, 4),
	
						color = function()
							return if selected() == key then theme.bg[0]()
								elseif guistate() == Enum.GuiState.Idle then theme.bg[3]()
								else theme.bg[1]()
						end,
	
						create "TextButton" {
							Size = UDim2.fromScale(1, 1),
							AutoLocalize = false,
							BackgroundTransparency = 1,
							
							Activated = function()
								selected(key)
							end,
					
							typography {
					
								position = UDim2.fromScale(0.5, 0.5),
								anchorpoint = Vector2.new(0.5, 0.5),
					
								text = function()
									return value().title
								end,
								
								textsize = 16
							},
					
					
							padding {
								x = UDim.new(0, 24),
								y = UDim.new(0, 2)
							},
					
							changed("GuiState", guistate)
						}
					}
				end),
			},

			ZIndex = 100,

		},
		
		create "Frame" {
			Size = UDim2.new(1, 0, 1, 0),
			AutoLocalize = false,

			BackgroundColor3 = theme.bg[0],

			function()
				return untrack(props.labels()[selected()].ui)
			end

		},

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="97">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">pane</string>
										<string name="ScriptGuid">{1DE6FC66-E7A3-44E3-A439-41C53F4A1D04}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local list = require(script.Parent.Parent.util.list)
local padding = require(script.Parent.Parent.util.padding)
local background = require(script.Parent.background)
local typography = require(script.Parent.typography)

local create = vide.create
local read = vide.read
local show = vide.show

type can<T> = T | () -> T
type props = {

	size: can<UDim2>?,
	position: can<UDim2>?,
	anchorpoint: can<UDim2>?,
	layoutorder: can<number>?,
	automaticsize: can<Enum.AutomaticSize>?,

	name: can<string>?,

	[number]: any

}

return function(props: props)

	return create "Frame" {
		Name = props.name,
		Size = props.size or UDim2.fromScale(1, 0),
		Position = props.position,
		AnchorPoint = props.anchorpoint,
		LayoutOrder = props.layoutorder,
		AutomaticSize = props.automaticsize or Enum.AutomaticSize.Y,
		BackgroundColor3 = theme.bg[0],
		AutoLocalize = false,

		create "UICorner" {
			CornerRadius = UDim.new(0, 8)
		},
		create "UIStroke" {
			Color = theme.bg[-3]
		},
		show(function()
			return if read(props.name) then #read(props.name) > 0 else false
		end, function()
			return background {
				size = UDim2.new(),
				position = UDim2.fromOffset(4, -16),
				automaticsize = Enum.AutomaticSize.XY,

				typography {
					text = props.name,
					disabled = true,

					textsize = 14
				},

				padding {x = UDim.new(0, 2), y = UDim.new()}
			}
		end),

		padding {},
		list {
			unpack(props)
		}

	}
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="98">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">resizeable_bar</string>
										<string name="ScriptGuid">{7F780D3F-0E83-4E22-8A7E-BDADB901ADC2}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local padding = require(script.Parent.Parent.util.padding)
local rounded_frame = require(script.Parent.Parent.util.rounded_frame)
local typography = require(script.Parent.typography)

local create = vide.create
local source = vide.source
local derive = vide.derive
local effect = vide.effect
local cleanup = vide.cleanup
local indexes = vide.indexes
local changed = vide.changed
local untrack = vide.untrack

local MAX_PIXELS_OFFSET = 32

local BEFORE = source(0)
local AFTER = source(1)

type ResizeableBar = {
    meaning: () -> { string },
    min_sizes: (() -> { vide.source<number>? })?,
    sizes: vide.source<{ vide.source<number> }>,
    suggested_sizes: { number }?,

    splits: (vide.source<{ vide.source<number> }>)?,
    base_splits: { number }?

}

return function(props: ResizeableBar)
    local meaning = props.meaning
	local sizes = props.sizes
	local min_sizes = props.min_sizes or source({}) :: never
    local suggested_sizes = props.suggested_sizes or {}

	local absolute_size = source(Vector2.one)
	local absolute_position = source(Vector2.one)

	local total = derive(function()
		return #meaning()
	end)

	local splits = props.splits or source {}
	local total_columns = derive(function()
		return #props.meaning()
	end)

	effect(function(previous)
		local new = {}

		for i = 1, total_columns() - 1 do
			local old_split = vide.read(previous and previous[i] or nil)
			new[i] = source(math.min(if old_split and old_split ~= 1 then old_split else suggested_sizes[i] or 1, i / total_columns()))
		end

		splits(new)
		return new
	end)

	for i, split in (props.base_splits :: never) or {} do
		splits()[i](split)
	end

	local function get_size(index: number)
		local split_before = splits()[index - 1] or BEFORE :: never
		local split_after = splits()[index] or AFTER :: never

		local size = split_after() - split_before()
		return size
	end

	local function get_min_size(i: number)
		local min_size = min_sizes()[i]
		return min_size and min_size() or 0.025
	end

	effect(function()
		local new = setmetatable({}, {
			__index = function()
				return function() return 0 end
			end,
		})

		for i = 1, total() do
			min_sizes()[i] = min_sizes()[i] or source(0.025)
			untrack(function()
				new[i] = derive(function()
					return get_size(i)
				end)
			end)
		end

		sizes(new :: any)
	end)

	local down = false
	local updating = 0

    return rounded_frame {
        size = function()
            return UDim2.new(1, 0, 0, 32)
        end,
        topleft = UDim.new(0, 8),
        topright = UDim.new(0, 8),
        color = theme.bg[1],

        create "TextButton" {
            Size = UDim2.fromScale(1, 1),
            BackgroundTransparency = 1,
			AutoLocalize = false,
            Text = "",

            create "UIListLayout" {
                FillDirection = Enum.FillDirection.Horizontal,
                Padding = UDim.new(0, 0)
            },

            indexes(meaning, function(column, i)
                return typography {
                    size = function()
                        return UDim2.fromScale(get_size(i), 1)
                    end,
                    automaticsize = Enum.AutomaticSize.None,
                    text = function()
                        return column() or ""
                    end,
                    xalignment = Enum.TextXAlignment.Left,
                    truncate = Enum.TextTruncate.AtEnd,
                    header = true,
                    textsize = 18,

                    padding {x = UDim.new(0, 8)}
                }
            end),

            changed("AbsoluteSize", absolute_size),
            changed("AbsolutePosition", absolute_position),

            MouseButton1Down = function(x: number)
                -- find the nearest split
                x -= absolute_position().X
                local absolute_size = absolute_size()
                local nearest = -1
                for i, location in splits() do
                    local absolute_x = absolute_size.X * location()
                    if math.abs(x - absolute_x) > MAX_PIXELS_OFFSET then continue end
    
                    nearest = i
                end
    
                down = nearest ~= -1
                updating = nearest
            end,
    
            MouseButton1Up = function()
                down = false
            end,

            cleanup(RunService.Heartbeat:Connect(function()
                local x = UserInputService:GetMouseLocation().X
    
                x -= absolute_position().X
                if down == false then return end
                down = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) == true
    
                local relative = x / absolute_size().X
                local current = splits()[updating]()
                local left_to_move = relative - current
    
                if left_to_move > 0 then
                    for i = updating, total() - 1, 1 do
                        local min_size = get_min_size(i + 1)
                        local size = get_size(i + 1)
    
                        local new_size = math.max(size - left_to_move, min_size)
                        local difference = size - new_size
    
                        splits()[i](splits()[i]() + difference)
                        left_to_move -= difference
    
                        if left_to_move == 0 then break end
                    end
                else
                    for i = updating, 1, -1 do
                        local min_size = get_min_size(i)
    
                        local size = math.max(get_size(i), min_size) -- this is changing, which it isnt supposed to do
    
                        local new_size = math.max(size + left_to_move, min_size)
                        local difference = new_size - size
    
                        splits()[i](splits()[i]() + difference)
                        --assert((new_size + difference) == get_size(i - 1))
                        left_to_move -= difference
    
                        if left_to_move == 0 then break end
                    end
                end
            end)),
        }

    }
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f5</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="99">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">scroll_frame</string>
										<string name="ScriptGuid">{F0226ABC-36C6-4AAD-881C-2337C8F1B0B2}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)

local create = vide.create

type props = vide.vScrollingFrame

return function(props: props)

	return create "ScrollingFrame" {
		AutoLocalize = false,
		ScrollBarThickness = 6,
		ScrollBarImageColor3 = theme.fg_on_bg_low[0],
		CanvasSize = UDim2.new(),
		
		BackgroundTransparency = 1,

		props

	}
	
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f6</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="100">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">snapping</string>
										<string name="ScriptGuid">{41F1A19F-864E-45EA-813C-1E3190DBCFC3}</string>
										<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local source = vide.source
local cleanup = vide.cleanup
local effect = vide.effect
local action = vide.action
local changed = vide.changed
local untrack = vide.untrack
local read = vide.read

type can<T> = T | () -> T

type snap_area = {
	zindex: can<number>?,
	snapped: (boolean) -> ()
}

type snappable = {
	--- tells the object that you are dragging it
	dragging: () -> boolean,
	--- allows making the widget float by itself without being anchored to anything
	allow_floating: can<boolean>,

	--- callbacks that update the position and size
	snapped: (boolean) -> (),
	position: (UDim2) -> (),
	size: (UDim2) -> ()
}

local function in_bounds(mpos: Vector2, pos: Vector2, size: Vector2)
	return mpos.X >= pos.X and mpos.X <= pos.X + size.X and mpos.Y >= pos.Y and mpos.Y <= pos.Y + size.Y
end

return function()

	local snap_areas = {}
	local mouse_position = source(Vector2.zero)

	local function snap_area(props: snap_area)
		local position = source(Vector2.zero)
		local size = source(Vector2.zero)
		local docked = source(false)

		return create "Frame" {
			Name = "SnapArea",
			AutoLocalize = false,
			Size = UDim2.fromScale(1, 1),

			BackgroundTransparency = 1,
			
			changed("AbsoluteSize", size),
			changed("AbsolutePosition", position),

			action(function(ref)
				snap_areas[ref] = {
					position = position,
					docked = docked,
					size = size,
					zindex = props.zindex or 0
				}

				cleanup(function()
					snap_areas[ref] = nil
				end)
			end)
		}
	end

	local function snappable(props: snappable)
		local snapped_to = source()

		effect(function()
			if props.dragging() == false then return end
			local mpos = mouse_position()

			untrack(function()
				if snapped_to() then snapped_to().docked(false) end

				local snap_to
				
				for _, data in snap_areas do
					if not in_bounds(mpos, data.position(), data.size()) then continue end
					if snap_to and read(data.zindex) <= read(snap_to.zindex) then continue end
					snap_to = data
				end

				if not snap_to and read(props.allow_floating) == false then return end
				if snap_to and snap_to.docked() then return end
				if snap_to then snap_to.docked(true) end
				
				snapped_to(snap_to)
			end)
		end)

		effect(function()
			props.snapped(if snapped_to() then true else false)
		end)

		effect(function()
			if not snapped_to() then return end
			local data = snapped_to()
			local pos = data.position()
			local size = data.size()
			
			props.position(UDim2.fromOffset(pos.X, pos.Y))
			props.size(UDim2.fromOffset(size.X, size.Y))
		end)
	end

	cleanup(UserInputService.InputChanged:Connect(function(input)
		if input.UserInputType ~= Enum.UserInputType.MouseMovement then return end
		mouse_position(Vector2.new(input.Position.X, input.Position.Y))
	end))

	return {
		snap_area = snap_area,
		snappable = snappable
	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="101">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">tablesheet</string>
										<string name="ScriptGuid">{68ADAA93-4F89-4DBD-A4EE-28248A2B175D}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local button = require(script.Parent.Parent.interactable.button)
local rounded_frame = require(script.Parent.Parent.util.rounded_frame)
local virtualscroller = require(script.Parent.Parent.util.virtualscroller)
local resizeable_bar = require(script.Parent.resizeable_bar)
local scroll_frame = require(script.Parent.scroll_frame)

local create = vide.create
local source = vide.source
local derive = vide.derive
local indexes = vide.indexes

type can<T> = T | () -> T
type table = {
	size: can<UDim2>?,
	suggested_column_sizes: { number }?,

	base_splits: { number }?,
	columns: () -> {{any}},

	on_click: (column: number, row: number) -> (),
	on_click2: (column: number, row: number) -> (),
	read_value: (column: number, row: number) -> string,

	below: {[number]: any}?,
	
	[number]: any
}

return function(props: table)
	local sizes = source({})
	local splits = source({})

	local meaning = derive(function()
		local t = {}

		for i, column in props.columns() do
			t[i] = column[1]
		end

		return t
	end)

	local function get_size(index: number)
		local split_before = splits()[index - 1] or source(0) :: never
		local split_after = splits()[index] or source(1) :: never

		local size = split_after() - split_before()
		return size
	end

	return scroll_frame {
		Size = props.size or UDim2.new(1, 0, 0, 8 * 32),
		CanvasSize = function()
			return UDim2.new(1, 0)
		end,

		create "UIListLayout" {
			VerticalFlex = Enum.UIFlexAlignment.SpaceEvenly
		},
		
		resizeable_bar {
			meaning = meaning,
			sizes = sizes,
			splits = splits,
			base_splits = props.base_splits,
			suggested_sizes = props.suggested_column_sizes
		},

		create "Folder" {

			indexes(meaning, function(_, i)
				return create "Frame" {
					Size = UDim2.new(0, 1, 1, -32),
					AutoLocalize = false,
					Position = function()
						local pos = splits()[i]
						return if not pos then UDim2.fromScale(0, 0) else UDim2.fromScale(pos(), 0)
					end,

					BackgroundColor3 = theme.bg[-1],

					ZIndex = 100
				}
			end)
		},

		virtualscroller {
			size = UDim2.fromScale(1, 0),

			create "UIFlexItem" {
				FlexMode = Enum.UIFlexMode.Grow,
			},

			{
				BackgroundColor3 = theme.bg[0],
				VerticalScrollBarInset = Enum.ScrollBarInset.None,
				BackgroundTransparency = 0,
			},

			item_size = 32,
			item = function(index)
				
				return create "Frame" {
					Size = UDim2.new(1, 0, 0, 32),
					AutoLocalize = false,

					BackgroundColor3 = theme.bg[2],

					create "UIListLayout" {
						FillDirection = Enum.FillDirection.Horizontal,
						Padding = UDim.new(0, 0)
					},

					create "UIStroke" {
						Color = theme.bg[-1],
					},

					indexes(props.columns, function(column, i)
						return button {
							size = function()
								local column_size = get_size(i)
								return UDim2.new(column_size, 0, 0, 32)
							end,

							text = function()
								return props.read_value(i, index() + 1) or ""
							end,

							create "UIListLayout" {
								FillDirection = Enum.FillDirection.Horizontal,
								VerticalAlignment = Enum.VerticalAlignment.Center
							},

							xalignment = Enum.TextXAlignment.Left,

							corner = false,
							stroke = false,
							code = true,

							activated = function()
								props.on_click(i, index() + 2)
							end,

							mouse2 = function()
								props.on_click2(i, index() + 2)
							end
						} :: Instance
					end)

				}
	
			end,

			max_items = function()
				local value = (props.columns()[1] ~= nil and #props.columns()[1] or 0)
				return value - 1
			end,
			
	
		},

		rounded_frame {
			size = function()
				return UDim2.new(1, 0, 0, 32)
			end,

			color = theme.bg[1],

			props.below,

			bottomleft = UDim.new(0, 8),
			bottomright = UDim.new(0, 8),
		},

		unpack(props)
	}
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="102">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">typography</string>
										<string name="ScriptGuid">{5CDAED07-A077-42B8-8CCB-5754575791B6}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local anim = require(script.Parent.Parent.Parent.util.anim)
local theme = require(script.Parent.Parent.Parent.util.theme)

local create = vide.create
local read = vide.read

type can<T> = T | () -> T
type props = {

	size: can<UDim2>?,
	position: can<UDim2>?,
	anchorpoint: can<Vector2>?,
	automaticsize: can<Enum.AutomaticSize>?,

	accent: can<boolean>?,

	xalignment: can<Enum.TextXAlignment>?,
	yalignment: can<Enum.TextYAlignment>?,
	truncate: can<Enum.TextTruncate>?,
	wrapped: can<boolean>?,
	
	header: can<boolean>?,
	code: can<boolean>?,
	disabled: can<boolean>?,
	
	text: can<string>,
	textsize: can<number>?,

	visible: can<boolean>?,

	[number]: any

}

return function(props: props)

	local function font()
		return if read(props.code) then theme.code else theme.font
	end

	local function fg()
        local accent = read(props.accent)
		local disabled = read(props.disabled)

        return if accent then
            if disabled then theme.fg_on_acc_low[0]()
            else theme.fg_on_acc_high[0]()
        else
            if disabled then theme.fg_on_bg_low[0]()
            else theme.fg_on_bg_high[0]()
    end

	return create "TextLabel" {

		Size = props.size,
		Position = props.position,
		AnchorPoint = props.anchorpoint,
		AutomaticSize = props.automaticsize or Enum.AutomaticSize.XY,
		AutoLocalize = false,

		TextXAlignment = props.xalignment,
		TextYAlignment = props.yalignment,
		TextTruncate = props.truncate,

		BackgroundTransparency = 1,

		Text = props.text,

		TextSize = props.textsize or function()
			return if read(props.header) then theme.header else theme.body
		end,
		TextWrapped = props.wrapped,
		FontFace = function()
			return if read(props.header) then
				Font.new(font().Family, Enum.FontWeight.Bold)
			else font()
		end,
		TextColor3 = anim(fg),

		Visible = props.visible,

		unpack(props)
	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003f9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="103">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">widget</string>
										<string name="ScriptGuid">{D858B4A4-A4BD-4318-A69B-CD02CF3BDA1A}</string>
										<ProtectedString name="Source"><![CDATA[local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.util.container)
local padding = require(script.Parent.Parent.util.padding)
local shadow = require(script.Parent.Parent.util.shadow)
local divider = require(script.Parent.divider)
local snapping = require(script.Parent.snapping)
local borders = require(script.borders)
local topbar = require(script.topbar)

local create = vide.create
local source = vide.source
local cleanup = vide.cleanup
local changed = vide.changed
local reference = vide.action
local spring = vide.spring

type can<T> = T | () -> T
type props = {

	title: can<string>,
	subtitle: can<string>?,
	min_size: Vector2?,
	position: Vector2?,
	size: Vector2?,

	bind_to_close: (() -> ())?,

	[number]: any

}

local HIGHEST_DISPLAY_ORDER = 100000
local RESIZE_RANGE = 6

local docks

vide.mount(function()

	docks = snapping()

	return create "ScreenGui" {
		Name = "docks",
		AutoLocalize = false,
		
		-- create "Frame" {
		-- 	Size = UDim2.new(1, 0, 0, 200),

		-- 	BackgroundTransparency = 1,
	
		-- 	docks.snap_area {}
		-- },
	
		-- create "Frame" {
		-- 	Size = UDim2.new(1, 0, 0, 200),
		-- 	Position = UDim2.fromScale(0, 1),
		-- 	AnchorPoint = Vector2.new(0, 1),
		-- 	BackgroundTransparency = 1,
	
		-- 	docks.snap_area {}
		-- },
	
		create "Frame" {
			Size = UDim2.new(0, 16, 1, 0),
			BackgroundTransparency = 1,
			AutoLocalize = false,
	
			docks.snap_area {}
		},
	}

end, Players.LocalPlayer.PlayerGui)

return function(props: props)
	local min_size = Vector2.new(100, 100):Max(props.min_size or Vector2.zero)
	local position = props.position or Vector2.new(32, 32)
	local base_size = props.size or min_size * 1.5

	local x_size = source(math.max(min_size.X, base_size.X))
	local y_size = source(math.max(min_size.Y, base_size.Y))
	local x_position = source(position.X)
	local y_position = source(position.Y)

	local offset = source(Vector2.zero)
	local dragging = source(false)
	local absolute_position = source(Vector2.zero)
	local absolute_size = source(Vector2.zero)

	local can_resize_top = source(false)
	local can_resize_bottom = source(false)
	local can_resize_right = source(false)
	local can_resize_left = source(false)
	local resizing = source(false)
	local ref = source()
	local display_order = source(HIGHEST_DISPLAY_ORDER + 1)
	HIGHEST_DISPLAY_ORDER += 1

	local mouse_inside = source(false)

	local top: Vector2
	local bottom: Vector2

	cleanup(UserInputService.InputEnded:Connect(function(input)
		if
			input.UserInputType ~= Enum.UserInputType.MouseButton1
			and input.UserInputType ~= Enum.UserInputType.Touch
		then
			return
		end
		resizing(false)
		dragging(false)
	end))

	cleanup(UserInputService.InputChanged:Connect(function(input: InputObject)
		if input.UserInputType ~= Enum.UserInputType.MouseMovement then return end
		if not resizing() then return end

		local mposition = UserInputService:GetMouseLocation()
		local top_inset, bottom_inset = GuiService:GetGuiInset()
		mposition += - top_inset - bottom_inset
		local x, y = mposition.X, mposition.Y

		if can_resize_bottom() then y_size(math.max(y - top.Y, min_size.Y)) end
		if can_resize_right() then x_size(math.max(x - top.X, min_size.X)) end
		if can_resize_top() then
			y_size(math.max(bottom.Y - y, min_size.Y))
			y_position(math.min(y, bottom.Y - min_size.Y))
		end
		if can_resize_left() then
			x_size(math.max(bottom.X - x, min_size.X))
			x_position(math.min(x, bottom.X - min_size.X))
		end
	end))

	cleanup(UserInputService.InputBegan:Connect(function(input)
		if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
		if not dragging() then resizing(true) end

		top = absolute_position()
		bottom = absolute_position() + absolute_size()

		local player_gui
		if Players.LocalPlayer and RunService:IsRunning() then
			player_gui = Players.LocalPlayer:WaitForChild("PlayerGui") :: PlayerGui
		elseif RunService:IsStudio() and RunService:IsRunning() then
			player_gui = game:GetService("CoreGui") :: any
		else
			return
		end

		local objects = player_gui:GetGuiObjectsAtPosition(input.Position.X, input.Position.Y)
		if #objects == 0 then return end
		if not objects[1]:IsDescendantOf(ref()) then return end

		display_order(HIGHEST_DISPLAY_ORDER + 1)
		HIGHEST_DISPLAY_ORDER += 1
	end))

	cleanup(UserInputService.InputChanged:Connect(function(input: InputObject)
		if dragging() == false then return end
		if not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
			dragging(false)
			return
		end

		local position = UserInputService:GetMouseLocation()
		-- local top_inset, bottom_inset = GuiService:GetGuiInset()
		-- position += - top_inset - bottom_inset
		x_position(position.X + offset().X)
		y_position(position.Y + offset().Y)
	end))

	local snapped = source(false)
	local snap_size = source(UDim2.new())
	local snap_pos = source(UDim2.new())

	local function radius()
		return if snapped() then UDim.new() else UDim.new(0, 6)
	end
	
	return create "ScreenGui" {
		Name = props.title,
		AutoLocalize = false,
		DisplayOrder = display_order,
		reference(ref),

		create "Frame" {
			AutoLocalize = false,
			Position = function()
				return if snapped() then snap_pos() else UDim2.fromOffset(x_position(), y_position())
			end,

			Size = function()
				return if snapped() then UDim2.fromOffset(x_size() + 6, snap_size().Y.Offset) else UDim2.fromOffset(x_size() + 6, y_size() + 6)
			end,
			
			Active = true,

			BackgroundColor3 = theme.bg[0],

			MouseMoved = function()
				if resizing() then return end

				local mposition = UserInputService:GetMouseLocation()
				local top_inset, bottom_inset = GuiService:GetGuiInset()
				position += - top_inset - bottom_inset
				local x, y = mposition.X, mposition.Y
				x -= absolute_position().X
				y -= absolute_position().Y

				can_resize_top(y < RESIZE_RANGE)
				can_resize_left(x < RESIZE_RANGE)
				can_resize_bottom(y > (absolute_size().Y - RESIZE_RANGE))
				can_resize_right(x > (absolute_size().X - RESIZE_RANGE))
			end,

			MouseEnter = function()
				mouse_inside(true)
			end,

			MouseLeave = function()
				if resizing() then return end
				if RunService:IsRunning() == false then return end

				mouse_inside(false)
			end,

			changed("AbsolutePosition", absolute_position),
			changed("AbsoluteSize", absolute_size),

			create "UICorner" {
				CornerRadius = radius
			},

			shadow {},

			borders {

				resize_range = RESIZE_RANGE,
				min_size = min_size,

				can_resize_top = can_resize_top,
				can_resize_bottom = can_resize_bottom,
				can_resize_left = can_resize_left,
				can_resize_right = can_resize_right,

				resizing = resizing,
			},

			container {
				Size = UDim2.fromScale(1, 1),

				create "UIListLayout" {},

				topbar {
					title = props.title,
					subtitle = props.subtitle,
					dragging = dragging,
					offset = offset,
					bind_to_close = props.bind_to_close,
					radius = radius
				},

				divider {},
				
				container {
					Size = UDim2.fromScale(1, 0),

					padding {
						x = UDim.new(0, 8),
						y = UDim.new(0, 8)
					},

					unpack(props),

					create "UIFlexItem" {
						FlexMode = Enum.UIFlexMode.Grow
					},
				}
			},

			docks.snappable {
				dragging = dragging,

				snapped = snapped,
				position = snap_pos,
				size = snap_size
			}

		},

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003fa</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="104">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">borders</string>
											<string name="ScriptGuid">{E1D8C037-D514-4896-80DF-D69A45F18EAD}</string>
											<ProtectedString name="Source"><![CDATA[local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.Parent.util.container)

local create = vide.create
local source = vide.source
local spring = vide.spring
local changed = vide.changed
local cleanup = vide.cleanup

type Source<T> = vide.Source<T>
type props = {

	resize_range: number,
	min_size: Vector2,

	can_resize_left: Source<boolean>,
	can_resize_right: Source<boolean>,
	can_resize_bottom: Source<boolean>,
	can_resize_top: Source<boolean>,

	resizing: () -> boolean,
}

local function xpos(s: () -> number)
	return function()
		return Vector2.new(s(), 0)
	end
end

local function ypos(s: () -> number)
	return function()
		return Vector2.new(0, s())
	end
end

return function(props: props)
	local RESIZE_RANGE = props.resize_range
	local MIN_SIZE = props.min_size

	local can_resize_left = props.can_resize_left
	local can_resize_right = props.can_resize_right
	local can_resize_bottom = props.can_resize_bottom
	local can_resize_top = props.can_resize_top
	local resizing = props.resizing

	local absolute_size = source(Vector2.new(1, 1))
	local absolute_position = source(Vector2.zero)

	local thickness = 4
	local border_selected = theme.acc[8]
	local gradient = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.25, 1),
		NumberSequenceKeypoint.new(0.5, 0),
		NumberSequenceKeypoint.new(0.75, 1),
		NumberSequenceKeypoint.new(1, 1),
	})

	local x = source(0)
	local y = source(0)

	cleanup(RunService.Heartbeat:Connect(function()
		local mposition = UserInputService:GetMouseLocation()
		local top_inset, bottom_inset = GuiService:GetGuiInset()
		mposition += - top_inset - bottom_inset

		if MIN_SIZE.X ~= absolute_size().X or not resizing() then x(mposition.X) end
		if MIN_SIZE.Y ~= absolute_size().Y or not resizing() then y(mposition.Y) end
	end))

	cleanup(RunService.RenderStepped:Connect(function()
		local mposition = UserInputService:GetMouseLocation()
		local top_inset, bottom_inset = GuiService:GetGuiInset()
		mposition += - top_inset - bottom_inset
		local x, y = mposition.X, mposition.Y

		if resizing() then return end

		local left = absolute_position().X
		local top = absolute_position().Y
		local right = left + absolute_size().X
		local bottom = top + absolute_size().Y

		local topleft = absolute_position() - Vector2.new(RESIZE_RANGE, RESIZE_RANGE)
		local bottomright = absolute_position() + absolute_size() + Vector2.new(RESIZE_RANGE, RESIZE_RANGE)

		-- perform AABB to check if the cursor is in range
		local within_bounds = x > topleft.X and y > topleft.Y and x < bottomright.X and y < bottomright.Y

		can_resize_top(y > top - RESIZE_RANGE and y < top and within_bounds)
		can_resize_left(x < left + RESIZE_RANGE and x > left - RESIZE_RANGE and within_bounds)
		can_resize_bottom(y < bottom + RESIZE_RANGE and y > bottom - RESIZE_RANGE and within_bounds)
		can_resize_right(x < right + RESIZE_RANGE and x > right - RESIZE_RANGE and within_bounds)
	end))

	return {

		changed("AbsoluteSize", function(value: Vector2)
			if value.Magnitude == 0 then return end
			absolute_size(value)
		end),
		changed("AbsolutePosition", absolute_position),

		container {

			Name = "Left",

			Position = UDim2.fromScale(0, 0.5),
			Size = UDim2.new(0, thickness, 1, thickness * 2),
			AnchorPoint = Vector2.new(1, 0.5),

			BackgroundColor3 = border_selected,

			BackgroundTransparency = spring(function()
				return can_resize_left() and 0 or 1
			end, 0.2),

			ZIndex = 1000,

			create "UIGradient" {

				Rotation = 90,

				Transparency = gradient,
				Offset = ypos(spring(function()
					return (y() - absolute_position().Y - absolute_size().Y / 2) / absolute_size().Y
				end, 0.1)),
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 4)
			},
		},

		container {

			Name = "Right",

			Position = UDim2.fromScale(1, 0.5),
			Size = UDim2.new(0, thickness, 1, thickness * 2),
			AnchorPoint = Vector2.new(0, 0.5),

			BackgroundColor3 = border_selected,

			BackgroundTransparency = spring(function()
				return can_resize_right() and 0 or 1
			end, 0.2),

			ZIndex = 1000,

			create "UIGradient" {

				Rotation = 90,

				Transparency = gradient,
				Offset = ypos(spring(function()
					return (y() - absolute_position().Y - absolute_size().Y / 2) / absolute_size().Y
				end, 0.1)),
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 4)
			},
		},

		container {

			Name = "Bottom",

			Position = UDim2.fromScale(0.5, 1),
			Size = UDim2.new(1, thickness * 2, 0, thickness),
			AnchorPoint = Vector2.new(0.5, 0),

			BackgroundColor3 = border_selected,

			BackgroundTransparency = spring(function()
				return can_resize_bottom() and 0 or 1
			end, 0.2),

			ZIndex = 1000,

			create "UIGradient" {

				Transparency = gradient,
				Offset = xpos(spring(function()
					return (x() - absolute_position().X - absolute_size().X / 2) / absolute_size().X
				end, 0.1)),
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 4)
			},
		},

		container {

			Name = "Top",

			Position = UDim2.fromScale(0.5, 0),
			Size = UDim2.new(1, thickness * 2, 0, thickness),
			AnchorPoint = Vector2.new(0.5, 1),

			BackgroundColor3 = border_selected,

			BackgroundTransparency = spring(function()
				return can_resize_top() and 0 or 1
			end, 0.2),

			ZIndex = 1000,

			create "UIGradient" {

				Transparency = gradient,
				Offset = xpos(spring(function()
					return (x() - absolute_position().X - absolute_size().X / 2) / absolute_size().X
				end, 0.1)),
			},

			create "UICorner" {
				CornerRadius = UDim.new(0, 4)
			},
		},
	} :: { any }
end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003fb</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="105">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">topbar</string>
											<string name="ScriptGuid">{9E9F204A-D73A-4CB1-858F-46EA032342AA}</string>
											<ProtectedString name="Source"><![CDATA[
local vide = require(script.Parent.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.Parent.util.theme)
local list = require(script.Parent.Parent.Parent.util.list)
local padding = require(script.Parent.Parent.Parent.util.padding)
local rounded_frame = require(script.Parent.Parent.Parent.util.rounded_frame)
local typography = require(script.Parent.Parent.typography)

local create = vide.create
local source = vide.source
local changed = vide.changed
local spring = vide.spring
local show = vide.show

type Source<T> = vide.Source<T>
type props = {

	title: (string | () -> string)?,
	subtitle: (string | () -> string)?,
	bind_to_close: (() -> ())?,

	radius: () -> UDim,

	dragging: Source<boolean>,
	offset: (new: Vector2) -> (),

	[any]: any,
}

return function(props: props)
	local bind_to_close = props.bind_to_close
	local dragging = props.dragging
	local offset = props.offset

	local closeable = not not bind_to_close

	local absolute_position = source(Vector2.zero)

	local gui_state = source(Enum.GuiState.Idle)

	return rounded_frame {

		name = "Topbar",
	
		size = UDim2.new(1, 0, 0, 48),
		color = theme.bg[3],

		topleft = props.radius,
		topright = props.radius,

		create "ImageButton" {
			Size = UDim2.fromScale(1, 1),
			AutoLocalize = false,
			BackgroundTransparency = 1,
			ZIndex = 1000,
	
			changed("AbsolutePosition", absolute_position),
	
			MouseButton1Down = function(x, y)
				offset(absolute_position() - Vector2.new(x, y))
				dragging(true)
			end,
			create "UIListLayout" {
				FillDirection = Enum.FillDirection.Horizontal,
				VerticalAlignment = Enum.VerticalAlignment.Center,
				HorizontalFlex = Enum.UIFlexAlignment.Fill,
			},
	
			padding {
				x = UDim.new(0, 16)
			},
	
			list {
				spacing = UDim.new(),

				typography {
					size = UDim2.fromScale(1, 0),
					text = props.title,
					
					xalignment = Enum.TextXAlignment.Left,
					truncate = Enum.TextTruncate.SplitWord,
					textsize = 20,
					header = true,
				},

				show(function()
					return props.subtitle ~= nil
				end, function()
					return typography {
						size = UDim2.fromScale(1, 0),
						text = props.subtitle,
						bold = true,
						
						xalignment = Enum.TextXAlignment.Left,
						truncate = Enum.TextTruncate.SplitWord,
	
						textsize = 16,
					}
				end)

			},

			show(source(closeable), function()
				return create "ImageButton" {

					Size = UDim2.fromOffset(32, 32),
	
					BackgroundColor3 = spring(function()
						return if gui_state() == Enum.GuiState.Hover then
							theme.bg[5]()
						elseif gui_state() == Enum.GuiState.Press then
							theme.bg[0]()
						else
							theme.bg[3]()
					end, 0.1),
	
					changed("GuiState", gui_state),
	
					Activated = props.bind_to_close,
	
					create "UICorner" {
						CornerRadius = UDim.new(1, 0)
					},
	
					create "ImageLabel" {
						Size = UDim2.fromOffset(24, 24),
						Position = UDim2.fromScale(0.5, 0.5),
						AnchorPoint = Vector2.new(0.5, 0.5),
						AutoLocalize = false,
	
						BackgroundTransparency = 1,

						ImageColor3 = theme.fg_on_bg_high[3],
	
						Image = "rbxassetid://10747384394",
	
					},
	
					create "UIFlexItem" {
						FlexMode = Enum.UIFlexMode.Custom,
						ShrinkRatio = 0
					}
	
				}
			end)
	
		}

	}
end]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003fc</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="106">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">graph</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003fd</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="107">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">bargraph</string>
										<string name="ScriptGuid">{B6E6AB09-EAE2-4050-A95C-DB0BCFE344F7}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.util.container)

local create = vide.create
local indexes = vide.indexes
local read = vide.read

type can<T> = T | () -> T
type props = {

	position: can<UDim2>?,
	size: can<UDim2>?,
	anchorpoint: can<UDim2>?,

	values: () -> {number},
	max: can<number>?,
	min: can<number>?,
	
	[number]: Instance

}

return function(props: props)

	local max = props.max or function()
		return math.max(unpack(props.values()))
	end

	local function total()
		return #props.values()
	end

	return container {

		Position = props.position,
		Size = props.size,
		AnchorPoint = props.anchorpoint,

		ClipsDescendants = true,

		indexes(props.values, function(value, index)
			
			return create "Frame" {
				AutoLocalize = false,

				Position = function()
					return UDim2.fromScale((index - 1) / total(), 1)
				end,
				Size = function()
					return UDim2.fromScale(
						1/total(),
						value() / read(max)
					)
				end,
				AnchorPoint = Vector2.new(0, 1),

				create "UIGradient" {
					Color = function()
						return ColorSequence.new(
							theme.acc[10](),
							theme.acc[-3]()
						)
					end,

					Rotation = 90
				}

			}

		end),

		unpack(props)

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003fe</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="108">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">graph</string>
										<string name="ScriptGuid">{059648E9-238D-459E-AD10-EF9508F47FBE}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.util.container)

local create = vide.create
local source = vide.source
local action = vide.action
local effect = vide.effect

type can<T> = T | () -> T
type props = {

	position: can<UDim2>?,
	size: can<UDim2>?,
	anchorpoint: can<UDim2>?,

	values: () -> {Path2DControlPoint},

	[number]: Instance

}

return function(props: props)

	local path2d: vide.Source<Path2D> = source()

	effect(function()
		if not path2d() then return end

		local path = path2d()
		path:SetControlPoints(props.values())
	end)

	return container {

		Position = props.position,
		Size = props.size,
		AnchorPoint = props.anchorpoint,

		create "Path2D" {

			Thickness = 2,
			Color3 = theme.acc[3],

			action(path2d)

		},

		unpack(props)

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000003ff</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="109">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">linegraph</string>
										<string name="ScriptGuid">{F61F8BCC-3F29-4FF8-BC3E-188869630995}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local container = require(script.Parent.Parent.util.container)

local create = vide.create
local source = vide.source
local action = vide.action
local effect = vide.effect
local read = vide.read

type can<T> = T | () -> T
type props = {

	position: can<UDim2>?,
	size: can<UDim2>?,
	anchorpoint: can<UDim2>?,

	values: () -> {number},
	max: can<number>?,
	min: can<number>?,

	[number]: Instance
}

return function(props: props)

	local path2d: vide.Source<Path2D> = source()

	effect(function()
		if not path2d() then return end

		local path = path2d()
		local points = table.create(50)
		local total = #props.values()
		local max = read(props.max) or 100
		local min = read(props.min) or 0
		local diff = math.abs(max - min)

		for index, value in props.values() do
			table.insert(
				points,
				Path2DControlPoint.new(
					UDim2.fromScale(
						(index - 1) / (total - 1), 1 - (value - min) / diff
					)
				)
			)
		end

		path:SetControlPoints(points)
	end)

	return container {

		Position = props.position,
		Size = props.size,
		AnchorPoint = props.anchorpoint,
		
		ClipsDescendants = true,

		create "Path2D" {

			Thickness = 2,
			Color3 = theme.acc[3],

			action(path2d)

		},

		unpack(props)

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000400</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="110">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">interactable</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000401</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="111">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">button</string>
										<string name="ScriptGuid">{9B14C045-20D0-4827-AE7F-E051BA915729}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local anim = require(script.Parent.Parent.Parent.util.anim)
local theme = require(script.Parent.Parent.Parent.util.theme)
local typography = require(script.Parent.Parent.display.typography)
local padding = require(script.Parent.Parent.util.padding)

local create = vide.create
local source = vide.source
local changed = vide.changed
local show = vide.show
local read = vide.read

type can<T> = T | () -> T
type props = {

    size: can<UDim2>?,
    position: can<UDim2>?,
    anchorpoint: can<Vector2>?,
    automaticsize: can<Enum.AutomaticSize>?,

    text: can<string>?,
    disabled: can<boolean>?,

    activated: () -> ()?,
    mouse2: () -> ()?,
    down: () -> ()?,
    up: () -> ()?,

    --- enables the stroke (enabled by default)
    stroke: can<boolean>?,
    --- enables the corner (enabled by default)
    corner: can<boolean>?,
    accent: can<boolean>?,

    xalignment: can<Enum.TextXAlignment>?,

    code: can<boolean>?,

    [number]: any

}

return function(props: props)

    local guistate = source(Enum.GuiState.Idle)

    local function bg()
        local accent = read(props.accent)
        local guistate = guistate()

        return if accent then
            if guistate == Enum.GuiState.NonInteractable then theme.acc[-5]()
            elseif guistate == Enum.GuiState.Idle then theme.acc[0]()
            elseif guistate == Enum.GuiState.Hover then theme.acc[3]()
            elseif guistate == Enum.GuiState.Press then theme.acc[-8]()
            else theme.acc[0]()
        else
            if guistate == Enum.GuiState.NonInteractable  then theme.bg[-2]()
            elseif guistate == Enum.GuiState.Idle then theme.bg[3]()
            elseif guistate == Enum.GuiState.Hover then theme.bg[6]()
            elseif guistate == Enum.GuiState.Press then theme.bg[0]()
            else theme.acc[0]()
    end

    local function stroke()
        local accent = read(props.accent)
        local guistate = guistate()

        return if accent then
                if guistate == Enum.GuiState.NonInteractable then theme.acc[-7]()
                else theme.acc[-7]()
            else
                if guistate == Enum.GuiState.NonInteractable then theme.bg[-3]()
                else theme.bg[-3]()
    end

    return create "TextButton" {

        Name = props.text,
        AutoLocalize = false,

        Size = props.size or UDim2.fromOffset(100, 30),
        Position = props.position,
        AnchorPoint = props.anchorpoint,
        AutomaticSize = props.automaticsize,

        Interactable = function()
            return not read(props.disabled) 
        end,

        BackgroundColor3 = anim(bg),

        Activated = props.activated,
        MouseButton2Click = props.mouse2,
        MouseButton1Down = props.down,
        MouseButton1Up = props.up,

        typography {

            position = UDim2.fromScale(0.5, 0.5),
            anchorpoint = Vector2.new(0.5, 0.5),
            size = UDim2.fromScale(1, 1),
            automaticsize = Enum.AutomaticSize.Y,

            text = props.text,
            truncate = Enum.TextTruncate.SplitWord,
            xalignment = props.xalignment,

            accent = props.accent,
            disabled = props.disabled,

            visible = function()
                return read(props.text) ~= ""
            end,

            code = props.code,

            create "UIFlexItem" {
                FlexMode = Enum.UIFlexMode.Fill
            }

        },

        show(
            function()
                return read(props.stroke) ~= false
            end,
            source(
                create "UIStroke" {
                    ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                    
                    Color = anim(stroke),
                    Thickness = 1,
                    Enabled = props.stroke
                }
            )
        ),

        show(
            function()
                return read(props.corner) ~= false
            end,
            source(
                create "UICorner" {
                    CornerRadius = UDim.new(0,4)
                }
            )
        ),

        padding {
            x = UDim.new(0, 8),
            y = UDim.new(0, 2)
        },

        changed("GuiState", guistate),
        
        unpack(props),

    }
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000402</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="112">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">select</string>
										<string name="ScriptGuid">{EE240875-4F2D-4519-94EC-BEFEAE0AAA99}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local theme = require(script.Parent.Parent.Parent.util.theme)
local scroll_frame = require(script.Parent.Parent.display.scroll_frame)
local container = require(script.Parent.Parent.util.container)
local list = require(script.Parent.Parent.util.list)
local padding = require(script.Parent.Parent.util.padding)
local portal = require(script.Parent.Parent.util.portal)
local button = require(script.Parent.button)

local create = vide.create
local source = vide.source
local changed = vide.changed
local indexes = vide.indexes
local spring = vide.spring
local read = vide.read

local MAX_SIZE = 100

type can<T> = T | () -> T
type dropdown = {
	size: can<UDim2>?,
	position: can<UDim2>?,
	anchorpoint: can<Vector2>?,

	selected: can<number>,
	update_selected: (() -> number)?,

	options: can<{string}>
}

local function dropdown(props: dropdown)
	
	local selected = props.selected
	local update_selected = props.update_selected or function() end
	local options = props.options

	local enabled = source(false)
	local absolute_size = source(Vector2.zero)

	local size = spring(function()
		if not enabled() then return UDim2.fromScale(1, 0) end
		return UDim2.new(1, 0, 0, math.min(MAX_SIZE, absolute_size().Y))
	end, 0.1)

	return button {

		size = props.size or UDim2.fromOffset(200, 32),
		position = props.position or UDim2.fromScale(0.5, 0.5),
		anchorpoint = props.anchorpoint or Vector2.new(0.5, 0.5),

		xalignment = Enum.TextXAlignment.Left,

		text = function()
			return read(options)[read(selected)]
		end,

		activated = function()
			enabled(not enabled())
		end,
		
		create "UIListLayout" {
			FillDirection = Enum.FillDirection.Horizontal,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			Padding = UDim.new(0, 8),
		},
		
		container {

			AnchorPoint = Vector2.new(1, 0),
			Position = UDim2.fromScale(1, 0),
			Size = UDim2.new(0, 18, 0, 16),

			LayoutOrder = -1,

			create "ImageLabel" {

				Name = "arrow",
				AutoLocalize = false,

				Size = UDim2.new(0, 8, 0, 4),
				Position = UDim2.fromScale(0.5, 0.5),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Rotation = spring(function()
					return if enabled() then -180 else 0
				end, 0.1),

				BackgroundTransparency = 1,

				BackgroundColor3 = theme.fg_on_bg_high[3],

				Image = "rbxassetid://7260137654",
				ImageColor3 = theme.fg_on_bg_low[3],
				ScaleType = Enum.ScaleType.Stretch

			}

		},

		portal {
			inherit_layout = true,
			
			container {
				Position = UDim2.new(0, 1, 1, 4),
				Size = size,

				BackgroundTransparency = 0,
				BackgroundColor3 = theme.bg[3],

				ClipsDescendants = true,

				Visible = function()
					return size().Y.Offset > 1
				end,

				padding {
					padding = UDim.new(0, 2)
				},

				scroll_frame {
					Size = UDim2.fromScale(1, 1),
					ScrollBarThickness = 4,
					AutomaticCanvasSize = Enum.AutomaticSize.Y,

					list {
						spacing = UDim.new(0, 1),

						changed("AbsoluteSize", absolute_size),

						indexes(function()
							return read(options)
						end, function(value, key)
							return button {
								size = UDim2.new(1, 0, 0, 30),
								text = value,
								stroke = false,

								activated = function()
									enabled(false)
									update_selected(key)
								end,

								create "UIListLayout" {
									FillDirection = Enum.FillDirection.Horizontal,
									VerticalAlignment = Enum.VerticalAlignment.Center,
									Padding = UDim.new(0, 8),
								},
							}
						end)
					}
				},

				create "UIStroke" {
					Color = theme.bg[-3]
				},

				create "UICorner" {
					CornerRadius = UDim.new(0, 3)
				}
			}
		}

	}
	
end

return dropdown]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000403</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="113">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">textfield</string>
										<string name="ScriptGuid">{13C4B93B-914A-4F14-B9B7-4EA47408728B}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local anim = require(script.Parent.Parent.Parent.util.anim)
local theme = require(script.Parent.Parent.Parent.util.theme)
local typography = require(script.Parent.Parent.display.typography)
local padding = require(script.Parent.Parent.util.padding)

local create = vide.create
local source = vide.source
local changed = vide.changed
local effect = vide.effect
local action = vide.action
local read = vide.read

type can<T> = T | () -> T
type props = {

    size: can<UDim2>?,
    position: can<UDim2>?,
    anchorpoint: can<UDim2>?,
    
    text: can<string>?,
    placeholder: can<string>?,

    multiline: can<boolean>?,
    code: can<boolean>?,

    disabled: can<boolean>?,

    stroke: can<boolean>?,
    corner: can<boolean>?,

    --- called whenever a character is added / removed
    oninput: ((new: string) -> ())?,
    --- called whenever focus is lost
    focuslost: ((text: string, enter: boolean?) -> ())?,
    --- called whenever focus is lost by pressing enter
    enter: ((text: string) -> ())?,

}

return function(props: props)

    local guistate = source(Enum.GuiState.Idle)
    local focused = source(false)
    local textbox = source() :: vide.Source<TextBox>
    local text = source("")

    effect(function()
        text(read(props.text) or "")
    end)

    local function bg()
        local guistate = guistate()

        return if guistate == Enum.GuiState.NonInteractable then theme.bg[0]()
            elseif focused() then theme.bg[-3]()
            else theme.bg[-2]()
    end

    local function fg()
        local disabled = read(props.disabled)

        return if disabled then theme.fg_on_bg_low[0]()
            else theme.fg_on_bg_high[0]()
    end

    local function stroke()
        local guistate = guistate()

        return if guistate == Enum.GuiState.NonInteractable then theme.bg[-3]()
            elseif focused() then theme.acc[5]()
            elseif guistate == Enum.GuiState.Idle then theme.bg[-3]()
            elseif guistate == Enum.GuiState.Hover then theme.bg[3]()
            else theme.bg[-3]()
    end

    -- this effect will automatically focus the textbox if focused is true
    effect(function()
        if focused() == true and textbox() then
            textbox():CaptureFocus()
        end
    end)

    return create "TextButton" {

        Name = props.placeholder or "Textbox",
        AutoLocalize = false,

        Size = props.size or UDim2.fromOffset(300, 30),
        Position = props.position,
        AnchorPoint = props.anchorpoint,

        Activated = function()
            focused(true)
        end,

        Interactable = function()
            return not props.disabled 
        end,

        BackgroundColor3 = anim(bg),

        ClipsDescendants = true,

        create "TextBox" {

            Size = UDim2.fromScale(1, 1),
			AutoLocalize = false,

            MultiLine = props.multiline,

            BackgroundTransparency = 1,

            Focused = function()
                focused(true)
            end,

            FocusLost = function(enter)
                focused(false)
                if props.focuslost then
                    props.focuslost(text(), enter)
                end

                if props.enter then
                    props.enter(text())
                end
            end,

            TextSize = theme.body,
            FontFace = function()
                return if read(props.code) then theme.code else theme.font
            end,
            TextColor3 = anim(fg),
            PlaceholderColor3 = theme.fg_on_bg_low[0],

            PlaceholderText = props.placeholder,
            Text = props.text,

            ClipsDescendants = true,

            TextXAlignment = Enum.TextXAlignment.Left,
            TextYAlignment = function()
                return if read(props.multiline) then Enum.TextYAlignment.Top else Enum.TextYAlignment.Center
            end,

            action(textbox),
            changed("Text", text),
            if props.oninput then changed("Text", props.oninput) else nil

        },

        create "UIStroke" {
            ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
            
            Color = anim(stroke),
            Thickness = 1,
            Enabled = props.stroke
        },

        create "UICorner" {
            CornerRadius = function()
                return if read(props.corner) == false then UDim.new() else UDim.new(0, 4)
            end
        },

        padding {
            x = UDim.new(0, 8),
            y = UDim.new(0, 2)
        },

        changed("GuiState", guistate)

    }

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000404</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="114">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">util</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000405</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="115">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">container</string>
										<string name="ScriptGuid">{981AA16F-42E1-44C3-B81C-F54DAFC7C609}</string>
										<ProtectedString name="Source"><![CDATA[--[[

container is a basic transparent frame that covers the entire frame.

]]

local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create

local function container(props: vide.vFrame)
	return create "Frame" {

		Name = "Container",
		AutoLocalize = false,
		
		Size = UDim2.fromScale(1, 1),

		BackgroundTransparency = 1,

		props,
	}
end

return container
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000406</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="116">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">gap</string>
										<string name="ScriptGuid">{69554384-0CD7-4467-BD88-41D5D1FD5374}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local container = require(script.Parent.container)

local read = vide.read

type can<T> = T | () -> T
type props = {

	gap: can<number>,
	direction: can<"x" | "y">?,

}

return function(props: props)

	local function direction()
		return read(props.direction) or "x"
	end

	return container {

		Size = function()
			return if direction() == "x" then
				UDim2.new(0, read(props.gap), 1, 0)
			else
				UDim2.new(1, 0, 0, read(props.gap))
		end

	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000407</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="117">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">list</string>
										<string name="ScriptGuid">{EE2CB15D-31B6-41B1-9E32-0B5F5D346379}</string>
										<ProtectedString name="Source"><![CDATA[--[[

Creates a container for a list of elements.

]]

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local container = require(script.Parent.container)

local create = vide.create
local read = vide.read

type can<T> = (() -> T) | T
type layout = {
	
	justifycontent: can<Enum.UIFlexAlignment>?,
	alignitems: can<Enum.ItemLineAlignment>?,
	spacing: can<number | UDim>?,
	wraps: can<boolean>?,

	[number]: Instance
}

local function layout(props: layout)
	return container {

		Size = UDim2.fromScale(1, 0),
		AutomaticSize = Enum.AutomaticSize.Y,
		
		create "UIListLayout" {
			Padding = function()
				local spacing: number | UDim? = read(props.spacing)
				
				return if typeof(spacing) == "number" then
					UDim.new(0, spacing)
				elseif typeof(spacing) == "UDim" then
					spacing
				elseif typeof(spacing) == "nil" then
					UDim.new(0, 8)
				else
					error("incorrect spacing type")
			end,

			VerticalFlex = props.justifycontent,
			ItemLineAlignment = props.alignitems,
			Wraps = props.wraps
			
		},

		unpack(props)
	}
	
end

return layout]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000408</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="118">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">padding</string>
										<string name="ScriptGuid">{FA089395-BC78-42E8-8735-B95F875BEF64}</string>
										<ProtectedString name="Source"><![CDATA[--[[

Fast and easy to use padding utility to make controlling padding quick and simple.

]]

local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create

type can<T> = T | () -> T
type padding = {
	padding: can<UDim>?,
	x: can<UDim>?,
	y: can<UDim>?,
	left: can<UDim>?,
	right: can<UDim>?,
	top: can<UDim>?,
	bottom: can<UDim>?
}

local function padding(props: padding)
	
	local padding = props.padding or UDim.new(0, 8)
	local x = props.x or padding
	local y = props.y or padding
	local left = props.left or x
	local right = props.right or x
	local top = props.top or y
	local bottom = props.bottom or y

	return create "UIPadding" {
		PaddingLeft = left,
		PaddingRight = right,
		PaddingTop = top,
		PaddingBottom = bottom,
	}
	
end

return padding]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000409</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="119">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">portal</string>
										<string name="ScriptGuid">{5043C28C-79ED-40B4-ABE9-3703D67533B1}</string>
										<ProtectedString name="Source"><![CDATA[--[[

portal is used to render a component over other components.
it will find the nearest layer collector to parent itself and it's descendants
onto, and if inherit_layout is enabled, inherits the nearest guibase2d's size and
position properties.

]]
local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create
local source = vide.source
local effect = vide.effect
local cleanup = vide.cleanup
local ref = vide.action
local read = vide.read

type can<T> = T | () -> T
type portal = {
	--- controls if the portal should inherit the layout of the frame it's under
	inherit_layout: can<boolean>?,

	[number]: Instance,
}

local layout = 100_000

local function portal(props: portal)

	local inherit_layout = props.inherit_layout

	local nearest_gui_base = source(nil :: GuiBase2d?)
	local nearest_layer_collector = source(nil :: LayerCollector?)

	local size = source(UDim2.fromScale(1, 1))
	local position = source(UDim2.fromScale(0, 0))
	local reference = source(nil :: Configuration?)

	-- this will create connections to update the size and position sources
	effect(function()
		local object = nearest_gui_base()
		if not object then return end
		
		local function update()
			size(UDim2.fromOffset(object.AbsoluteSize.X, object.AbsoluteSize.Y))
			position(UDim2.fromOffset(object.AbsolutePosition.X, object.AbsolutePosition.Y))
		end

		cleanup(object:GetPropertyChangedSignal("AbsoluteSize"):Connect(update))
		cleanup(object:GetPropertyChangedSignal("AbsolutePosition"):Connect(update))
	end)

	-- creates a container that is mounted to somewhere.
	cleanup(vide.mount(function()
		cleanup(create "Frame" {

			Name = `Portal:{layout}`,
			Parent = nearest_layer_collector,
			AutoLocalize = false,
			ZIndex = layout,

			Size = function()
				return if read(inherit_layout) == true then size()
				else UDim2.fromScale(1, 1)
			end,
			Position = function()
				return if read(inherit_layout) == true then position()
				else UDim2.fromScale(0, 0)
			end,

			BackgroundTransparency = 1,

			unpack(props)

		})
	end))

	-- this is an anchor used to reference what gui base and layer collector to use.
	return create "Configuration" {
		Name = `PortalAnchor:{layout}`,

		AncestryChanged = function()
			local reference = reference()
			if not reference then
				nearest_gui_base(nil)
				return
			end
			nearest_gui_base(reference:FindFirstAncestorWhichIsA("GuiBase2d"))
			nearest_layer_collector(reference:FindFirstAncestorWhichIsA("LayerCollector"))
		end,

		ref(function(instance)
			layout += 1
			reference(instance)
			nearest_gui_base(instance:FindFirstAncestorWhichIsA("GuiBase2d"))
			nearest_layer_collector(instance:FindFirstAncestorWhichIsA("LayerCollector"))
		end)
	}
	
end

return portal]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="120">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">rounded_frame</string>
										<string name="ScriptGuid">{87928FF8-13F2-4E49-9A98-ED5F156E7F28}</string>
										<ProtectedString name="Source"><![CDATA[--[[

rounded_frame is a special kind of frame with UICorner controls for every
single corner.

]]

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local container = require(script.Parent.container)

local create = vide.create
local read = vide.read

type can<T> = T | () -> T
type rounded_frame = {
	name: can<string>?,
	size: can<UDim2>?,
	position: can<UDim2>?,
	anchor_point: can<Vector2>?,

	topleft: can<UDim>?,
	topright: can<UDim>?,
	bottomleft: can<UDim>?,
	bottomright: can<UDim>?,

	color: can<Color3>?,

	layout: vide.vFrame?,

	[number]: any,
}

local function rounded_frame(props: rounded_frame)
	local topleft = props.topleft or UDim.new()
	local topright = props.topright or UDim.new()
	local bottomleft = props.bottomleft or UDim.new()
	local bottomright = props.bottomright or UDim.new()

	local function corner(name: string, position: UDim2, anchor_point: Vector2, udim: can<UDim>)
		return create "Frame" {
			Name = name,
			AutoLocalize = false,

			Size = function()
				return UDim2.new(read(udim), read(udim))
			end,
			Position = position,
			AnchorPoint = anchor_point,

			BackgroundTransparency = 1,
			ClipsDescendants = true,

			create "Frame" {
				Name = "TopLeft",
				AutoLocalize = false,
	
				Size = UDim2.fromScale(2, 2),
				Position = UDim2.fromScale(-anchor_point.X, -anchor_point.Y),
	
				BackgroundColor3 = props.color,
				ClipsDescendants = true,
	
				create "UICorner" {
					CornerRadius = udim
				}
			}

		}
	end

	return create "Frame" {

		Name = props.name or "RoundedFrame",
		Size = props.size,
		Position = props.position,
		AnchorPoint = props.anchor_point,

		BackgroundColor3 = props.color,

		BackgroundTransparency = 1,

		create "Folder" {
			Name = "Corner",
			
			corner("TopLeft", UDim2.fromScale(0, 0), Vector2.new(0, 0), topleft),
			corner("TopRight", UDim2.fromScale(1, 0), Vector2.new(1, 0), topright),
			corner("BottomLeft", UDim2.fromScale(0, 1), Vector2.new(0, 1), bottomleft),
			corner("BottomRight", UDim2.fromScale(1, 1), Vector2.new(1, 1), bottomright),
		
			create "Frame" {
				AutoLocalize = false,
				
				Name = "FrameLeft",

				Size = function()
					return UDim2.new(
						0.5,
						0,
						1 - read(topleft).Scale - read(bottomleft).Scale,
						- (read(topleft).Offset + read(bottomleft).Offset)
					)
				end,
				Position = function()
					return UDim2.new(
						0, 0,
						0.5 + read(topleft).Scale / 2 - read(bottomleft).Scale / 2,
						0 + read(topleft).Offset / 2 - read(bottomleft).Offset / 2
					)
				end,
				AnchorPoint = Vector2.new(0, 0.5),

				BackgroundColor3 = props.color,
			},

			create "Frame" {
				
				Name = "FrameRight",
				AutoLocalize = false,

				Size = function()
					return UDim2.new(
						0.5,
						0,
						1 - read(topright).Scale - read(bottomright).Scale,
						- (read(topright).Offset + read(bottomright).Offset)
					)
				end,
				Position = function()
					return UDim2.new(
						1, 0,
						0.5 + read(topright).Scale / 2 - read(bottomright).Scale / 2,
						0 + read(topright).Offset / 2 - read(bottomright).Offset / 2
					)
				end,
				AnchorPoint = Vector2.new(1, 0.5),

				BackgroundColor3 = props.color,
			},

			create "Frame" {
				
				Name = "FrameTop",
				AutoLocalize = false,

				Size = function()
					return UDim2.new(
						1 - read(topleft).Scale - read(topright).Scale,
						- (read(topleft).Offset + read(topright).Offset),
						0.5,
						0
					)
				end,
				Position = function()
					return UDim2.new(
						0.5 + read(topleft).Scale / 2 - read(topright).Scale / 2,
						0 + read(topleft).Offset / 2 - read(topright).Offset / 2,
						0, 0
					)
				end,
				AnchorPoint = Vector2.new(0.5, 0),

				BackgroundColor3 = props.color,
			},

			create "Frame" {
				
				Name = "FrameBottom",
				AutoLocalize = false,

				Size = function()
					return UDim2.new(
						1 - read(bottomleft).Scale - read(bottomright).Scale,
						- (read(bottomleft).Offset + read(bottomright).Offset),
						0.5,
						0
					)
				end,
				Position = function()
					return UDim2.new(
						0.5 + read(bottomleft).Scale / 2 - read(bottomright).Scale / 2,
						0 + read(bottomleft).Offset / 2 - read(bottomright).Offset / 2,
						1, 0
					)
				end,
				AnchorPoint = Vector2.new(0.5, 1),

				BackgroundColor3 = props.color,
			},
		},

		container {
			unpack(props)
		},

		props.layout

	}
	
end

return rounded_frame]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="121">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">row</string>
										<string name="ScriptGuid">{FCA7D3DC-B70C-45A6-9882-224ED95179EC}</string>
										<ProtectedString name="Source"><![CDATA[--[[

Creates a container for a list of elements.

]]

local vide = require(script.Parent.Parent.Parent.Parent.vide)
local container = require(script.Parent.container)

local create = vide.create
local read = vide.read

type can<T> = (() -> T) | T
type layout = {
	
	justifycontent: can<Enum.UIFlexAlignment>?,
	alignitems: can<Enum.ItemLineAlignment>?,
	spacing: can<number | UDim>?,
	wraps: can<boolean>?,

	[number]: Instance
}

local function layout(props: layout)
	return container {

		Size = UDim2.fromScale(1, 0),
		AutomaticSize = Enum.AutomaticSize.Y,
		
		create "UIListLayout" {
			Padding = function()
				local spacing: number | UDim? = read(props.spacing)
				
				return if typeof(spacing) == "number" then
					UDim.new(0, spacing)
				elseif typeof(spacing) == "UDim" then
					spacing
				elseif typeof(spacing) == "nil" then
					UDim.new(0, 8)
				else
					error("incorrect spacing type")
			end,
			FillDirection = Enum.FillDirection.Horizontal,

			HorizontalFlex = props.justifycontent,
			ItemLineAlignment = props.alignitems,
			Wraps = props.wraps
			
		},

		unpack(props)
	}
	
end

return layout]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="122">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">shadow</string>
										<string name="ScriptGuid">{C42BCA0D-7369-456D-8B23-B6C5BD4209B3}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)

local create = vide.create

type can<T> = T | () -> T
type props = {
	zindex: can<number>?,
	transparency: can<number>?
}

return function(props: props)
	
	return create "UIStroke" {

		Thickness = 2,
		Color = Color3.new(0, 0, 0),
		Transparency = 0.8

	}
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="123">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">virtualscroller</string>
										<string name="ScriptGuid">{8B23F735-811D-43C9-B56F-7ECA3F7297C4}</string>
										<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.Parent.vide)
local scroll_frame = require(script.Parent.Parent.display.scroll_frame)
local container = require(script.Parent.container)

local create = vide.create
local source = vide.source
local values = vide.values
local changed = vide.changed
local effect = vide.effect
local untrack = vide.untrack
local batch = vide.batch

type can<T> = T | () -> T
type props = {

	size: can<UDim2>?,
	position: can<UDim2>?,
	anchorpoint: can<UDim2>?,

	--- streams in items. when index is -1, should expect to be unused
	item: (index: () -> number) -> Instance,
	--- streams in separators. when index is -1, should expect to be unused
	separator: ((index: () -> number) -> Instance)?,

	item_size: number,
	separator_size: number?,

	max_items: (() -> number)?,

	[number]: any

}

return function(props: props)

	local items = source({} :: {vide.Source<number>})

	local absolute_size = source(Vector2.zero)
	local canvas_position = source(Vector2.zero)

	local item_size = props.item_size
	local separator_size = props.separator_size or 0

	local item = props.item
	local separator = props.separator

	local OVERFLOW = 4

	effect(function()
		local absolute_size = absolute_size()
		local canvas_position = canvas_position()

		local child_size = item_size + separator_size
		local total_required = math.ceil(absolute_size.Y / child_size) + OVERFLOW
		local sources = untrack(items)

		local min_index = math.floor(canvas_position.Y / child_size)
		local max_index = math.ceil((canvas_position.Y + absolute_size.Y) / child_size)

		local max_items = math.huge
		if props.max_items then
			max_items = props.max_items()
		end

		batch(function()
			untrack(function()
				-- mark any sources out of range as unused
				local unused = {}

				for i, s in sources do
					local index = s()

					if
						index >= math.max(min_index, 1)
						and index <= math.min(max_index, max_items)
					then continue end
					unused[i] = true
					s(-1)
				end

				-- add sources necessary
				if #sources < total_required then
					for i = #sources + 1, total_required do
						sources[i] = source(-1)
						unused[i] = true
					end
					items(sources)
				end

				-- update indexes of any sources that went unused
				local did_not_render = {}

				for i = math.max(min_index, 1), math.min(max_index, max_items) do
					did_not_render[i] = true
				end
				

				for _, s in sources do
					did_not_render[s()] = nil
				end

				for index in unused do
					local s = sources[index]
					local key = next(did_not_render)
					if not key then break end
					s(key)
					did_not_render[key] = nil
					unused[index] = nil
				end

				-- remove unnecessary sources
				if #sources > total_required then
					for i = #sources, 1, -1 do
						if unused[i] then
							table.remove(sources, i)
						end
						unused[i] = nil
						if #sources < total_required then break end
					end
					items(sources)
				end

			end)
		end)

	end)

	return scroll_frame {

		unpack(props),

		Size = props.size or UDim2.fromScale(1, 1),
		Position = props.position,
		AnchorPoint = props.anchorpoint,

		BackgroundTransparency = 1,

		CanvasSize = function()
			if props.max_items then
				return UDim2.fromOffset(0, props.max_items() * (item_size + separator_size))
			else
				local absolute_size = absolute_size()
				local canvas_position = canvas_position()
				local child_size = item_size + separator_size
				local max_index = math.ceil((canvas_position.Y + absolute_size.Y) / child_size) + OVERFLOW
				return UDim2.fromOffset(0, max_index * child_size)
			end
		end,

		values(items, function(index)
			return create "Frame" {
				Name = index,
				AutoLocalize = false,

				Position = function()
					if index() == -1 then UDim2.fromOffset(0, -1000) end
					return UDim2.fromOffset(
						0,
						(item_size + separator_size) * (index() - 1)
					)
				end,
				Size = UDim2.new(1, 0, 0, item_size + separator_size),

				BackgroundTransparency = 1,

				container {
					Name = "Item",
					
					item(index),
				},

				if separator then
					container {
						Name = "Separator",

						separator(index)
					}
				else nil,
				
			}
		end),

		changed("AbsoluteSize", absolute_size),
		changed("CanvasPosition", canvas_position),


	}

end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040e</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Folder" referent="124">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">libraries</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000040f</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="125">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">apcaw3</string>
									<string name="ScriptGuid">{4F588C68-8D15-4423-842C-13D8DA40A2FB}</string>
									<ProtectedString name="Source"><![CDATA[local SA98G = {
	mainTRC = 2.4,
	mainTRCencode = 1 / 2.4,
	sRco = 0.2126729,
	sGco = 0.7151522,
	sBco = 0.0721750,
	normBG = 0.56,
	normTXT = 0.57,
	revTXT = 0.62,
	revBG = 0.65,
	blkThrs = 0.022,
	blkClmp = 1.414,
	scaleBoW = 1.14,
	scaleWoB = 1.14,
	loBoWoffset = 0.027,
	loWoBoffset = 0.027,
	deltaYmin = 0.0005,
	loClip = 0.1,
	mFactor = 1.94685544331710,
	mFactInv = 1 / 1.94685544331710,
	mOffsetIn = 0.03873938165714010,
	mExpAdj = 0.2833433964208690,
	mExp = 0.2833433964208690 / 1.414,
	mOffsetOut = 0.3128657958707580,
}

local function isNaN(n)
	return n ~= n
end

local function reverseAPCA(contrast, knownY, knownType, returnAs)
	if contrast == nil then
		contrast = 0
	end
	if knownY == nil then
		knownY = 1.0
	end
	if knownType == nil then
		knownType = "bg"
	end
	if returnAs == nil then
		returnAs = "hex"
	end
	if math.abs(contrast) < 9 then
		return false
	end
	local unknownY = knownY
	local knownExp
	local unknownExp
	--///   APCA   0.0.98G - 4g - W3 Compatible Constants   ////////////////////
	local scale = if contrast > 0 then SA98G.scaleBoW else SA98G.scaleWoB
	local offset = if contrast > 0 then SA98G.loBoWoffset else -SA98G.loWoBoffset
	contrast = (assert(tonumber(contrast)) * 0.01 + offset) / scale
	-- Soft clamps Y if it is near black.
	knownY = if (knownY > SA98G.blkThrs) then knownY else knownY + math.pow(SA98G.blkThrs - knownY, SA98G.blkClmp)
	-- set the known and unknown exponents
	if knownType == "bg" or knownType == "background" then
		knownExp = if contrast > 0 then SA98G.normBG else SA98G.revBG
		unknownExp = if contrast > 0 then SA98G.normTXT else SA98G.revTXT
		unknownY = math.pow(math.pow(knownY, knownExp) - contrast, 1 / unknownExp)
		if isNaN(unknownY) then
			return false
		end
	elseif knownType == "txt" or knownType == "text" then
		knownExp = if contrast > 0 then SA98G.normTXT else SA98G.revTXT
		unknownExp = if contrast > 0 then SA98G.normBG else SA98G.revBG
		unknownY = math.pow(contrast + math.pow(knownY, knownExp), 1 / unknownExp)
		if isNaN(unknownY) then
			return false
		end
	else
		return false
	end
	--return contrast +'----'+unknownY;
	if unknownY > 1.06 or unknownY < 0 then
		return false
	end
	-- if (unknownY < 0) { return false } // return false on underflow
	--unknownY = math.max(unknownY,0.0);
	--  unclamp
	unknownY = if (unknownY > SA98G.blkThrs) then unknownY else (math.pow(((unknownY + SA98G.mOffsetIn) * SA98G.mFactor), SA98G.mExp) * SA98G.mFactInv) - SA98G.mOffsetOut
	--    unknownY - 0.22 * math.pow(unknownY*0.5, 1/blkClmp);
	unknownY = math.max(math.min(unknownY, 1.0), 0.0)
	if returnAs == "color" then
		local colorB = math.round(math.pow(unknownY, SA98G.mainTRCencode) * 255)
		local retUse = if (knownType == "bg") then "txtColor" else "bgColor"
		return { colorB, colorB, colorB, 1, retUse }
	elseif returnAs == "Y" or returnAs == "y" then
		return math.max(0.0, unknownY)
	else
		return false
	end
end

local function sRGBtoY(sRGBcolor: Color3)
	local r = sRGBcolor.R
	local g = sRGBcolor.G
	local b = sRGBcolor.B

	local function simpleExp(chan)
		return math.pow(chan, SA98G.mainTRC)
	end

	return SA98G.sRco * simpleExp(r) + SA98G.sGco * simpleExp(g) + SA98G.sBco * simpleExp(b)
end

local function displayP3toY(rgb: Color3)
	local mainTRC = 2.4
	local sRco, sGco, sBco = 0.2289829594805780, 0.6917492625852380, 0.0792677779341829

	local function simpleExp(chan)
		return math.pow(chan, mainTRC)
	end

	return sRco * simpleExp(rgb.R) + sGco * simpleExp(rgb.G) + sBco * simpleExp(rgb.B)
end

local function adobeRGBtoY(rgb: Color3)
	local mainTRC = 2.35

	local sRco = 0.2973550227113810
	local sGco = 0.6273727497145280
	local sBco = 0.0752722275740913

	local function simpleExp(chan)
		return math.pow(chan / 255.0, mainTRC)
	end

	return sRco * simpleExp(rgb.R) + sGco * simpleExp(rgb.G) + sBco * simpleExp(rgb.B)
end


local function APCAcontrast(txtY, bgY, places)
	places = places or -1

	local icp = { 0, 1.1 }

	if math.min(txtY, bgY) < icp[1] or math.max(txtY, bgY) > icp[2] then
		return 0
	end

	local SAPC = 0
	local outputContrast = 0
	local polCat = "BoW"

	txtY = (txtY > SA98G.blkThrs) and txtY or txtY + math.pow(SA98G.blkThrs - txtY, SA98G.blkClmp)
	bgY = (bgY > SA98G.blkThrs) and bgY or bgY + math.pow(SA98G.blkThrs - bgY, SA98G.blkClmp)

	if math.abs(bgY - txtY) < SA98G.deltaYmin then
		return 0
	end

	if bgY > txtY then -- black text on white
		SAPC = (math.pow(bgY, SA98G.normBG) - math.pow(txtY, SA98G.normTXT)) * SA98G.scaleBoW

		outputContrast = (SAPC < SA98G.loClip) and 0.0 or SAPC - SA98G.loBoWoffset
	else
		-- should always return negative
		polCat = "WoB" -- white on black

		SAPC = (math.pow(bgY, SA98G.revBG) - math.pow(txtY, SA98G.revTXT)) * SA98G.scaleWoB

		outputContrast = (SAPC > -SA98G.loClip) and 0.0 or SAPC + SA98G.loWoBoffset
	end

	if places < 0 then
		return outputContrast * 100.0
	elseif places == 0 then
		return math.round(math.abs(outputContrast) * 100.0) --+ "<sub>" + polCat + "</sub>" -- why is there html
	elseif places // 1 == places then
		return (outputContrast * 100.0) * places // 1 / places
	else
		return 0.0
	end
end

local function alphaBlend(rgbFG: Color3, aFG: number, rgbBG: Color3, round: boolean?)
	round = if round == nil then true else round
	aFG = aFG or 1
	local compBlend = 1 - aFG
	local rgbOut = {0, 0, 0}

	rgbOut[1] = rgbBG.R * compBlend + rgbFG.R * aFG
	if round then rgbOut[1] = math.min(math.round(rgbOut[1]), 255) end
	rgbOut[2] = rgbBG.G * compBlend + rgbFG.G * aFG
	if round then rgbOut[2] = math.min(math.round(rgbOut[2]), 255) end
	rgbOut[3] = rgbBG.B * compBlend + rgbFG.B * aFG
	if round then rgbOut[3] = math.min(math.round(rgbOut[3]), 255) end

	return Color3.new(rgbOut[1], rgbOut[2], rgbOut[3])

end

local function calcAPCA(textcolor: Color3, bgColor: Color3, textalpha: number?, places: number?, round: boolean?)
	places = -1

	--todo: alpha blending
	if textalpha then textcolor = alphaBlend(textcolor, textalpha, bgColor, round) end

	return APCAcontrast(sRGBtoY(textcolor), sRGBtoY(bgColor), places)
end

local function fontLookupAPCA(contrast, places: number?)
	places = places or 2

	-- Font size interpolations. Here the chart was re-ordered to put
	-- the main contrast levels each on one line, instead of font size per line.
	-- First column is LC value, then each following column is font size by weight

	-- G G G G G G  Public Beta 0.1.7 (G) • MAY 28 2022

	-- Lc values under 70 should have Lc 15 ADDED if used for body text
	-- All font sizes are in px and reference font is Barlow

	-- 999: prohibited - too low contrast
	-- 777: NON TEXT at this minimum weight stroke
	-- 666 - this is for spot text, not fluent-Things like copyright or placeholder.
	-- 5xx - minimum font at this weight for content, 5xx % 500 for font-size
	-- 4xx - minimum font at this weight for any purpose], 4xx % 400 for font-size

	-- MAIN FONT SIZE LOOKUP

	---- ASCENDING SORTED  Public Beta 0.1.7 (G) • MAY 28 2022  ////

	---- Lc 45 * 0.2 = 9 which is the index for the row for Lc 45

	--  MAIN FONT LOOKUP May 28 2022 EXPANDED
	-- Sorted by Lc Value
	-- First row is standard weights 100-900
	-- First column is font size in px
	-- All other values are the Lc contrast 
	-- 999 = too low. 777 = non-text and spot text only

	local fontMatrixAscend = {
		{'Lc',100,200,300,400,500,600,700,800,900},
		{0,999,999,999,999,999,999,999,999,999},
		{10,999,999,999,999,999,999,999,999,999},
		{15,777,777,777,777,777,777,777,777,777},
		{20,777,777,777,777,777,777,777,777,777},
		{25,777,777,777,120,120,108,96,96,96},
		{30,777,777,120,108,108,96,72,72,72},
		{35,777,120,108,96,72,60,48,48,48},
		{40,120,108,96,60,48,42,32,32,32},
		{45,108,96,72,42,32,28,24,24,24},
		{50,96,72,60,32,28,24,21,21,21},
		{55,80,60,48,28,24,21,18,18,18},
		{60,72,48,42,24,21,18,16,16,18},
		{65,68,46,32,21.75,19,17,15,16,18},
		{70,64,44,28,19.5,18,16,14.5,16,18},
		{75,60,42,24,18,16,15,14,16,18},
		{80,56,38.25,23,17.25,15.81,14.81,14,16,18},
		{85,52,34.5,22,16.5,15.625,14.625,14,16,18},
		{90,48,32,21,16,15.5,14.5,14,16,18},
		{95,45,28,19.5,15.5,15,14,13.5,16,18},
		{100,42,26.5,18.5,15,14.5,13.5,13,16,18},
		{105,39,25,18,14.5,14,13,12,16,18},
		{110,36,24,18,14,13,12,11,16,18},
		{115,34.5,22.5,17.25,12.5,11.875,11.25,10.625,14.5,16.5},
		{120,33,21,16.5,11,10.75,10.5,10.25,13,15},
		{125,32,20,16,10,10,10,10,12,14},
	}

	local fontDeltaAscend = {
		{'∆Lc',100,200,300,400,500,600,700,800,900},
		{0,0,0,0,0,0,0,0,0,0},
		{10,0,0,0,0,0,0,0,0,0},
		{15,0,0,0,0,0,0,0,0,0},
		{20,0,0,0,0,0,0,0,0,0},
		{25,0,0,0,12,12,12,24,24,24},
		{30,0,0,12,12,36,36,24,24,24},
		{35,0,12,12,36,24,18,16,16,16},
		{40,12,12,24,18,16,14,8,8,8},
		{45,12,24,12,10,4,4,3,3,3},
		{50,16,12,12,4,4,3,3,3,3},
		{55,8,12,6,4,3,3,2,2,0},
		{60,4,2,10,2.25,2,1,1,0,0},
		{65,4,2,4,2.25,1,1,0.5,0,0},
		{70,4,2,4,1.5,2,1,0.5,0,0},
		{75,4,3.75,1,0.75,0.188,0.188,0,0,0},
		{80,4,3.75,1,0.75,0.188,0.188,0,0,0},
		{85,4,2.5,1,0.5,0.125,0.125,0,0,0},
		{90,3,4,1.5,0.5,0.5,0.5,0.5,0,0},
		{95,3,1.5,1,0.5,0.5,0.5,0.5,0,0},
		{100,3,1.5,0.5,0.5,0.5,0.5,1,0,0},
		{105,3,1,0,0.5,1,1,1,0,0},
		{110,1.5,1.5,0.75,1.5,1.125,0.75,0.375,1.5,1.5},
		{115,1.5,1.5,0.75,1.5,1.125,0.75,0.375,1.5,1.5},
		{120,1,1,0.5,1,0.75,0.5,0.25,1,1},
		{125,0,0,0,0,0,0,0,0,0},
	};

	local weightArray = {0, 100, 200, 300, 400, 500, 600, 700, 800, 900}
	local weightArrayLen = #weightArray

	local returnArray = {tostring(contrast * places // 1 / places), 0, 0, 0, 0, 0, 0, 0, 0, 0}
	local returnArrayLen = #returnArray

	local contrastArrayAscend = {'lc',0,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120,125,}
	local contrastArrayLenAsc = #contrastArrayAscend

	-- Lc 45 * 0.2 = 9 and 9 is the index for the row for lc 45

	local tempFont = 777
	local contrast = math.abs(contrast)
	local factor = 0.2
	local index = contrast == 0 and 1 or bit32.bor(contrast * factor, 0)
	local w = 0
	local scoreAdj = (contrast - fontMatrixAscend[index + 1][w + 1]) * factor

	w += 1

	while w < weightArrayLen do
		w += 1
		tempFont = fontMatrixAscend[index+1][w+1]

		if tempFont > 400 then
			returnArray[w + 1] = tempFont
		elseif contrast < 14.5 then
			returnArray[w + 1] = 999
		elseif contrast < 29.5 then
			returnArray[w + 1] = 777
		else
			--- interpolation of font size

			if tempFont > 24 then
				returnArray[w + 1] = math.round(tempFont - (fontDeltaAscend[index + 1][w + 1] * scoreAdj))
			else
				returnArray[w + 1] = tempFont - ((2 * fontDeltaAscend[index + 1][w + 1] * scoreAdj // 1) * 0.5)
		
			end
		end
	end

	return returnArray

end

return {

	APCAcontrast = APCAcontrast,
	reverseAPCA = reverseAPCA,
	calcAPCA = calcAPCA,
	fontLookupAPCA = fontLookupAPCA,

	sRGBtoY = sRGBtoY,
	displayP3toY = displayP3toY,
	adobeRGBtoY = adobeRGBtoY,
	alphaBlend = alphaBlend

}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000410</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="126">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cascade</string>
									<string name="ScriptGuid">{E9A58A81-D4F2-44E0-BB2E-29A15441FE2E}</string>
									<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.vide)

local action = vide.action
local cleanup = vide.cleanup

--[[

Cascades are applied and passed through an instance.
Use a context if you need to pass this through function scopes.

This is primarily useful for passing down theme information.

]]
local function cascade<T>(default_value: T)

	local self = {}
	local senders: {[Instance]: T} = {}

	local function get_cascaded_value(from: Instance?): T
		while from ~= nil do
			local sender = senders[from]
			if sender ~= nil then
				return sender
			else
				from = from.Parent
			end
		end
		return default_value
	end

	function self.send(value: T)
		return action(function(instance)
			cleanup(function()
				senders[instance] = nil
			end)
			
			senders[instance] = value
		end)
	end

	function self.receive(output_to: (T) -> any)
		return action(function(instance)
			local function recalculate()
				output_to(
					get_cascaded_value(instance.Parent)
				)
			end

			recalculate()

			cleanup(instance.AncestryChanged:Connect(recalculate))
			cleanup(function()
				output_to(default_value)
			end)
		end)
	end

	return self

end

return cascade]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000411</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="127">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">context</string>
									<string name="ScriptGuid">{312F34FA-2F34-4415-9937-68BDE6DE2712}</string>
									<ProtectedString name="Source"><![CDATA[--[[

Implements a form of dependency injection to save the need from passing data
as props through intermediate components.

]]

export type Context<T = nil> = {
	default_value: T,
	_values: {[thread]: T},

	provide: <U>(Context<T>, callback: () -> U) -> (new: T) -> U,
	consume: (Context<T>) -> T
}

type ContextNoDefault<T> = {
	_values: {[thread]: T},

	provide: <U>(Context<T>, callback: () -> U) -> (new: T) -> U,
	consume: (Context<T>) -> T?
}

local function provide<T, U>(context: Context<T>, callback: () -> U)
	return function(new: T): U
		local thread = coroutine.running()
		local old = context._values[thread]

		context._values[thread] = new

		local ok, value = pcall(callback)

		context._values[thread] = old
		
		if not ok then
			error(`provided callback errored with "{value}"`, 2)
		end

		return value
	end :: (new: T) -> U
end

local function consume<T>(context: Context<T>): T
	local thread = coroutine.running()
	return context._values[thread] or context.default_value
end

local function create_context<T>(default_value: T?): Context<T>
	return {
		default_value = default_value,
		_values = {},

		provide = provide :: any,
		consume = consume
	}
end

return create_context :: (<T>(default_value: T) -> Context<T>) & (<T>() -> ContextNoDefault<T>)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000412</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="128">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">delay</string>
									<string name="ScriptGuid">{80F782C7-7AC7-47BE-886B-5FE3F08DE930}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local vide = require(script.Parent.Parent.Parent.vide)

local source = vide.source
local effect = vide.effect
local cleanup = vide.cleanup

return function<T>(delay: number, input: () -> T): () -> T
	local output = source(input())

	effect(function()
			local v = input()
			local t = delay

			cleanup(RunService.Heartbeat:Connect(function(dt)
				t -= dt
				if t > 0 then return end
				output(v)
			
			end))

	end)

	return output
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000413</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="129">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">oklab</string>
									<string name="ScriptGuid">{FB6A8F6E-8132-4692-BDBF-DB6B44AAFE86}</string>
									<ProtectedString name="Source"><![CDATA[--!nolint
--!strict
-- Oklab C implementation provided by Björn Ottosson:
--     https://bottosson.github.io/posts/gamutclipping/
-- Luau port and Roblox/Lch extensions by Elttob:
--     https://elttob.uk/
-- Licensed under MIT

local TAU = 2 * math.pi

local function cbrt(x: number)
	return math.sign(x) * math.abs(x) ^ (1/3)
end

local Oklab = {}

function Oklab.linear_srgb_to_oklab(
	c: Vector3
): Vector3
	local l = 0.4122214708 * c.X + 0.5363325363 * c.Y + 0.0514459929 * c.Z
	local m = 0.2119034982 * c.X + 0.6806995451 * c.Y + 0.1073969566 * c.Z
	local s = 0.0883024619 * c.X + 0.2817188376 * c.Y + 0.6299787005 * c.Z
	
	local l_ = cbrt(l)
	local m_ = cbrt(m)
	local s_ = cbrt(s)

	return Vector3.new(
		0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
		1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
		0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_
	)
end

function Oklab.oklab_to_linear_srgb(
	c: Vector3
): Vector3
	local l_ = c.X + 0.3963377774 * c.Y + 0.2158037573 * c.Z
	local m_ = c.X - 0.1055613458 * c.Y - 0.0638541728 * c.Z
	local s_ = c.X - 0.0894841775 * c.Y - 1.2914855480 * c.Z

	local l = l_ * l_ * l_
	local m = m_ * m_ * m_
	local s = s_ * s_ * s_

	return Vector3.new(
		4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
		-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
		-0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s
	)
end

-- Finds the maximum saturation possible for a given hue that fits in sRGB.
-- Saturation here is defined as S = C/L
-- a and b must be normalised so a^2 + b^2 == 1
function Oklab.compute_max_saturation(
	a: number,
	b: number
): number
	-- Max saturation will be when one of r, g or b goes below zero.

	-- Select different coefficients depending on which component goes below zero first
	local k0, k1, k2, k3, k4, wl, wm, ws

	if -1.88170328 * a - 0.80936493 * b > 1 then
		-- Red component
		k0, k1, k2, k3, k4 = 1.19086277, 1.76576728, 0.59662641, 0.75515197, 0.56771245
		wl, wm, ws = 4.0767416621, -3.3077115913, 0.2309699292
	elseif 1.81444104 * a - 1.19445276 * b > 1 then
		-- Green component
		k0, k1, k2, k3, k4 = 0.73956515, -0.45954404, 0.08285427, 0.12541070, 0.14503204
		wl, wm, ws = -1.2684380046, 2.6097574011, -0.3413193965
	else
		-- Blue component
		k0, k1, k2, k3, k4 = 1.35733652, -0.00915799, -1.15130210, -0.50559606, 0.00692167
		wl, wm, ws = -0.0041960863, -0.7034186147, 1.7076147010
	end

	-- Approximate max saturation using a polynomial
	local S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b

	-- Do one step Halley's method to get closer
	-- this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
	-- this should be sufficient for most applications, otherwise do two/three steps
	local k_l =  0.3963377774 * a + 0.2158037573 * b
	local k_m = -0.1055613458 * a - 0.0638541728 * b
	local k_s = -0.0894841775 * a - 1.2914855480 * b

	do
		local l_ = 1 + S * k_l
		local m_ = 1 + S * k_m
		local s_ = 1 + S * k_s

		local l = l_ * l_ * l_
		local m = m_ * m_ * m_
		local s = s_ * s_ * s_

		local l_dS = 3 * k_l * l_ * l_
		local m_dS = 3 * k_m * m_ * m_
		local s_dS = 3 * k_s * s_ * s_

		local l_dS2 = 6 * k_l * k_l * l_
		local m_dS2 = 6 * k_m * k_m * m_
		local s_dS2 = 6 * k_s * k_s * s_

		local f  = wl * l     + wm * m     + ws * s
		local f1 = wl * l_dS  + wm * m_dS  + ws * s_dS
		local f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2

		S = S - f * f1 / (f1*f1 - 0.5 * f * f2)
	end

	return S
end

-- finds L_cusp and C_cusp for a given hue
-- a and b must be normalised so a^2 + b^2 == 1
function Oklab.find_cusp(
	a: number,
	b: number
): (number, number)
	-- First, find the maximum saturation (saturation S = C/L)
	local S_cusp = Oklab.compute_max_saturation(a, b)

	-- Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
	local rgb_at_max = Oklab.oklab_to_linear_srgb(Vector3.new(1, S_cusp * a, S_cusp * b))
	local L_cusp = cbrt(1 / math.max(rgb_at_max.X, rgb_at_max.Y, rgb_at_max.Z))
	local C_cusp = L_cusp * S_cusp

	return L_cusp, C_cusp
end

-- Finds intersection of the line defined by 
-- L = L0 * (1 - t) + t * L1;
-- C = t * C1;
-- a and b must be normalized so a^2 + b^2 == 1
function Oklab.find_gamut_intersection(
	a: number,
	b: number,
	L1: number,
	C1: number,
	L0: number
): number
	-- Find the cusp of the gamut triangle
	local L_cusp, C_cusp = Oklab.find_cusp(a, b)

	-- Find the intersection for upper and lower half seprately
	local t
	if ((L1 - L0) * C_cusp - (L_cusp - L0) * C1) <= 0 then
		-- Lower half
		t = C_cusp * L0 / (C1 * L_cusp + C_cusp * (L0 - L1))
	else
		-- Upper half
		-- First intersect with triangle
		t = C_cusp * (L0 - 1) / (C1 * (L_cusp - 1) + C_cusp * (L0 - L1))

		-- Then one step Halley's method
		do
			local dL = L1 - L0
			local dC = C1

			local k_l =  0.3963377774 * a + 0.2158037573 * b
			local k_m = -0.1055613458 * a - 0.0638541728 * b
			local k_s = -0.0894841775 * a - 1.2914855480 * b

			local l_dt = dL + dC * k_l
			local m_dt = dL + dC * k_m
			local s_dt = dL + dC * k_s

			-- If higher accuracy is required, 2 or 3 iterations of the following block can be used:
			do
				local L = L0 * (1 - t) + t * L1
				local C = t * C1

				local l_ = L + C * k_l
				local m_ = L + C * k_m
				local s_ = L + C * k_s

				local l = l_ * l_ * l_
				local m = m_ * m_ * m_
				local s = s_ * s_ * s_

				local ldt = 3 * l_dt * l_ * l_
				local mdt = 3 * m_dt * m_ * m_
				local sdt = 3 * s_dt * s_ * s_

				local ldt2 = 6 * l_dt * l_dt * l_
				local mdt2 = 6 * m_dt * m_dt * m_
				local sdt2 = 6 * s_dt * s_dt * s_

				local r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1
				local r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt
				local r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2

				local u_r = r1 / (r1 * r1 - 0.5 * r * r2)
				local t_r = -r * u_r

				local g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1
				local g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt
				local g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2

				local u_g = g1 / (g1 * g1 - 0.5 * g * g2)
				local t_g = -g * u_g

				local b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s - 1
				local b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.7076147010 * sdt
				local b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.7076147010 * sdt2

				local u_b = b1 / (b1 * b1 - 0.5 * b * b2)
				local t_b = -b * u_b

				t_r = if u_r >= 0 then t_r else math.huge
				t_g = if u_g >= 0 then t_g else math.huge
				t_b = if u_b >= 0 then t_b else math.huge

				t += math.min(t_r, t_g, t_b)
			end
		end
	end

	return t
end

function Oklab.gamut_clip_preserve_chroma(
	rgb: Vector3
): Vector3
	if rgb.X <= 1 and rgb.Y <= 1 and rgb.Z <= 1 and rgb.X >= 0 and rgb.Y >= 0 and rgb.Z >= 0 then
		return rgb
	end

	local lab = Oklab.linear_srgb_to_oklab(rgb)

	local L = lab.X
	local eps = 0.00001
	local C = math.max(eps, math.sqrt(lab.Y * lab.Y + lab.Z * lab.Z))
	local a_ = if C == 0 then 0 else lab.Y / C
	local b_ = if C == 0 then 0 else lab.Z / C
	local L0 = math.clamp(L, 0, 1)

	local t = Oklab.find_gamut_intersection(a_, b_, L, C, L0)
	local L_clipped = L0 * (1 - t) + t * L
	local C_clipped = t * C

	return Oklab.oklab_to_linear_srgb(Vector3.new(L_clipped, C_clipped * a_, C_clipped * b_))
end

function Oklab.gamut_clip_project_to_0_5(
	rgb: Vector3
): Vector3
	if rgb.X <= 1 and rgb.Y <= 1 and rgb.Z <= 1 and rgb.X >= 0 and rgb.Y >= 0 and rgb.Z >= 0 then
		return rgb
	end

	local lab = Oklab.linear_srgb_to_oklab(rgb)

	local L = lab.X
	local eps = 0.00001
	local C = math.max(eps, math.sqrt(lab.Y * lab.Y + lab.Z * lab.Z))
	local a_ = lab.Y / C
	local b_ = lab.Z / C

	local L0 = 0.5

	local t = Oklab.find_gamut_intersection(a_, b_, L, C, L0)
	local L_clipped = L0 * (1 - t) + t * L
	local C_clipped = t * C

	return Oklab.oklab_to_linear_srgb(Vector3.new(L_clipped, C_clipped * a_, C_clipped * b_))
end

function Oklab.gamut_clip_project_to_L_cusp(
	rgb: Vector3
): Vector3
	if rgb.X <= 1 and rgb.Y <= 1 and rgb.Z <= 1 and rgb.X >= 0 and rgb.Y >= 0 and rgb.Z >= 0 then
		return rgb
	end

	local lab = Oklab.linear_srgb_to_oklab(rgb)

	local L = lab.X
	local eps = 0.00001
	local C = math.max(eps, math.sqrt(lab.Y * lab.Y + lab.Z * lab.Z))
	local a_ = lab.Y / C
	local b_ = lab.Z / C

	-- The cusp is computed here and in find_gamut_intersection, an optimised solution would only compute it once.
	local L_cusp, C_cusp = Oklab.find_cusp(a_, b_)

	local L0 = L_cusp

	local t = Oklab.find_gamut_intersection(a_, b_, L, C, L0)

	local L_clipped = L0 * (1 - t) + t * L
	local C_clipped = t * C

	return Oklab.oklab_to_linear_srgb(Vector3.new(L_clipped, C_clipped * a_, C_clipped * b_))
end

function Oklab.gamut_clip_adaptive_L0_0_5(
	rgb: Vector3,
	alpha: number?
): Vector3
	if rgb.X <= 1 and rgb.Y <= 1 and rgb.Z <= 1 and rgb.X >= 0 and rgb.Y >= 0 and rgb.Z >= 0 then
		return rgb
	end
	local alpha = alpha or 0.05

	local lab = Oklab.linear_srgb_to_oklab(rgb)

	local L = lab.X
	local eps = 0.00001
	local C = math.max(eps, math.sqrt(lab.Y * lab.Y + lab.Z * lab.Z))
	local a_ = lab.Y / C
	local b_ = lab.Z / C

	local Ld = L - 0.5
	local e1 = 0.5 + math.abs(Ld) + alpha * C
	local L0 = 0.5 * (1 + math.sign(Ld) * (e1 - math.sqrt(e1*e1 - 2 * math.abs(Ld))))

	local t = Oklab.find_gamut_intersection(a_, b_, L, C, L0)
	local L_clipped = L0 * (1 - t) + t * L
	local C_clipped = t * C

	return Oklab.oklab_to_linear_srgb(Vector3.new(L_clipped, C_clipped * a_, C_clipped * b_))
end

function Oklab.gamut_clip_adaptive_L0_L_cusp(
	rgb: Vector3,
	alpha: number?
): Vector3
	if rgb.X < 1 and rgb.Y < 1 and rgb.Z < 1 and rgb.X > 0 and rgb.Y > 0 and rgb.Z > 0 then
		return rgb
	end
	local alpha = alpha or 0.05

	local lab = Oklab.linear_srgb_to_oklab(rgb)

	local L = lab.X
	local eps = 0.00001
	local C = math.max(eps, math.sqrt(lab.Y * lab.Y + lab.Z * lab.Z))
	local a_ = lab.Y / C
	local b_ = lab.Z / C

	-- The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
	local L_cusp, C_cusp = Oklab.find_cusp(a_, b_)

	local Ld = L - L_cusp
	local k = 2 * (if Ld > 0 then 1 - L_cusp else L_cusp)

	local e1 = 0.5*k + math.abs(Ld) + alpha * C/k
	local L0 = L_cusp + 0.5 * (math.sign(Ld) * (e1 - math.sqrt(e1 * e1 - 2 * k * math.abs(Ld))))

	local t = Oklab.find_gamut_intersection(a_, b_, L, C, L0)
	local L_clipped = L0 * (1 - t) + t * L
	local C_clipped = t * C

	return Oklab.oklab_to_linear_srgb(Vector3.new(L_clipped, C_clipped * a_, C_clipped * b_))
end

--[[
	ROBLOX EXTENSIONS
]]

Oklab.default_gamut_clip = Oklab.gamut_clip_adaptive_L0_0_5

local function component_to_gamma(x: number): number
	if x >= 0.0031308 then
		return (1.055) * x^(1.0/2.4) - 0.055
	else
		return 12.92 * x
	end
end

local function component_to_linear(x: number): number
	if x >= 0.04045 then
		return ((x + 0.055)/(1 + 0.055))^2.4
	else 
		return x / 12.92
	end
end

function Oklab.color3_to_linear_srgb(
	c: Color3
): Vector3
	return Vector3.new(
		component_to_linear(c.R),
		component_to_linear(c.G),
		component_to_linear(c.B)
	)
end

function Oklab.linear_srgb_to_color3(
	c: Vector3,
	use_default_gamut_clip: boolean?
): Color3
	if use_default_gamut_clip == false then
		return Color3.new(
			component_to_gamma(c.X),
			component_to_gamma(c.Y),
			component_to_gamma(c.Z)
		)
	else
		local c = Oklab.default_gamut_clip(c)
		return Color3.new(
			math.clamp(component_to_gamma(c.X), 0, 1),
			math.clamp(component_to_gamma(c.Y), 0, 1),
			math.clamp(component_to_gamma(c.Z), 0, 1)
		)
	end


end

--[[
	LCH EXTENSIONS
]]

function Oklab.oklch_to_oklab(oklch: Vector3): Vector3
	return Vector3.new(
		oklch.X,
		oklch.Y * math.cos(oklch.Z * TAU),
		oklch.Y * math.sin(oklch.Z * TAU)
	)
end

function Oklab.oklab_to_oklch(oklab: Vector3): Vector3
	return Vector3.new(
		oklab.X,
		math.sqrt(oklab.Y^2 + oklab.Z^2),
		(math.atan2(oklab.Z, oklab.Y) / TAU) % 1
	)
end

return Oklab]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000414</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="130">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">store</string>
									<string name="ScriptGuid">{519AE59E-5A92-429B-9ECC-29682878BD3B}</string>
									<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
-- videx/store.luau
--------------------------------------------------------------------------------

local vide = require(script.Parent.Parent.Parent.vide)
local source = vide.source

local NULL = newproxy()

local Store = {}

--[=[
Creates a new store object that receives some initial state and then returns
a table with the same structure, but all keys of the given table will be reactive.

When accessed inside a reactive scope, the reactive scope will update whenever
the key that is accessed is changed.

@param initial_state `T : {[string]: any}` The initial state the store will start in.
@param mutations `() -> {[string]: (T, ...any) -> ...any}?` A list of functions that mutate the data.
@return `T & U` A resulting table that 
]=]
function Store.new<T, U>(
    initial_state: T & {},
    mutations: (T & U) -> U
): T & U
    local sources = {}

    for i, v in initial_state :: any do
        local src = source(v ~= NULL and v or nil)
        sources[i] = src
    end

    local internal_proxy = {}

    setmetatable(internal_proxy, {
        __index = function(_, index)
            return sources[index]()
        end,
        __newindex = function(_, index, value)
            sources[index](value)
        end
    })

    local external_proxy = {}

    setmetatable(external_proxy :: any, {
        __index = function(_, index)
            local src = sources[index]
            if src == nil then error(`invalid index {index}`, 2) end
            return src()
        end,

        __newindex = function(_, index, value)
            sources[index](value)
        end
    })

    for i, v in next, mutations(internal_proxy :: any) :: any do
        if rawget(external_proxy, i) then
            error(`duplicate field "{i}"`, 2)
        end
        rawset(external_proxy, i, v)
    end

    return external_proxy :: T & U & {}
end


--[=[
Creates a new store object that receives some initial state and then returns
a table with the same structure, but all keys of the given table will be reactive.

When accessed inside a reactive scope, the reactive scope will update whenever
the key that is accessed is changed.

@param initial_state `T : {[string]: any}` The initial state the store will start in.
@param mutations `() -> {[string]: (T, ...any) -> ...any}?` A list of functions that mutate the data.
@return `T & U` A resulting table that 
]=]
function Store.new_deep<T, U>(
    initial_state: T & {},
    mutations: (T & U) -> U
): T & U
    
    local main = Store.new(initial_state, mutations)

    for key, value in initial_state :: any do
        if type(value) == "table" then
            main[key] = Store.new_deep(value, mutations :: any)
        end
    end

    return main

end

--- A special symbol used to indicate that a value should be nil within a Store.
Store.null = NULL :: nil

return Store]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000415</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="131">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">util</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000416</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="132">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">anim</string>
									<string name="ScriptGuid">{C14F3D18-189E-4EA0-B1C5-4D1E99A15899}</string>
									<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.vide)
local reduced_motion = require(script.Parent.reduced_motion)

local source = vide.source
local spring = vide.spring
local untrack = vide.untrack

type Animation = "move" | ""

return function<T>(s: () -> T)
	local type = typeof(untrack(s))
	local is_movement = false
	local reduce = reduced_motion:consume()

	if type == "UDim" or type == "UDim2" or type == "Vector2" then
		is_movement = true
	end

	local spr = spring(s, 0.1)
	return function()
		if is_movement and reduce then
			return s()
		else
			return spr()
		end
	end
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000417</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="133">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">constants</string>
									<string name="ScriptGuid">{DEBEC450-A4F2-47AB-A4A0-6FF17C79687A}</string>
									<ProtectedString name="Source"></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000418</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="134">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">consume</string>
									<string name="ScriptGuid">{6936117A-7687-4157-A50E-71B2F341E56F}</string>
									<ProtectedString name="Source"><![CDATA[--[[

Consumes a property from a table and removes it

]]

return function(t: {}, key: string)
    local v = t[key]; t[key] = nil
    return v
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000419</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="135">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">contrast</string>
									<string name="ScriptGuid">{F4E33494-E8E1-422E-AF03-40ADAA9BCE6D}</string>
									<ProtectedString name="Source"><![CDATA[local vide = require(script.Parent.Parent.Parent.vide)
local apcaw3 = require(script.Parent.Parent.libraries.apcaw3)
local oklch = require(script.Parent.oklch)

local derive = vide.derive
local read = vide.read

local function min_contrast(options: {
	size: can<number>,
	weight: can<number | Font>?,
	body: can<boolean>?
})

	local size = options.size
	local weight = options.weight or 400
	local needs_body = options.body
	local NO = math.huge

	if not size and not weight then return 0 end

	local MIN_CONTRAST = {
		[12] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[14] = {NO, NO, NO, 100, 100, 90, 75, NO, NO},
		[15] = {NO, NO, NO, 100, 90, 75, 70, NO, NO},
		[16] = {NO, NO, NO, 90, 75, 70, 60, 60, NO},
		[18] = {NO, NO, 100, 75, 70, 60, 55, 55, 55},
		[21] = {NO, NO, 90, 70, 60, 55, 50, 50, 50},
		[24] = {NO, NO, 75, 60, 55, 50, 45, 45, 55},
		[28] = {NO, 100, 70, 55, 50, 45, 43, 43, 43},
		[32] = {NO, 90, 65, 50, 45, 43, 40, 40, 40},
		[36] = {NO, 75, 60, 45, 43, 40, 38, 38, 38},
		[42] = {100, 70, 55, 43, 40, 38, 35, 35, 35},
		[48] = {90, 60, 50, 40, 38, 35, 33, 33, 33},
		[60] = {75, 55, 45, 37, 35, 33, 30 ,30, 30},
		[72] = {60, 50, 40, 35, 33, 30, 30, 30, 30},
		[96] = {50, 45, 35, 33, 30, 30, 30, 30, 30}
	}
	local MIN_CONTRAST_BODY = {
		[12] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[14] = {NO, NO, NO, 100, 100, 90, 75, NO, NO},
		[15] = {NO, NO, NO, 100, 90, 90, 85, NO, NO},
		[16] = {NO, NO, NO, 90, 75, 85, 75, NO, NO},
		[18] = {NO, NO, 100, 75, 85, 75, 70, NO, NO},
		[21] = {NO, NO, 90, 70, 75, 70, 65, NO, NO},
		[24] = {NO, NO, 75, 75, 70, 65, 60, NO, NO},
		[28] = {NO, NO, 85, 70, 65, 60, 58, NO, NO},
		[32] = {NO, NO, 80, 65, 60, 58, 55, NO, NO},
		[36] = {NO, NO, 75, 60, 58, 55, 52, NO, NO},
		[42] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[48] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[60] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[72] = {NO, NO, NO, NO, NO, NO, NO, NO, NO},
		[96] = {NO, NO, NO, NO, NO, NO, NO, NO, NO}
	}

	return derive(function()
		local matrix_to_use =
			if read(needs_body) then MIN_CONTRAST_BODY
			else MIN_CONTRAST
		
		local row_to_use = matrix_to_use[read(size)]
		if not row_to_use then return NO end
		local weight: Font | number = read(weight)
		local font_weight: number = 400

		if type(weight) == "number" then
			font_weight = weight
		elseif typeof(weight) == "Font" then
			font_weight = weight.Weight.Value
		end

		return row_to_use[font_weight // 100] or NO
	end)

end

--- collapses a state to a single value
type recursive<T> = (() -> recursive<T>) | T
type can<T> = (() -> T) | T
local function unwrap<T>(source: recursive<T>): T

	local value: recursive<T>

	while type(source) == "function" do
		source = source()
	end

	value = source

	return value :: T
end

local function get_appropriate_color(options: {
	background: recursive<Color3>?,
	foreground: recursive<{{number}}>,
	elevation: recursive<number>?,
	min_contrast: recursive<number>,
}): () -> Color3

	return function()
		local min_contrast = unwrap(options.min_contrast)
		local elevation = unwrap(options.elevation) or 0
		local bg = unwrap(options.background)
		
		if bg == nil then
			local foreground = unwrap(options.foreground)[1]
			local l, c, h = unpack(foreground, 1, 3)
			local l_a, l_c, l_h = unpack(foreground, 4, 6)
			local color = oklch(
				l + elevation * (l_a or 0),
				c + elevation * (l_c or 0),
				h + elevation * (l_h or 0)
			)
			return color
		end

		if min_contrast == math.huge then
			warn("min contrast is invalid")
		end

		local max = -1
		local furthest_away = Color3.new()
		
		for _, foreground: {number} in unwrap(options.foreground) do
			local l, c, h = unpack(foreground, 1, 3)
			local l_a, l_c, l_h = unpack(foreground, 4, 6)
			local color = oklch(
				l + elevation * (l_a or 0),
				c + elevation * (l_c or 0),
				h + elevation * (l_h or 0)
			)
			local contrast = math.abs(apcaw3.calcAPCA(color, bg, nil, 1, true))

			if max < contrast then
				max = contrast
				furthest_away = color
			end

			if contrast >= min_contrast then
				return color
			end
		end

		-- warn(`unable to find a color, max contrast found is {max // 1} but needs at least {min_contrast}`)
		return furthest_away
	end

end

return {

	min_contrast = min_contrast,
	get_appropriate_color = get_appropriate_color

}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="136">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">oklch</string>
									<string name="ScriptGuid">{DFE78560-4B1E-4629-BE8E-330769D09D24}</string>
									<ProtectedString name="Source"><![CDATA[local oklab = require(script.Parent.Parent.libraries.oklab)

--[=[

Converts OkLCh into a Color3.

lightness is a value between 0-1, determining how "light" a color is.

chroma is a value between 0 to infinity, determining how colorful something is.
current displays can only display a chroma up to around 0.34, and srgb can only
go up to 0.245.

hue is a hue circle from 0-360


]=]
local function oklch(lightness: number, chroma: number, hue: number)
	return oklab.linear_srgb_to_color3(
		oklab.oklab_to_linear_srgb(
			oklab.oklch_to_oklab(
				Vector3.new(math.clamp(lightness, 0, 1), chroma, hue)
			)
		),
		true
	)
end

return oklch]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="137">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">reduced_motion</string>
									<string name="ScriptGuid">{F2157871-266D-4033-8859-DCA3CF9DCD7B}</string>
									<ProtectedString name="Source"><![CDATA[local context = require(script.Parent.Parent.libraries.context)

return context(false)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="138">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">theme</string>
									<string name="ScriptGuid">{ACBA87EA-C261-4506-AABB-F21198D3CD61}</string>
									<ProtectedString name="Source"><![CDATA[--[[

simple theme engine for computing colors
]]

local vide = require(script.Parent.Parent.Parent.vide)
local apcaw3 = require(script.Parent.Parent.libraries.apcaw3)
local contrast = require(script.Parent.contrast)
local oklch_to_color3 = require(script.Parent.oklch)

local source = vide.source

local function oklch(t: {number})
    return table.freeze {
        l = t[1],
        c = t[2],
        h = t[3],
        color = oklch_to_color3(unpack(t))
    }
end

local background = source(oklch {0.2012, 0.01, 0.6}) -- note: for light mode change this to 0.9012 from 0.3012
local accent = source(oklch {0.52, 0.21, 0.71}) -- note: for light mode change this to 0.62 from 0.52

local BODY_SIZE = 18
local HEADER_SIZE = 24
local FONT = Font.fromName(
    "BuilderSans",
    Enum.FontWeight.Regular,
    Enum.FontStyle.Normal
)
local FONT_CODE = Font.new(
    "rbxassetid://16658246179",
    Enum.FontWeight.Regular,
    Enum.FontStyle.Normal
)

--- determines when it should be decreasing instead of increasing
local function should_flip(lightness: number)
    return lightness > 0.65
end

local CONTRAST_LOW = 0.4
local CONTRAST_HIGH = 0.7

type Depth = number
type ColorPalette = {

    bg: {[Depth]: Color3},
    fg_on_bg_high: {[Depth]: Color3},
    fg_on_bg_low: {[Depth]: Color3},
    fg_on_accent: {[Depth]: Color3},
    accent: Color3,

}

local function compute_bg(depth: Depth)
    local function get()
        local bg = background()
        -- print(bg.l + 0.01 * depth, depth, bg.c, bg.h)

        return oklch {
            math.clamp(bg.l + 0.02 * depth, 0, 1),
            bg.c,
            bg.h
        }
        -- if should_flip(bg.l) then
        --     return oklch {
        --         math.clamp(bg.l - 0.02 * depth, 0, 1),
        --         bg.c,
        --         bg.h
        --     }
        -- else
        --     return oklch {
        --         math.clamp(bg.l + 0.02 * depth, 0, 1),
        --         bg.c,
        --         bg.h
        --     }
        -- end
    end

    return function(raw: boolean)
        local c = if raw then get() else get().color
        return c
    end :: ((true) -> typeof(oklch {}) ) & (false?) -> Color3
end

local function compute_acc(depth: Depth)
    local function get()
        local bg = accent()
        -- print(bg.l + 0.01 * depth, depth, bg.c, bg.h)
        return oklch {
            math.clamp(bg.l + 0.02 * depth, 0, 1),
            bg.c,
            bg.h
        }
        -- if should_flip(bg.l) then
        --     return oklch {
        --         math.clamp(bg.l - 0.02 * depth, 0, 1),
        --         bg.c,
        --         bg.h
        --     }
        -- else
        --     return oklch {
        --         math.clamp(bg.l + 0.02 * depth, 0, 1),
        --         bg.c,
        --         bg.h
        --     }
        -- end
    end

    return function(raw: boolean)
        local c = if raw then get() else get().color
        return c
    end :: ((true) -> typeof(oklch {}) ) & (false?) -> Color3
end

local function compute_fg_on_bg_high(depth: Depth)
    local get_bg = compute_bg(depth)
    return function()
        local bg = get_bg(true)
        
        if should_flip(bg.l) then
            return oklch {
                bg.l - CONTRAST_HIGH,
                bg.c, bg.h
            }.color
        else
            return oklch {
                bg.l + CONTRAST_HIGH,
                bg.c, bg.h
            }.color
        end
    end
end

local function compute_fg_on_bg_low(depth: Depth)
    local get_bg = compute_bg(depth)
    return function()
        local bg = get_bg(true)
        
        if should_flip(bg.l) then
            return oklch {
                bg.l - CONTRAST_LOW,
                bg.c, bg.h
            }.color
        else
            return oklch {
                bg.l + CONTRAST_LOW,
                bg.c, bg.h
            }.color
        end
    end
end

local function compute_fg_on_acc_low(depth: Depth)
    local get_bg = compute_acc(depth)
    return function()
        local bg = get_bg(true)
        
        if should_flip(bg.l) then
            return oklch {
                bg.l - CONTRAST_LOW,
                bg.c, bg.h
            }.color
        else
            return oklch {
                bg.l + CONTRAST_LOW,
                bg.c, bg.h
            }.color
        end
    end
end

local function compute_fg_on_acc_high(depth: Depth)
    local get_bg = compute_acc(depth)
    return function()
        local bg = get_bg(true)
        
        if should_flip(bg.l) then
            return oklch {
                bg.l - CONTRAST_HIGH,
                bg.c, bg.h
            }.color
        else
            return oklch {
                bg.l + CONTRAST_HIGH,
                bg.c, bg.h
            }.color
        end
    end
end

type Theme = {

    bg: {[Depth]: number},
    accent: Color3,

    fg_on_bg_high: {[Depth]: Color3},
    fg_on_bg_low: {[Depth]: Color3},
    fg_on_accent_high: {[Depth]: Color3},
    fg_on_accent_low: {[Depth]: Color3},
    
    body: number,
    header: number,
    font: Font,
    font_code: Font,

}

local function compute_theme()

    local MAX_DEPTH = 20
    local MIN_DEPTH = -20

    local theme = {
        bg = {},
        acc = {},

        fg_on_bg_high = {},
        fg_on_bg_low = {},
        fg_on_acc_high = {},
        fg_on_acc_low = {},
        
        body = BODY_SIZE,
        header = HEADER_SIZE,
        font = FONT,
        code = FONT_CODE
    }

    for i = MIN_DEPTH, MAX_DEPTH do
        theme.bg[i] = compute_bg(i)
        theme.acc[i] = compute_acc(i)
        theme.fg_on_acc_high[i] = compute_fg_on_acc_high(i)
        theme.fg_on_acc_low[i] = compute_fg_on_acc_low(i)
        theme.fg_on_bg_high[i] = compute_fg_on_bg_high(i)
        theme.fg_on_bg_low[i] = compute_fg_on_bg_low(i)
    end

    return theme

end

return setmetatable({

    settings = {
        background = background,
        accent = accent
    },

}, {
    __index = compute_theme()
})]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041d</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="139">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">vide</string>
							<string name="ScriptGuid">{E3E48851-915F-4CCC-B482-7C4B879AF9D2}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["centau_vide@0.3.1"]["vide"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041e</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="140">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">centau_vide@0.3.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000041f</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="141">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">vide</string>
							<string name="ScriptGuid">{7DCDCDCF-22B1-41EA-B8D6-58D38AFA7735}</string>
							<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
-- vide.luau
--------------------------------------------------------------------------------

local version = { major = 0, minor = 3, patch = 1 }

if not game then script = require "test/relative-string" end

local root = require(script.root)
local mount = require(script.mount)
local create = require(script.create)
local apply = require(script.apply)
local source = require(script.source)
local effect = require(script.effect)
local derive = require(script.derive)
local cleanup = require(script.cleanup)
local untrack = require(script.untrack)
local read = require(script.read)
local batch = require(script.batch)
local context = require(script.context)
local switch = require(script.switch)
local show = require(script.show)
local indexes, values = require(script.maps)()
local spring, update_springs = require(script.spring)()
local action = require(script.action)()
local changed = require(script.changed)
local throw = require(script.throw)
local flags = require(script.flags)

export type Source<T> = source.Source<T>
export type source<T> = Source<T>
export type Context<T> = context.Context<T>
export type context<T> = Context<T>

local function step(dt: number)
    if game then
        debug.profilebegin("VIDE STEP")
        debug.profilebegin("VIDE SPRING")
    end

    update_springs(dt)

    if game then
        debug.profileend()
        debug.profileend()
    end
end

local stepped = game and game:GetService("RunService").Heartbeat:Connect(function(dt: number)
    task.defer(step, dt)
end)

local vide = {
    version = version,

    -- core
    root = root,
    mount = mount,
    create = create,
    source = source,
    effect = effect,
    derive = derive,
    switch = switch,
    show = show,
    indexes = indexes,
    values = values,

    -- util
    cleanup = cleanup,
    untrack = untrack,
    read = read,
    batch = batch,
    context = context,

    -- animations
    spring = spring,

    -- actions
    action = action,
    changed = changed,

    -- flags
    strict = (nil :: any) :: boolean,

    -- temporary
    apply = function(instance: Instance)
        return function(props: { [any]: any })
            apply(instance, props)
            return instance
        end
    end,

    -- runtime
    step = function(dt: number)
        if stepped then
            stepped:Disconnect()
            stepped = nil
        end
        step(dt)
    end
}

setmetatable(vide :: any, {
    __index = function(_, index: unknown): ()
        if index == "strict" then
            return flags.strict
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end,

    __newindex = function(_, index: unknown, value: unknown)
        if index == "strict" then
            flags.strict = value :: boolean
        else
            throw(`{tostring(index)} is not a valid member of vide`)
        end
    end
})

return vide
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000420</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="142">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">action</string>
								<string name="ScriptGuid">{4A222AE1-9A1D-4F49-AD78-F842508833D4}</string>
								<ProtectedString name="Source"><![CDATA[type Action = {
    priority: number,
    callback: (Instance) -> ()
}

local ActionMT = table.freeze {}

local function is_action(v: any)
    return getmetatable(v) == ActionMT
end

local function action(callback: (Instance) -> (), priority: number?): Action
    local a = {
        priority = priority or 1,
        callback = callback
    }

    setmetatable(a :: any, ActionMT)

    return table.freeze(a)
end

return function()
    return action, is_action
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000421</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="143">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">apply</string>
								<string name="ScriptGuid">{36C5F1AF-84D3-47DF-A35F-C09A6DD62AB9}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never
local Vector2 = game and Vector2 or require "test/mock".Vector2 :: never
local UDim2 = game and UDim2 or require "test/mock".UDim2 :: never

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local bind = require(script.Parent.bind)
local _, is_action = require(script.Parent.action)()
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>

type Array<V> = { V }
type ArrayOrV<V> = {ArrayOrV<V>} | V
type Map<K, V> = { [K]: V }

local free_caches: {
    -- event listeners to connect after properties are set
    events: Map<
        string, -- event name
        () -> () -- listener
    >,

    -- actions to run after events are connected
    actions: Map<
        number, -- priority
        Array<(Instance) -> ()> -- action callbacks
    >,

    -- cache to detect duplicate property setting at same nesting depth
    nested_debug: Map<
        number, -- depth
        Map<string, true> -- set of property names
    >,

    -- use stack instead of recursive function to process nesting layers one at time
    -- deeper-nested properties take precedence over shallower-nested ones
    -- each nested layer occupies two indexes: 1. table ref 2. nested depth
    -- e.g. { t1 = { t3 = {} }, t2 = {} } -> { t1, 1, t2, 1, t3, 2 }
    nested_stack: { {} | number }
}?

local function borrow_caches(): typeof(assert(free_caches))
    if free_caches then
        local caches = free_caches :: typeof(assert(free_caches))
        free_caches = nil
        return caches
    else
        return {
            events = {},
            actions = setmetatable({} :: any, { -- lazy init
                __index = function(self, i) self[i] = {}; return self[i] end
            }),
            nested_debug = setmetatable({} :: any, {
                __index = function(self, i: number) self[i] = {}; return self[i] end
            }),
            nested_stack = {}
        }
    end
end

local function return_caches(caches: typeof(free_caches) )
    free_caches = caches
end

-- map of datatype names to class default constructor for aggregate init
local aggregates = {}
for name, class in {
    CFrame = CFrame,
    Color3 = Color3,
    UDim = UDim,
    UDim2 = UDim2,
    Vector2 = Vector2,
    Vector3 = Vector3,
    Rect = Rect
} :: Map<string, { [string]: any }> do
    aggregates[name] = class.new
end

-- applies table of nested properties to an instance using full vide semantics
local function apply<T>(instance: T & Instance, properties: { [unknown]: unknown }): T
    if not properties then
        throw("attempt to call a constructor returned by create() with no properties")
    end

    local strict = flags.strict

    -- queue parent assignment if any for last
    local parent: unknown = properties.Parent 

    local caches = borrow_caches()
    local events = caches.events
    local actions = caches.actions
    local nested_debug = caches.nested_debug
    local nested_stack = caches.nested_stack

    -- process all properties
    local depth = 1
    repeat
        for property, value in properties do
            if property == "Parent" then continue end

            if type(property) == "string" then
                if strict then -- check for duplicate prop assignment at nesting depth
                    if nested_debug[depth][property] then
                        throw(`duplicate property {property} at depth {depth}`)
                    end
                    nested_debug[depth][property] = true
                end

                if type(value) == "table" then -- attempt aggregate init
                    local ctor = aggregates[typeof((instance :: any)[property])]
                    if ctor == nil then
                        throw(`cannot aggregate type {typeof(value)} for property {property}`)
                    end
                    (instance :: any)[property] = ctor(unpack(value :: {}))
                elseif type(value) == "function" then 
                    if typeof((instance :: any)[property]) == "RBXScriptSignal" then
                        events[property] = value  :: () -> () -- add event to buffer
                    else
                        bind.property(instance, property, value :: () -> ()) -- bind property
                    end
                else
                    (instance :: any)[property] = value -- set property
                end    
            elseif type(property) == "number" then
                if type(value) == "function" then
                    bind.children(instance, value :: () -> ArrayOrV<Instance>) -- bind children
                elseif type(value) == "table" then
                    if is_action(value) then
                        table.insert(actions[(value :: any).priority], (value :: any).callback :: () -> ()) -- add action to buffer
                    else
                        table.insert(nested_stack, value :: {})
                        table.insert(nested_stack, depth + 1) -- push table to stack for later processing
                    end
                else
                    (value :: Instance).Parent = instance -- parent child
                end
            end
        end

        depth = table.remove(nested_stack) :: number
        properties = table.remove(nested_stack) :: {}

    until not properties

    for event, listener in next, events do
        (instance :: any)[event]:Connect(listener)   
    end

    for _, queued in next, actions do
        for _, callback in next, queued do
            callback(instance)
        end
    end

    -- finally set parent if any
    if parent then
        if type(parent) == "function" then
            bind.parent(instance, parent :: () -> Instance)
        else
            instance.Parent = parent :: Instance
        end
    end

    -- clear caches
    table.clear(events)
    for _, queued in next, actions do table.clear(queued) end
    if strict then table.clear(nested_debug) end
    table.clear(nested_stack)

    return_caches(caches)

    return instance
end

return apply
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000422</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="144">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">batch</string>
								<string name="ScriptGuid">{0721FFF3-1197-499D-A587-3A55F2C175F4}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local flags = require(script.Parent.flags)
local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)

local function batch(setter: () -> ())
    local already_batching = flags.batch
    local from

    if not already_batching then
        flags.batch = true
        from = graph.get_update_queue_length()
    end

    local ok, err: string? = pcall(setter)

    if not already_batching then
        flags.batch = false
        graph.flush_update_queue(from)
    end

    if not ok then throw(`error occured while batching updates: {err}`) end
end

return batch
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000423</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="145">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">bind</string>
								<string name="ScriptGuid">{3D193257-681F-49B4-AC22-DDCEBC4193E1}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

function create_implicit_effect<T>(updater: (T) -> T, binding: T)
    evaluate_node(create_node(assert_stable_scope(), updater, binding))
end

type PropertyBinding = {
    instance: Instance,
    property: string,
    source: () -> unknown
}

local function update_property_effect(p: PropertyBinding)
    (p.instance :: any)[p.property] = p.source()
    return p
end

type ParentBinding = {
    instance: Instance,
    parent: () -> Instance
}

local function update_parent_effect(p: ParentBinding)
    p.instance.Parent = p.parent()
    return p
end

type ChildrenBinding = {
    instance: Instance,
    cur_children_set: { [Instance]: true },
    new_children_set: { [Instance]: true },
    children: () -> Instance | { Instance }
}

type ArrayOrV<V> = V | { V }
local function update_children_effect(p: ChildrenBinding)
    local cur_children_set: { [Instance]: true } = p.cur_children_set -- cache of all children parented before update
    local new_child_set: { [Instance]: true } = p.new_children_set -- cache of all children parented after update

    local new_children = p.children() -- all (and only) children that should be parented after this update
    
    if type(new_children) ~= "table" then
        new_children = { new_children }
    end

    local function process_child(child: ArrayOrV<Instance>)
        if type(child) == "table" then
            for _, child in next, child do
                process_child(child)
            end
        else
            if new_child_set[child] then return end -- stops redundant reparenting

            new_child_set[child] = true -- record child set from this update
            if not cur_children_set[child] then
                child.Parent = p.instance -- if child wasn't already parented then parent it
            else 
                cur_children_set[child] = nil -- remove child from cache if it was already in cache
            end
        end
    end

    process_child(new_children)

    for child in next, cur_children_set do
        child.Parent = nil -- unparent all children that weren't in the new children set
    end

    table.clear(cur_children_set) -- clear cache, preserve capacity
    p.cur_children_set, p.new_children_set = new_child_set, cur_children_set

    return p
end

return {
    property = function(instance, property, source)
        return create_implicit_effect(update_property_effect, {
            instance = instance,
            property = property,
            source = source
        })
    end,

    parent = function(instance, parent)
        return create_implicit_effect(update_parent_effect, {
            instance = instance,
            parent = parent
        })
    end,

    children = function(instance, children)
        return create_implicit_effect(update_children_effect, {
            instance = instance,
            cur_children_set = {},
            new_children_set = {},
            children = children
        })
    end
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000424</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="146">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">changed</string>
								<string name="ScriptGuid">{0959B8FF-9FD5-4B27-A551-B8F8CFCAC310}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local action = require(script.Parent.action)()
local cleanup = require(script.Parent.cleanup)

local function changed<T>(property: string, callback: (T) -> ())
    return action(function(instance)
        local con = instance:GetPropertyChangedSignal(property):Connect(function()
            callback((instance :: any)[property])
        end)

        cleanup(function()
            con:Disconnect()
        end)

        callback((instance :: any)[property])
    end)
end

return changed
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000425</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="147">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">cleanup</string>
								<string name="ScriptGuid">{EBBB7386-5E81-44F2-8290-F34A6F13E37A}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof :: never

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
local get_scope = graph.get_scope
local push_cleanup = graph.push_cleanup

local function helper(obj: any)
    return
        if typeof(obj) == "RBXScriptConnection" then function() obj:Disconnect() end
        elseif typeof(obj) == "Instance" then function() obj:Destroy() end
        elseif obj.destroy then function() obj:destroy() end
        elseif obj.disconnect then function() obj:disconnect() end
        elseif obj.Destroy then function() obj:Destroy() end
        elseif obj.Disconnect then function() obj:Disconnect() end
        else throw("cannot cleanup given object")
end

local function cleanup(value: unknown)
    local scope = get_scope()

    if not scope then
        throw "cannot cleanup outside a stable or reactive scope"
    end; assert(scope)

    if type(value) == "function" then
        push_cleanup(scope, value :: () -> ())
    else
        push_cleanup(scope, helper(value))
    end
end

type Destroyable = { destroy: (any) -> () } | { Destroy: (any) -> () }
type Disconnectable = { disconnect: (any) -> () } | { Disconnect: (any) -> () }

return cleanup ::
    ( (callback: () -> ()) -> () ) &
    ( (instance: Destroyable) -> () ) &
    ( (connection: Disconnectable) -> () ) &
    ( (instance: Instance) -> () ) &
    ( (connection: RBXScriptConnection) -> () )

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000426</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="148">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">context</string>
								<string name="ScriptGuid">{B4428B36-B9AF-4438-AECF-1F22CA382CD1}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local get_scope = graph.get_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local set_context = graph.set_context

export type Context<T> = (() -> T) & (<U>(T, () -> U) -> U)

local nil_symbol = newproxy()
local count = 0

local function context<T>(...: T): Context<T>
    count += 1
    local id = count

    local has_default = select("#", ...) > 0
    local default_value = ...

    return function<T>(...): any -- todo: fix type error
        local scope: Node<unknown>? | false = get_scope()

        if select("#", ...) == 0 then -- get
            while scope do
                local ctx = scope.context
    
                if not ctx then
                    scope = scope.owner
                    continue
                end

                local value = (ctx :: { unknown })[id]

                if value == nil then
                    scope = scope.owner
                    continue
                end
                
                return (if value ~= nil_symbol then value else nil) :: T
            end

            if has_default ~= nil then
                return default_value
            else
                throw("attempt to get context when no context is set and no default context is set")
            end
        else -- set
            if not scope then return throw("attempt to set context outside of a vide scope") end

            local value, component = ...
            
            local new_scope = create_node(scope, false, false)
            set_context(new_scope, id, if value == nil then nil_symbol else value)

            push_scope(new_scope)

            local function efn(err: string) return debug.traceback(err, 3) end
            local ok, result = xpcall(component, efn)

            pop_scope()

            if not ok then
                throw(`error while running context:\n\n{result}`)
            end

            return result
        end

        return nil :: any
    end
end

return context
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000427</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="149">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">create</string>
								<string name="ScriptGuid">{217013B7-998D-419B-AC1E-389224034052}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local typeof = game and typeof or require "test/mock".typeof:: never
local Instance = game and Instance or require "test/mock".Instance :: never

local throw = require(script.Parent.throw)
local defaults = require(script.Parent.defaults)
local apply = require(script.Parent.apply)

local ctor_cache = {} :: { [string]: () -> Instance }

setmetatable(ctor_cache :: any, {
    __index = function(self, class)
        local ok, instance: Instance = pcall(Instance.new, class :: any)
        if not ok then throw(`invalid class name, could not create instance of class { class }`) end

        local default: { [string]: unknown }? = defaults[class]
        if default then
            for i, v in next, default do
                (instance :: any)[i] = v
            end
        end

        local function ctor(properties: Props): Instance
            return apply(instance:Clone(), properties)    
        end  

        self[class] = ctor
        return ctor
    end
})

local function create_instance(class: string)
    return ctor_cache[class]
end

local function clone_instance(instance: Instance)
    return function(properties: Props): Instance
        local clone = instance:Clone()
        if not clone then throw "attempt to clone a non-archivable instance" end
        return apply(clone, properties)
    end
end

local function create(class_or_instance: string|Instance): (Props) -> Instance
    if type(class_or_instance) == "string" then
        return create_instance(class_or_instance)
    elseif typeof(class_or_instance) == "Instance" then
        return clone_instance(class_or_instance)
    else
        throw("bad argument #1, expected string or instance, got " .. typeof(class_or_instance))
        return nil :: never
    end
end

type Props = { [any]: any }
return (create :: any) :: 
( <T>(T & Instance) -> (Props) -> T ) &
( ("Folder") -> (Props) -> Folder ) &
( ("BillboardGui") -> (Props) -> BillboardGui ) &
( ("CanvasGroup") -> (Props) -> CanvasGroup ) &
( ("Frame") -> (Props) -> Frame ) &
( ("ImageButton") -> (Props) -> ImageButton ) &
( ("ImageLabel") -> (Props) -> ImageLabel ) &
( ("ScreenGui") -> (Props) -> ScreenGui ) &
( ("ScrollingFrame") -> (Props) -> ScrollingFrame ) &
( ("SurfaceGui") -> (Props) -> SurfaceGui ) &
( ("TextBox") -> (Props) -> TextBox ) &
( ("TextButton") -> (Props) -> TextButton ) &
( ("TextLabel") -> (Props) -> TextLabel ) &
( ("UIAspectRatioConstraint") -> (Props) -> UIAspectRatioConstraint ) &
( ("UICorner") -> (Props) -> UICorner ) &
( ("UIGradient") -> (Props) -> UIGradient ) &
( ("UIGridLayout") -> (Props) -> UIGridLayout ) &
( ("UIListLayout") -> (Props) -> UIListLayout ) &
( ("UIPadding") -> (Props) -> UIPadding ) &
( ("UIPageLayout") -> (Props) -> UIPageLayout ) &
( ("UIScale") -> (Props) -> UIScale ) &
( ("UISizeConstraint") -> (Props) -> UISizeConstraint ) &
( ("UIStroke") -> (Props) -> UIStroke ) &
( ("UITableLayout") -> (Props) -> UITableLayout ) &
( ("UITextSizeConstraint") -> (Props) -> UITextSizeConstraint ) &
( ("VideoFrame") -> (Props) -> VideoFrame ) &
( ("ViewportFrame") -> (Props) -> ViewportFrame ) &
( (string) -> (Props) -> Instance )
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000428</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="150">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">defaults</string>
								<string name="ScriptGuid">{AB95C66C-2FA6-40EA-A0EE-69F4D9D773AD}</string>
								<ProtectedString name="Source"><![CDATA[local Enum = game and Enum or require "test/mock".Enum :: never
local Color3 = game and Color3 or require "test/mock".Color3 :: never
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

return {
    Part = {
        Material = Enum.Material.SmoothPlastic,
        Size = Vector3.new(1, 1, 1),
        Anchored = true
    },

    BillboardGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    CanvasGroup = nil,

    Frame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },

    ImageButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false
    },

    ImageLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
    },

    ScreenGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    },

    ScrollingFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ScrollBarImageColor3 = Color3.new(0, 0, 0)
    },
    
    SurfaceGui = {
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

        PixelsPerStud = 50,
        SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    },
    
    TextBox = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        ClearTextOnFocus = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },

    TextButton = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        AutoButtonColor = false,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    TextLabel = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0,
        Font = Enum.Font.SourceSans,
        Text = "",
        TextColor3 = Color3.new(0, 0, 0)
    },
    
    UIListLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
   
    UIGridLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UITableLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },

    UIPageLayout = {
        SortOrder = Enum.SortOrder.LayoutOrder
    },
    
    VideoFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    },
    
    ViewportFrame = {
        BackgroundColor3 = Color3.new(1, 1, 1),
        BorderColor3 = Color3.new(0, 0, 0),
        BorderSizePixel = 0
    }
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000429</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="151">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">derive</string>
								<string name="ScriptGuid">{6B152138-2266-4B6B-A629-29A53BE53C0F}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local push_child_to_scope = graph.push_child_to_scope
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function derive<T>(source: () -> T): () -> T
    local node = create_node(assert_stable_scope(), source, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return derive
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="152">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">effect</string>
								<string name="ScriptGuid">{5F73E94A-0077-4A91-B0CA-80B5C83B380A}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
local create_node = graph.create_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node

local function effect<T>(callback: (T) -> T, initial_value: T)
    local node = create_node(assert_stable_scope(), callback, initial_value)

    evaluate_node(node)
end

return effect :: (<T>(callback: (T) -> T, initial_value: T) -> ()) & ((callback: () -> ()) -> ())
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="153">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">flags</string>
								<string name="ScriptGuid">{725A6D30-B51C-4CB0-B336-44CE02394809}</string>
								<ProtectedString name="Source"><![CDATA[local function inline_test(): string
    return debug.info(1, "n")
end

local is_O2 = inline_test() ~= "inline_test"

return { strict = not is_O2, batch = false }
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="154">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">graph</string>
								<string name="ScriptGuid">{41106510-BD7D-4872-A235-9567F785BB40}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)

export type SourceNode<T> = {
    cache: T,
    [number]: Node<T>
}

export type Node<T> =  {
    cache: T,
    effect:  ((T) -> T) | false,
    cleanups: { () -> () } | false,

    context: { [number]: unknown } | false,

    owned: { Node<T> } | false,
    owner: Node<T> | false,

    parents: { SourceNode<T> },
    [number]: Node<T> -- children
}

local scopes = { n = 0 } :: { [number]: Node<any>, n: number } -- scopes stack

local function ycall<T, U>(fn: (T) -> U, arg: T): (boolean, string|U)
    local thread = coroutine.create(xpcall)
    local function efn(err: string) return debug.traceback(err, 3) end
    local resume_ok, run_ok, result = coroutine.resume(thread, fn, efn, arg)

    assert(resume_ok)
        
    if coroutine.status(thread) ~= "dead" then
        return false, debug.traceback(thread, "attempt to yield in reactive scope")
    end

    return run_ok, result
end

local function get_scope(): Node<unknown>?
    return scopes[scopes.n]
end

local function assert_stable_scope(): Node<unknown>
    local scope = get_scope()

    if not scope then
        local caller_name = debug.info(2, "n")
        return throw(`cannot use {caller_name}() outside a stable or reactive scope`)
    elseif scope.effect then
        throw("cannot create a new reactive scope inside another reactive scope")
    end

    return scope
end

local function push_child<T>(parent: SourceNode<any>, child: Node<any>)
    table.insert(parent, child)
    table.insert(child.parents, parent)
end

local function push_scope<T>(node: Node<T>)
    local n = scopes.n + 1
    scopes.n = n
    scopes[n] = node
end

local function pop_scope()
    local n = scopes.n
    scopes.n = n - 1
    scopes[n] = nil
end

local function push_cleanup<T>(node: Node<T>, cleanup: () -> ())
    if node.cleanups then
        table.insert(node.cleanups, cleanup)
    else
        node.cleanups = { cleanup }
    end
end

local function flush_cleanups<T>(node: Node<T>)
    if node.cleanups then
        for _, fn in next, node.cleanups do
            local ok, err: string? = pcall(fn)
            if not ok then throw(`cleanup error: {err}`) end
        end

        table.clear(node.cleanups)
    end
end

local function find_and_swap_pop<T>(t: { T }, v: T)
    local i = table.find(t, v) :: number
    local n = #t
    t[i] = t[n]
    t[n] = nil
end

local function unparent<T>(node: Node<T>)
    local parents = node.parents

    for i, parent in parents do
        find_and_swap_pop(parent, node)
        parents[i] = nil
    end
end

local function destroy<T>(node: Node<T>)
    flush_cleanups(node)
    unparent(node)
    
    if node.owner then
        find_and_swap_pop(node.owner.owned :: { Node<T> }, node)
        node.owner = false
    end

    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local function destroy_owned<T>(node: Node<T>)
    if node.owned then
        local owned = node.owned
        while owned[1] do destroy(owned[1]) end
    end
end

local update_queue = { n = 0 } :: { n: number, [number]: Node<any> }

local function evaluate_node<T>(node: Node<T>)
    if flags.strict then
        local initial_value = node.cache

        for i = 1, 2 do
            local cur_value = node.cache

            flush_cleanups(node)
            destroy_owned(node)
    
            push_scope(node)
            local ok, new_value = ycall(node.effect :: (T) -> T, cur_value)
            pop_scope()
            
            if not ok then
                table.clear(update_queue)
                update_queue.n = 0
                throw(`effect stacktrace:\n{new_value :: string}`)
            end

            node.cache = new_value :: T
        end

        return initial_value ~= node.cache
    else
        local cur_value = node.cache

        flush_cleanups(node)
        destroy_owned(node)

        push_scope(node)
        local ok, new_value = pcall(node.effect :: (T) -> T, node.cache)
        pop_scope()

        if not ok then
            table.clear(update_queue)
            update_queue.n = 0
            throw(`effect stacktrace:\n{new_value}\n`)
        end
    
        node.cache = new_value
        return cur_value ~= new_value
    end
end

local function queue_children_for_update<T>(node: SourceNode<T>)
    local i = update_queue.n
    while node[1] do
        i += 1
        update_queue[i] = node[1]
        unparent(node[1])
    end
    update_queue.n = i
end

local function get_update_queue_length()
    return update_queue.n
end

local function flush_update_queue(from: number)
    local i = from + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any
        i += 1
    end
    
    update_queue.n = from
end

local function update_descendants<T>(root: SourceNode<T>)
    local n0 = update_queue.n
    queue_children_for_update(root)

    if flags.batch then return end

    local i = n0 + 1
    while i <= update_queue.n do
        local node = update_queue[i]
        --assert(node.effect)

        -- check if node is still owned in case destroyed after queued
        if node.owner and evaluate_node(node) then
            queue_children_for_update(node)
        end

        update_queue[i] = false :: any -- false instead of nil to avoid sparse
        i += 1
    end

    update_queue.n = n0
end

local function push_child_to_scope<T>(node: SourceNode<T>)
    local scope = get_scope()
    if scope and scope.effect then -- do not track nodes with no effect
        push_child(node, scope)
    end
end

local function create_node<T>(owner: false | Node<any>, effect: false | (T) -> T, value: T): Node<T>
    local node: Node<T> = {
        cache = value,
        effect = effect,
        cleanups = false,

        context = false,

        owner = owner,
        owned = false,

        parents = {},
    }

    if owner then
        if owner.owned then
            table.insert(owner.owned, node)
        else
            owner.owned = { node }
        end
    end

    return node
end

local function create_source_node<T>(value: T): SourceNode<T>
    return { cache = value }
end

local function get_children<T>(node: Node<T>): { Node<unknown> }
    return { unpack(node) } :: { Node<any> }
end

local function set_context<T>(node: Node<T>, key: number, value: unknown)
    if node.context then
        node.context[key] = value
    else
        node.context = { [key] = value }
    end
end

return table.freeze {
    push_scope = push_scope,
    pop_scope = pop_scope,
    evaluate_node = evaluate_node,
    get_scope = get_scope,
    assert_stable_scope = assert_stable_scope,
    push_cleanup = push_cleanup,
    destroy = destroy,
    flush_cleanups = flush_cleanups,
    push_child_to_scope = push_child_to_scope,
    update_descendants = update_descendants,
    push_child = push_child,
    create_node = create_node,
    create_source_node = create_source_node,
    get_children = get_children,
    flush_update_queue = flush_update_queue,
    get_update_queue_length = get_update_queue_length,
    set_context = set_context,
    scopes = scopes
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="155">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">maps</string>
								<string name="ScriptGuid">{899BF15A-747F-4C52-8DEA-7E8738579091}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local flags = require(script.Parent.flags)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local evaluate_node = graph.evaluate_node
local destroy = graph.destroy

type Map<K, V> = { [K]: V }

local function check_primitives(t: {})
    if not flags.strict then return end

    for _, v in next, t do
        if type(v) == "table" or type(v) == "userdata" or type(v) == "function" then continue end
        throw("table source map cannot return primitives")
    end
end

local function indexes<K, VI, VO>(input: () -> Map<K, VI>, transform: (() -> VI, K) -> VO): () -> { VO }
    local owner = assert_stable_scope()
    local subowner = create_node(owner, false, false)

    local input_cache = {} :: Map<K, VI>
    local output_cache = {} :: Map<K, VO>
    local input_nodes = {} :: Map<K, SourceNode<VI>>
    local remove_queue = {} :: { K }
    local scopes = {} :: Map<K, Node<unknown>>

    local function update_children(data)
        -- queue removed values
        for i in next, input_cache do
            if data[i] == nil then
                table.insert(remove_queue, i)
            end
        end

        -- remove queued values
        for _, i in next, remove_queue do
            destroy(scopes[i])

            input_cache[i] = nil
            output_cache[i] = nil
            input_nodes[i] = nil
            scopes[i] = nil
        end

        table.clear(remove_queue)

        push_scope(subowner)

        -- process new or changed values
        for i, v in next, data do
            local cv = input_cache[i]

            if cv ~= v then
                if cv == nil then -- create new scope and run transform
                    local scope = create_node(subowner, false, false)
                    scopes[i] = scope :: Node<any>

                    local node = create_source_node(v)

                    push_scope(scope)

                    local ok, result = pcall(transform, function()
                        push_child_to_scope(node)
                        return node.cache
                    end, i)
                    
                    pop_scope()

                    if not ok then
                        pop_scope() -- subowner scope
                        error(result, 0)
                    end
                    
                    input_nodes[i] = node
                    output_cache[i] = result
                else -- update source
                    input_nodes[i].cache = v
                    update_descendants(input_nodes[i])
                end

                input_cache[i] = v
            end
        end

        pop_scope()

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)
        
        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

local function values<K, VI, VO>(input: () -> Map<K, VI>, transform: (VI, () -> K) -> VO): () -> { VO }
    local owner  = assert_stable_scope()
    local subowner = create_node(owner, false, false)
    
    local cur_input_cache_up = {} :: Map<VI, K>
    local new_input_cache_up = {} :: Map<VI, K>
    local output_cache = {} :: Map<VI, VO>
    local input_nodes = {} :: Map<VI, SourceNode<K>>
    local scopes = {} :: Map<VI, Node<unknown>>

    local function update_children(data: Map<K, VI>)
        local cur_input_cache, new_input_cache = cur_input_cache_up, new_input_cache_up

        if flags.strict then
            local cache = {}
            for _, v in next, data do
                if cache[v] ~= nil then
                    throw "duplicate table value detected"
                end
                cache[v] = true
            end
        end

        push_scope(subowner)
    
        -- process data
        for i, v in next, data do
            new_input_cache[v] = i

            local cv = cur_input_cache[v]
            
            if cv == nil then -- create new scope and run transform
                local scope = create_node(subowner, false, false)
                scopes[v] = scope :: Node<any>

                local node = create_source_node(i)
    
                push_scope(scope)
                
                local ok, result = pcall(transform, v, function()
                    push_child_to_scope(node)
                    return node.cache
                end)
                
                pop_scope()

                if not ok then
                    pop_scope() -- subowner scope
                    error(result, 0)
                end

                input_nodes[v] = node
                output_cache[v] = result
            else -- update source
                if cv ~= i then
                    input_nodes[v].cache = i
                    update_descendants(input_nodes[v])
                end

                cur_input_cache[v] = nil
            end
        end

        pop_scope()

        -- remove old values
        for v in next, cur_input_cache do
            destroy(scopes[v])

            output_cache[v] = nil
            input_nodes[v] = nil
            scopes[v] = nil
        end

        -- update buffer cache
        table.clear(cur_input_cache)
        cur_input_cache_up, new_input_cache_up = new_input_cache, cur_input_cache

        local output_array = table.create(#scopes)
        for _, v in next, output_cache do
            table.insert(output_array, v)
        end
        check_primitives(output_array)

        return output_array
    end

    local node = create_node(owner, function()
        return update_children(input())
    end, false :: any)

    evaluate_node(node)

    return function()
        push_child_to_scope(node)
        return node.cache
    end
end

return function() return indexes, values end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="156">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">mount</string>
								<string name="ScriptGuid">{169B440C-A28B-4A41-866C-6A516C25AB50}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local root = require(script.Parent.root)
local apply = require(script.Parent.apply)

local function mount<T>(component: () -> T, target: Instance?): () -> ()
    return root(function()
        local result = component()
        if target then apply(target, { result }) end
    end)
end

return mount :: (<T>(component: () -> T, target: Instance) -> () -> ()) & ((component: () -> ()) -> () -> ())
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000042f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="157">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">read</string>
								<string name="ScriptGuid">{1845E7E7-E3FB-418F-A201-17917BC4DEB9}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function read<T>(value: T | () -> T): T
    return if type(value) == "function" then value() else value
end

return read
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000430</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="158">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">root</string>
								<string name="ScriptGuid">{5D6E909C-C527-4D48-B838-F4E7D06D613D}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_node = graph.create_node
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope
local destroy = graph.destroy

local refs = {}

local function root<T...>(fn: (destroy: () -> ()) -> T...): (() -> (), T...)
    local node = create_node(false, false, false)

    refs[node] = true -- prevent gc of root node

    local destroy = function()
        if not refs[node] then throw "root already destroyed" end
        refs[node] = nil
        destroy(node)
    end

    push_scope(node)

    local function efn(err: string) return debug.traceback(err, 3) end
    local result = { xpcall(fn, efn, destroy) }

    pop_scope()

    if not result[1] then
        destroy()
        throw(`error while running root():\n\n{result[2]}`)
    end

    return destroy, unpack(result :: any, 2)
end

return root :: <T...>(fn: (destroy: () -> ()) -> T...) -> (() -> (), T...)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000431</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="159">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">show</string>
								<string name="ScriptGuid">{2F1A4A6D-0D8C-4C4D-A022-056CEB2389CD}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local switch = require(script.Parent.switch)

local function show<T>(source: () -> any, component: () -> T, fallback: (() -> T)?): () -> T?
    local function truthy()
        return not not source()
    end

    return switch(truthy) {
        [true] = component,
        [false] = fallback,
    }
end

return show ::
    (<T>(source: () -> any, component: () -> T) -> () -> T?) &
    (<T, U>(source: () -> any, component: () -> T, fallback: () -> U) -> () -> (T | U)?)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000432</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="160">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">source</string>
								<string name="ScriptGuid">{0D881322-FBE4-4145-9820-DE1A89DD53C5}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local create_source_node = graph.create_source_node
local push_child_to_scope = graph.push_child_to_scope
local update_descendants = graph.update_descendants

export type Source<T> = (() -> T) & ((value: T) -> T)

local function source<T>(initial_value: T): Source<T>
    local node = create_source_node(initial_value)

    return function(...): T
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(node)
            return node.cache
        end

        local v = ... :: T
        if node.cache == v and (type(v) ~= "table" or table.isfrozen(v)) then 
            return v
        end

        node.cache = v
        update_descendants(node)
        return v
    end
end

return source :: (<T>(initial_value: T) -> Source<T>) & (<T>() -> Source<T>)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000433</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="161">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">spring</string>
								<string name="ScriptGuid">{3B89DC87-3A6C-4FCB-9C42-C408E6E0E588}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end
local Vector3 = game and Vector3 or require "test/mock".Vector3 :: never

--[[

Supported datatypes:
- number
- CFrame
- Color3
- UDim
- UDim2
- Vector2
- Vector3
- Rect

Unsupported datatypes:
- bool
- Vector2int16
- Vector3int16
- EnumItem

]]

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local create_source_node = graph.create_source_node
local assert_stable_scope = graph.assert_stable_scope
local evaluate_node = graph.evaluate_node
local update_descendants = graph.update_descendants
local push_child_to_scope = graph.push_child_to_scope

local UPDATE_RATE = 120
local TOLERANCE = 0.0001

type Vec3 = Vector3

local function Vec3(x: number?, y: number?, z: number?)
    return Vector3.new(x, y, z)
end

local ZERO = Vec3(0, 0, 0)

type Animatable = number | CFrame | Color3 | UDim | UDim2 | Vector2 | Vector3

type SpringData<T> = {
    k: number, -- spring constant
    c: number, -- damping coeff

    -- dimensions 1-3
    x0_123: Vec3,
    x1_123: Vec3,
    v_123: Vec3,

    -- dimensions 4-6
    x0_456: Vec3,
    x1_456: Vec3,
    v_456: Vec3,

    source_value: T -- current value of spring input source
}

type TypeToVec6<T> = (T) -> (Vec3, Vec3)
type Vec6ToType<T> = (Vec3, Vec3) -> T

local type_to_vec6 = {
    number = function(v)
        return Vec3(v, 0, 0), ZERO
    end :: TypeToVec6<number>,

    CFrame = function(v)
        return v.Position, Vec3(v:ToEulerAnglesXYZ())
    end :: TypeToVec6<CFrame>,

    Color3 = function(v)
        -- todo: hsv, oklab?
        return Vec3(v.R, v.G, v.B), ZERO
    end :: TypeToVec6<Color3>,

    UDim = function(v)
        return Vec3(v.Scale, v.Offset, 0), ZERO
    end :: TypeToVec6<UDim>,
    
    UDim2 = function(v)
        return Vec3(v.X.Scale, v.X.Offset, v.Y.Scale), Vec3(v.Y.Offset, 0, 0)
    end :: TypeToVec6<UDim2>,

    Vector2 = function(v)
        return Vec3(v.X, v.Y, 0), ZERO
    end :: TypeToVec6<Vector2>,

    Vector3 = function(v)
        return v, ZERO
    end :: TypeToVec6<Vector3>,

    Rect = function(v)
        return Vec3(v.Min.X, v.Min.Y, v.Max.X), Vec3(v.Max.Y, 0, 0)
    end :: TypeToVec6<Rect>
}

local vec6_to_type = {
    number = function(a, b)
        return a.X
    end :: Vec6ToType<number>,

    CFrame = function(a, b)
        return CFrame.new(a) * CFrame.fromEulerAnglesXYZ(b.X, b.Y, b.Z)
    end :: Vec6ToType<CFrame>,

    Color3 = function(v)
        return Color3.new(math.clamp(v.X, 0, 1), math.clamp(v.Y, 0, 1), math.clamp(v.Z, 0, 1))
    end :: Vec6ToType<Color3>,

    UDim = function(v)
        return UDim.new(v.X, math.round(v.Y))
    end :: Vec6ToType<UDim>,
    
    UDim2 = function(a, b)
        return UDim2.new(a.X, math.round(a.Y), a.Z, math.round(b.X))
    end :: Vec6ToType<UDim2>,

    Vector2 = function(v)
        return Vector2.new(v.X, v.Y)
    end :: Vec6ToType<Vector2>,

    Vector3 = function(v)
        return v
    end :: Vec6ToType<Vector3>,

    Rect = function(a, b)
        return Rect.new(a.X, a.Y, a.Z, b.X)
    end :: Vec6ToType<Rect>
}

local invalid_type = {
    __index = function(_, t: string)
        throw(`cannot spring type {t}`)
    end
}

setmetatable(type_to_vec6, invalid_type)
setmetatable(vec6_to_type, invalid_type)

-- maps spring data to its corresponding output node
-- lifetime of spring data is tied to output node
local springs: { [SpringData<any>]: SourceNode<any> } = {}
setmetatable(springs, { __mode = "v" })

local function spring<T>(source: () -> T, period: number?, damping_ratio: number?): () -> T
    local owner = assert_stable_scope()

    -- https://en.wikipedia.org/wiki/Damping

    local w_n = 2*math.pi / (period or 1)
    local z = damping_ratio or 1

    local k = w_n^2
    local c_c = 2*w_n
    local c = z * c_c

    -- todo: is there a solution other than reducing step size?
    -- todo: this does not catch all solver exploding cases
    if c > UPDATE_RATE*2 then -- solver will explode if this is true
        throw("spring damping too high, consider reducing damping or increasing period")
    end

    local data: SpringData<T> = {
        k = k,
        c = c,

        x0_123 = ZERO,
        x1_123 = ZERO,
        v_123 = ZERO,

        x0_456 = ZERO,
        x1_456 = ZERO,
        v_456 = ZERO,

        source_value = false :: any,
    }
    
    local output = create_source_node(false :: any)

    local function updater_effect()
        local value = source()
        data.x1_123, data.x1_456 = type_to_vec6[typeof(value)](value)
        data.source_value = value
        springs[data] = output -- todo: investigate why insertion is not O(1) at ~20k springs
        return value
    end

    local updater = create_node(owner, updater_effect, false :: any)

    evaluate_node(updater)

    -- set initial position to goal
    data.x0_123, data.x0_456 = data.x1_123, data.x1_456

    -- set output to goal
    output.cache = data.source_value

    return function(...)
        if select("#", ...) == 0 then -- no args were given
            push_child_to_scope(output)
            return output.cache
        end

        -- set current position to value
        local v = ... :: T
        data.x0_123, data.x0_456 = type_to_vec6[typeof(v)](v)

        -- reset velocity
        data.v_123 = ZERO
        data.v_456 = ZERO

        -- schedule spring
        springs[data] = output

        -- set output to value
        output.cache = v

        return v
    end
end

local function step_springs(dt: number)
    for data in next, springs do
        local k, c,
        x0_123, x1_123, u_123,
        x0_456, x1_456, u_456 =
            data.k, data.c,
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456

        -- calculate displacement from target
        local dx_123 = x0_123 - x1_123
        local dx_456 = x0_456 - x1_456

        -- calculate spring force
        local fs_123 = dx_123*-k
        local fs_456 = dx_456*-k

        -- calculate friction force
        local ff_123 = u_123*-c
        local ff_456 = u_456*-c

        -- calculate acceleration step
        local dv_123 = (fs_123 + ff_123)*dt
        local dv_456 = (fs_456 + ff_456)*dt

        -- apply acceleration step
        local v_123 = u_123 + dv_123
        local v_456 = u_456 + dv_456

        -- calculate new position
        local x_123 = x0_123 + v_123*dt
        local x_456 = x0_456 + v_456*dt

        data.x0_123, data.x0_456 = x_123, x_456
        data.v_123, data.v_456 = v_123, v_456
    end
end

local remove_queue = {}

local function update_spring_sources()
    for data, output in next, springs do
        local x0_123, x1_123, v_123,
        x0_456, x1_456, v_456 =
            data.x0_123, data.x1_123, data.v_123,
            data.x0_456, data.x1_456, data.v_456
    
        local dx_123, dx_456 =
            x0_123 - x1_123,
            x0_456 - x1_456

        -- todo: can this false positive?
        if (v_123 + v_456 + dx_123 + dx_456).Magnitude < TOLERANCE then
            -- close enough to target, unshedule spring and set value to target
            table.insert(remove_queue, data)
            output.cache = data.source_value
        else
            output.cache = vec6_to_type[typeof(data.source_value)](x0_123, x0_456)
        end

        update_descendants(output)
    end

    for _, data in next, remove_queue do
        springs[data] = nil
    end

    table.clear(remove_queue)
end

return function()
    local time_elapsed = 0

    return spring, function(dt: number)
        time_elapsed += dt

        while time_elapsed > 1 / UPDATE_RATE do
            time_elapsed -= 1 / UPDATE_RATE
            step_springs(1 / UPDATE_RATE)
        end

        update_spring_sources()
    end
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000434</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="162">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">switch</string>
								<string name="ScriptGuid">{AB9762E0-1432-4DD4-AB01-7E21D1E91E57}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local throw = require(script.Parent.throw)
local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
type SourceNode<T> = graph.SourceNode<T>
local create_node = graph.create_node
local evaluate_node = graph.evaluate_node
local push_child_to_scope = graph.push_child_to_scope
local destroy = graph.destroy
local assert_stable_scope = graph.assert_stable_scope
local push_scope = graph.push_scope
local pop_scope = graph.pop_scope

type Map<K, V> = { [K]: V }

local function switch<T, U>(source: () -> T): (map: Map<T, ((() -> U)?)>) -> () -> U?
    local owner = assert_stable_scope()

    return function(map)
        local last_scope: Node<false>?
        local last_component: (() -> U)?

        local function update(cached): U?
            local component = map[source()]
            if component == last_component then return cached end
            last_component = component

            if last_scope then
                destroy(last_scope :: Node<any>)
                last_scope = nil
            end

            if component == nil then return nil end

            if type(component) ~= "function" then
                throw "map must map a value to a function"
            end

            local new_scope = create_node(owner, false, false)
            last_scope = new_scope :: Node<any>
            
            push_scope(new_scope)
        
            local ok, result = pcall(component)

            pop_scope()

            if not ok then error(result, 0) end

            return result
        end

        local node = create_node(owner, update, nil)

        evaluate_node(node)

        return function()
            push_child_to_scope(node)
            return node.cache
        end
    end
end

return switch
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000435</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="163">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">throw</string>
								<string name="ScriptGuid">{EA4B15EC-DF58-497D-9D6A-434E4724742C}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local function VIDE_ASSERT(msg): any
    error(msg, 0)
end

return VIDE_ASSERT
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000436</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="164">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">untrack</string>
								<string name="ScriptGuid">{F67D5F1B-7ACE-4679-BC3E-AA8371611525}</string>
								<ProtectedString name="Source"><![CDATA[if not game then script = require "test/relative-string" end

local graph = require(script.Parent.graph)
type Node<T> = graph.Node<T>
local get_scope = graph.get_scope

local function untrack<T>(source: () -> T): T
    local scope = get_scope()
    
    if scope then
        -- sources are only tracked if the node in scope has an effect
        local effect = scope.effect
        scope.effect = false

        local ok, result = pcall(source)

        scope.effect = effect :: () -> ()

        if not ok then error(result, 0) end

        return result
    else
        return source()
    end
end

return untrack
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000437</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="165">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">dekkonot_sha256@1.0.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000438</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="166">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">sha256</string>
							<string name="ScriptGuid">{0FC22562-A0BF-428C-9DBE-5B0B1B13E70D}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--!native
--!optimize 2

--stylua: ignore
local K = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
}

--- An allocation that is reused for blocks during hashing
local BLOCK = table.create(64)

--[=[
	Processes `message` from byte `start` to byte `finish` using `digest`.
	It is assumed that `(finish - start) % 64 == 0`.
]=]
local function processBlocks(digest: { number }, message: string, start: number, finish: number)
	local block = BLOCK
	local d1, d2, d3, d4 = digest[1], digest[2], digest[3], digest[4]
	local d5, d6, d7, d8 = digest[5], digest[6], digest[7], digest[8]

	for i = start, finish, 64 do
		-- Fill `block`
		for t = 1, 16 do
			local a, b, c, d = string.byte(message, i, i + 3)
			block[t] = bit32.bor(bit32.lshift(a, 24), bit32.lshift(b, 16), bit32.lshift(c, 8), d)
			i += 4
		end
		for t = 17, 64 do
			local b2 = block[t - 2]
			local b15 = block[t - 15]
			block[t] = bit32.bxor(bit32.rrotate(b2, 17), bit32.rrotate(b2, 19), bit32.rshift(b2, 10))
				+ block[t - 7]
				+ bit32.bxor(bit32.rrotate(b15, 7), bit32.rrotate(b15, 18), bit32.rshift(b15, 3))
				+ block[t - 16]
		end

		local a, b, c, d = d1, d2, d3, d4
		local e, f, g, h = d5, d6, d7, d8
		local temp1, temp2
		for t = 1, 64 do
			-- h + bsig1(e) + ch(e, f, g) + K[t] + block[t]
			-- bsig1(e) = bit32.bxor(bit32.rrotate(e, 6), bit32.rrotate(e, 11), bit32.rrotate(e, 25))
			-- ch(e, f, g) = bit32.band(e, f) + bit32.band(-1 - e, g)
			temp1 = h
				+ bit32.bxor(bit32.rrotate(e, 6), bit32.rrotate(e, 11), bit32.rrotate(e, 25))
				+ bit32.band(e, f)
				+ bit32.band(bit32.bnot(e), g)
				+ K[t]
				+ block[t]
			-- bsig0(a) + maj(a, b, c)
			-- bsig0(a) = bit32.bxor(bit32.rrotate(a, 2), bit32.rrotate(a, 13), bit32.rrotate(a, 22))
			-- maj(a, b, c) = bit32.band(c, b) + bit32.band(a, bit32.bxor(c, b))
			temp2 = bit32.band(c, b)
				+ bit32.band(a, bit32.bxor(c, b))
				+ bit32.bxor(bit32.rrotate(a, 2), bit32.rrotate(a, 13), bit32.rrotate(a, 22))
			h = g
			g = f
			f = e
			e = d + temp1
			d = c
			c = b
			b = a
			a = temp1 + temp2
		end

		d1 = bit32.bor(a + d1, 0)
		d2 = bit32.bor(b + d2, 0)
		d3 = bit32.bor(c + d3, 0)
		d4 = bit32.bor(d + d4, 0)
		d5 = bit32.bor(e + d5, 0)
		d6 = bit32.bor(f + d6, 0)
		d7 = bit32.bor(g + d7, 0)
		d8 = bit32.bor(h + d8, 0)
	end

	digest[1] = d1
	digest[2] = d2
	digest[3] = d3
	digest[4] = d4
	digest[5] = d5
	digest[6] = d6
	digest[7] = d7
	digest[8] = d8
end

--[=[
	Computes the SHA-256 hash for `message` and returns it.
	This function returns both a hexadecimal encoded string of the hash
	and returns a **read-only** table containing the eight 32-bit integers
	that make up the hash.
	
	@param message -- The payload to compute the SHA-256 hash of
	@return string -- The computed SHA-256 hash as a string of hexadecimal digits
	@return {number} -- The computed SHA-256 hash as an array of 8 integers
]=]
local function sha256(message: string): (string, { number })
	local digest = {
		0x6a09e667,
		0xbb67ae85,
		0x3c6ef372,
		0xa54ff53a,
		0x510e527f,
		0x9b05688c,
		0x1f83d9ab,
		0x5be0cd19,
	}

	local messageLen = #message
	local leftover = messageLen % 64
	if messageLen >= 64 then
		processBlocks(digest, message, 1, messageLen - leftover)
	end

	-- Raise `leftover` to next multiple of 64 so that we can calculate
	-- how much padding we need without a branch or loop.
	-- The number here is just masking off the last 6 bits.
	local nextMultipleOf64 = bit32.band(leftover + 32, 0xffff_ffc0)

	local finalMessage = {
		if leftover ~= 0 then string.sub(message, -leftover) else "",
		"\x80",
		string.rep("\0", (nextMultipleOf64 - leftover - 9) % 64),
		string.pack(">L", messageLen * 8),
	}
	local finalBlock = table.concat(finalMessage)
	processBlocks(digest, finalBlock, 1, #finalBlock)

	return string.format(
		"%08x%08x%08x%08x%08x%08x%08x%08x",
		digest[1],
		digest[2],
		digest[3],
		digest[4],
		digest[5],
		digest[6],
		digest[7],
		digest[8]
	),
		table.freeze(digest)
end

return sha256
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000439</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="167">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{D539CC6E-2968-4BBF-9283-9ED5B69BEBC3}</string>
								<ProtectedString name="Source"><![CDATA[return {
	dependencies = {
	},
	package = {
		description = "Implementation of the SHA-256 hashing algorithm",
		exclude = {"*"},
		include = {"*.luau", "wally.toml"},
		license = "MIT",
		name = "dekkonot/sha256",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "1.0.1",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043a</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="168">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">evaera_cmdr@1.12.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043b</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="169">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">cmdr</string>
							<string name="ScriptGuid">{B5EF8CCD-3921-4C1F-BEC7-485E13C7A20C}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Util = require(script.Shared:WaitForChild("Util"))

if RunService:IsServer() == false then
	error("Cmdr server module is somehow running on a client!")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = nil;
		RemoteFunction = nil;
		RemoteEvent = nil;
		Util = Util;
		DefaultCommandsFolder = script.BuiltInCommands;
	}, {
		__index = function (self, k)
			local r = self.Registry[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Registry, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(script.Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(script.Shared.Dispatcher)(Cmdr)

	require(script.Initialize)(Cmdr)
end

-- Handle command invocations from the clients.
Cmdr.RemoteFunction.OnServerInvoke = function (player, text, options)
	if #text > 100_000 then
		return "Input too long"
	end

	return Cmdr.Dispatcher:EvaluateAndRun(text, player, options)
end

return Cmdr]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043c</UniqueId>
						</Properties>
						<Item class="Folder" referent="170">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BuiltInCommands</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043d</UniqueId>
							</Properties>
							<Item class="Folder" referent="171">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Admin</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043e</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="172">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">announce</string>
										<string name="ScriptGuid">{204A206F-4516-4E1A-AEB8-B190EDCAA5A6}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "announce";
	Aliases = {"m"};
	Description = "Makes a server-wide announcement.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "string";
			Name = "text";
			Description = "The announcement text.";
		},
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000043f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="173">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">announceServer</string>
										<string name="ScriptGuid">{282C9979-78D3-496A-8F25-0B35B904D2C1}</string>
										<ProtectedString name="Source"><![CDATA[local TextService = game:GetService("TextService")
local Players = game:GetService("Players")
local Chat = game:GetService("Chat")

return function (context, text)
	local filterResult = TextService:FilterStringAsync(text, context.Executor.UserId, Enum.TextFilterContext.PublicChat)

	for _, player in ipairs(Players:GetPlayers()) do
		if Chat:CanUsersChatAsync(context.Executor.UserId, player.UserId) then
			context:SendEvent(player, "Message", filterResult:GetChatForUserAsync(player.UserId), context.Executor)
		end
	end

	return "Created announcement."
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000440</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="174">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">gotoPlace</string>
										<string name="ScriptGuid">{68BEF676-EFD2-475F-925D-9421EDC19D4D}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "goto-place";
	Aliases = {};
	Description = "Teleport to a Roblox place";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"follow-player|Join a player in another server\" goto-place $1{players|Players} ${{get-player-place-instance $2{playerId|Target}}}",
		"alias \"rejoin|Rejoin this place. You might end up in a different server.\" goto-place $1{players|Players} ${get-player-place-instance ${me} PlaceId}"
	};
	Args = {
		{
			Type = "players";
			Name = "Players";
			Description = "The players you want to teleport";
		},
		{
			Type = "integer";
			Name = "Place ID";
			Description = "The Place ID you want to teleport to";
		},
		{
			Type = "string";
			Name = "JobId";
			Description = "The specific JobId you want to teleport to";
			Optional = true;
		}
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000441</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="175">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">gotoPlaceServer</string>
										<string name="ScriptGuid">{73B76BFD-6F65-436E-BFE7-956CEF2ABB71}</string>
										<ProtectedString name="Source"><![CDATA[local TeleportService = game:GetService("TeleportService")

return function(context, players, placeId, jobId)
	players = players or { context.Executor }

	if placeId <= 0 then
		return "Invalid place ID"
	elseif jobId == "-" then
		return "Invalid job ID"
	end

	context:Reply("Commencing teleport...")

	if jobId then
		for _, player in ipairs(players) do
			TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
		end
	else
		TeleportService:TeleportAsync(placeId, players)
	end

	return "Teleported."
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000442</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="176">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">kick</string>
										<string name="ScriptGuid">{FA67C9CA-E3CA-48F3-B84C-28925ED26EC8}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "kick";
	Aliases = {"boot"};
	Description = "Kicks a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "players";
			Description = "The players to kick.";
		},
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000443</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="177">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">kickServer</string>
										<string name="ScriptGuid">{B9610926-4556-48C8-A643-B365CE0D57ED}</string>
										<ProtectedString name="Source"><![CDATA[return function (_, players)
	for _, player in pairs(players) do
		player:Kick("Kicked by admin.")
	end

	return ("Kicked %d players."):format(#players)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000444</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="178">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">kill</string>
										<string name="ScriptGuid">{3E518B37-3ADE-48A9-A263-C4F89D9139A8}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "kill";
	Aliases = {"slay"};
	Description = "Kills a player or set of players.";
	Group = "DefaultAdmin";
	Args = {
		{
			Type = "players";
			Name = "victims";
			Description = "The players to kill.";
		},
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000445</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="179">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">killServer</string>
										<string name="ScriptGuid">{3BF9AD84-E1CF-46F7-8539-3AE4819622B1}</string>
										<ProtectedString name="Source"><![CDATA[return function (_, players)
	for _, player in pairs(players) do
		if player.Character then
			player.Character:BreakJoints()
		end
	end

	return ("Killed %d players."):format(#players)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000446</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="180">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">respawn</string>
										<string name="ScriptGuid">{08ACA5EB-30EA-4C81-9B25-27E7B1C4AB12}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "respawn";
	Description = "Respawns a player or a group of players.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"refresh|Respawns the player and returns them to their previous location.\" var= .refresh_pos ${position $1{player|Player}} && respawn $1 && tp $1 @${{var .refresh_pos}}"
	},
	Args = {
		{
			Type = "players";
			Name = "targets";
			Description = "The players to respawn."
		}
	}
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000447</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="181">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">respawnServer</string>
										<string name="ScriptGuid">{2D8635AC-DFE4-438A-890B-13FD603BAC1D}</string>
										<ProtectedString name="Source"><![CDATA[return function(_, players)
	for _, player in pairs(players) do
		if player.Character then
			player:LoadCharacter()
		end
	end
	return ("Respawned %d players."):format(#players)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000448</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="182">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">teleport</string>
										<string name="ScriptGuid">{64A717C1-6CFC-4FC0-85C9-5E7543E48A55}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "teleport";
	Aliases = {"tp"};
	Description = "Teleports a player or set of players to one target.";
	Group = "DefaultAdmin";
	AutoExec = {
		"alias \"bring|Brings a player or set of players to you.\" teleport $1{players|players|The players to bring} ${me}";
		"alias \"to|Teleports you to another player or location.\" teleport ${me} $1{player @ vector3|Destination|The player or location to teleport to}";
	};
	Args = {
		{
			Type = "players";
			Name = "From";
			Description = "The players to teleport";
		},
		{
			Type = "player @ vector3";
			Name = "Destination";
			Description = "The player to teleport to"
		}
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000449</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="183">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">teleportServer</string>
										<string name="ScriptGuid">{A993FC9B-7177-4FA6-90F2-502B1CDA0540}</string>
										<ProtectedString name="Source"><![CDATA[return function (_, fromPlayers, destination)
	local cframe

	if typeof(destination) == "Instance" then
		if destination.Character and destination.Character:FindFirstChild("HumanoidRootPart") then
			cframe = destination.Character.HumanoidRootPart.CFrame
		else
			return "Target player has no character."
		end
	elseif typeof(destination) == "Vector3" then
		cframe = CFrame.new(destination)
	end

	for _, player in ipairs(fromPlayers) do
		if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = cframe
		end
	end

	return ("Teleported %d players."):format(#fromPlayers)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044a</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="184">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Debug</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044b</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="185">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">blink</string>
										<string name="ScriptGuid">{36E0AF19-1F74-4730-A5AF-324032522BCE}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "blink";
	Aliases = {"b"};
	Description = "Teleports you to where your mouse is hovering.";
	Group = "DefaultDebug";
	Args = {};

	ClientRun = function(context)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character then
			return "You don't have a character."
		end

		character:MoveTo(mouse.Hit.p)

		return "Blinked!"
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="186">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">fetch</string>
										<string name="ScriptGuid">{FDE591C0-996E-4C77-9651-FC1A9D143E38}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "fetch";
	Aliases = {};
	Description = "Fetch a value from the Internet";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "url";
			Name = "URL";
			Description = "The URL to fetch.";
		}
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="187">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">fetchServer</string>
										<string name="ScriptGuid">{E4227FAB-A257-415C-8140-0C6C97DF80B5}</string>
										<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

return function (_, url)
	return HttpService:GetAsync(url)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="188">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getPlayerPlaceInstance</string>
										<string name="ScriptGuid">{A70E6D7B-C0A2-4499-8D49-4A6777F8EBB8}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "get-player-place-instance";
	Aliases = {};
	Description = "Returns the target player's Place ID and the JobId separated by a space. Returns 0 if the player is offline or something else goes wrong.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "playerId";
			Name = "Player";
			Description = "Get the place instance of this player";
		},
		function(context)
			return {
				Type = context.Cmdr.Util.MakeEnumType("PlaceInstance Format", {"PlaceIdJobId", "PlaceId", "JobId"}),
				Name = "Format";
				Description = "What data to return. PlaceIdJobId returns both separated by a space.";
				Default = "PlaceIdJobId";
			}
		end
	};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000044f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="189">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getPlayerPlaceInstanceServer</string>
										<string name="ScriptGuid">{2A3F48C5-33E3-4A0E-8137-C96F39676D50}</string>
										<ProtectedString name="Source"><![CDATA[local TeleportService = game:GetService("TeleportService")

return function (_, playerId, format)
	format = format or "PlaceIdJobId"

	local ok, _, errorText, placeId, jobId = pcall(function()
		return TeleportService:GetPlayerPlaceInstanceAsync(playerId)
	end)

	if not ok or (errorText and #errorText > 0) then
		if format == "PlaceIdJobId" then
			return "0" .. " -"
		elseif format == "PlaceId" then
			return "0"
		elseif format == "JobId" then
			return "-"
		end
	end

	if format == "PlaceIdJobId" then
		return placeId .. " " .. jobId
	elseif format == "PlaceId" then
		return tostring(placeId)
	elseif format == "JobId" then
		return tostring(jobId)
	end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000450</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="190">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">position</string>
										<string name="ScriptGuid">{DB1DB05B-EBB9-401F-A9E1-128C145F7770}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "position";
	Aliases = {"pos"};
	Description = "Returns Vector3 position of you or other players. Empty string is the player has no character.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "player";
			Name = "Player";
			Description = "The player to report the position of. Omit for your own position.";
			Default = Players.LocalPlayer;
		}
	};

	ClientRun = function(_, player)
		local character = player.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return ""
		end

		return tostring(character.HumanoidRootPart.Position):gsub("%s", "")
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000451</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="191">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">thru</string>
										<string name="ScriptGuid">{472A3AFB-2B07-47C3-AC7A-8FC314AB32FF}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "thru";
	Aliases = {"t", "through"};
	Description = "Teleports you through whatever your mouse is hovering over, placing you equidistantly from the wall.";
	Group = "DefaultDebug";
	Args = {
		{
			Type = "number";
			Name = "Extra distance";
			Description = "Go through the wall an additional X studs.";
			Default = 0;
		}
	};

	ClientRun = function(context, extra)
		-- We implement this here because player position is owned by the client.
		-- No reason to bother the server for this!

		local mouse = context.Executor:GetMouse()
		local character = context.Executor.Character

		if not character or not character:FindFirstChild("HumanoidRootPart") then
			return "You don't have a character."
		end

		local pos = character.HumanoidRootPart.Position
		local diff = (mouse.Hit.p - pos)

		character:MoveTo((diff * 2) + (diff.unit * extra) + pos)

		return "Blinked!"
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000452</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="192">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">uptime</string>
										<string name="ScriptGuid">{D608B0D6-FB6F-4B84-B857-0F1D44AF1B2E}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "uptime";
	Aliases = {};
	Description = "Returns the amount of time the server has been running.";
	Group = "DefaultDebug";
	Args = {};
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000453</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="193">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">uptimeServer</string>
										<string name="ScriptGuid">{F05DDE67-86AA-41BC-A5A7-14951F9C2FBB}</string>
										<ProtectedString name="Source"><![CDATA[local startTime = os.time()

return function ()
	local uptime = os.time() - startTime
	return ("%dd %dh %dm %ds"):format(
		math.floor(uptime / (60 * 60 * 24)),
		math.floor(uptime / (60 * 60)) % 24,
		math.floor(uptime / 60) % 60,
		math.floor(uptime) % 60
	)
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000454</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="194">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">version</string>
										<string name="ScriptGuid">{E33A74B8-00E6-4426-9415-36DBF6610539}</string>
										<ProtectedString name="Source"><![CDATA[local version = "v1.12.0"

return {
	Name = "version",
	Args = {},
	Description = "Shows the current version of Cmdr",
	Group = "DefaultDebug",

	Run = function()
		return ("Cmdr Version %s"):format(version)
	end,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000455</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="195">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Utility</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000456</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="196">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">alias</string>
										<string name="ScriptGuid">{0CE26E94-474B-4E7D-B29C-409D8F35D555}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "alias";
	Aliases = {};
	Description = "Creates a new, single command out of a command and given arguments.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Alias name";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "string";
			Name = "Command string";
			Description = "The command text you want to run. Separate multiple commands with \"&&\". Accept arguments with $1, $2, $3, etc."
		},
	};

	ClientRun = function(context, name, commandString)
		context.Cmdr.Registry:RegisterCommandObject(
			context.Cmdr.Util.MakeAliasCommand(name, commandString),
			true
		)

		return ("Created alias %q"):format(name)
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000457</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="197">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">bind</string>
										<string name="ScriptGuid">{CD36E96A-A4AA-414F-90D0-ABB41BC956D6}</string>
										<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

return {
	Name = "bind";
	Aliases = {};
	Description = "Binds a command string to a key or mouse input.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input";
			Description = "The key or input type you'd like to bind the command to."
		},
		{
			Type = "command";
			Name = "Command";
			Description = "The command you want to run on this input"
		},
		{
			Type = "string";
			Name = "Arguments";
			Description = "The arguments for the command";
			Default = "";
		}
	};

	ClientRun = function(context, bind, command, arguments)
		local binds = context:GetStore("CMDR_Binds")

		command = command .. " " .. arguments

		if binds[bind] then
			binds[bind]:Disconnect()
		end

		local bindType = context:GetArgument(1).Type.Name

		if bindType == "userInput" then
			binds[bind] = UserInputService.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then
					return
				end

				if input.UserInputType == bind or input.KeyCode == bind then
					context:Reply(context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command)))
				end
			end)
		elseif bindType == "bindableResource" then
			return "Unimplemented..."
		elseif bindType == "player" then
			binds[bind] = bind.Chatted:Connect(function(message)
				local args = { message }
				local chatCommand = context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, context.Cmdr.Util.SubstituteArgs(command, args))
				context:Reply(("%s $ %s : %s"):format(
					bind.Name,
					chatCommand,
					context.Dispatcher:EvaluateAndRun(chatCommand)
				), Color3.fromRGB(244, 92, 66))
			end)
		end


		return "Bound command to input."
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000458</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="198">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">clear</string>
										<string name="ScriptGuid">{F2C8DDC4-2FD3-473F-8AC8-B9611FA2E9CB}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "clear",
	Aliases = {},
	Description = "Clear all lines above the entry line of the Cmdr window.",
	Group = "DefaultUtil",
	Args = {},
	ClientRun = function()
		local player = Players.LocalPlayer
		local gui = player:WaitForChild("PlayerGui"):WaitForChild("Cmdr")
		local frame = gui:WaitForChild("Frame")

		if gui and frame then
			for _, child in pairs(frame:GetChildren()) do
				if child.Name == "Line" and child:IsA("TextBox") then
					child:Destroy()
				end
			end
		end
		return ""
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000459</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="199">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">convertTimestamp</string>
										<string name="ScriptGuid">{8A7450F1-FFB2-4C8A-A189-FC3A488E7596}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "convertTimestamp";
	Aliases = { "date" },
	Description = "Convert a timestamp to a human-readable format.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "number";
			Name = "timestamp";
			Description = "A numerical representation of a specific moment in time.";
			Optional = true
		}
	};
	ClientRun = function(_, timestamp)
		timestamp = timestamp or os.time()
		return `{os.date("%x", timestamp)} {os.date("%X", timestamp)}`
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="200">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">echo</string>
										<string name="ScriptGuid">{90DB7616-CB52-43D3-B5FE-40EB947B845E}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "echo";
	Aliases = {"="};
	Description = "Echoes your text back to you.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Text";
			Description = "The text."
		},
	};

	Run = function(_, text)
		return text
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="201">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">edit</string>
										<string name="ScriptGuid">{6732007B-0EF0-4AD0-B9A5-681BFDC23210}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local TEXT_BOX_PROPERTIES = {
	AnchorPoint = Vector2.new(0.5, 0.5),
	BackgroundColor3 = Color3.fromRGB(17, 17, 17),
	BackgroundTransparency = 0.05,
	BorderColor3 = Color3.fromRGB(17, 17, 17),
	BorderSizePixel = 20,
	ClearTextOnFocus = false,
	MultiLine = true,
	Position = UDim2.new(0.5, 0, 0.5, 0),
	Size = UDim2.new(0.5, 0, 0.4, 0),
	Font = Enum.Font.Code,
	TextColor3 = Color3.fromRGB(241, 241, 241),
	TextWrapped = true,
	TextSize = 18,
	TextXAlignment = "Left",
	TextYAlignment = "Top",
	AutoLocalize = false,
	PlaceholderText = "Right click to exit",
}

local lock

return {
	Name = "edit";
	Aliases = {};
	Description = "Edit text in a TextBox";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Input text";
			Description = "The text you wish to edit";
			Default = "";
		},
		{
			Type = "string";
			Name = "Delimiter";
			Description = "The character that separates each line";
			Default = ",";
		}
	};

	ClientRun = function(context, text, delimeter)
		lock = lock or context.Cmdr.Util.Mutex()

		local unlock = lock()

		context:Reply("Right-click on the text area to exit.", Color3.fromRGB(158, 158, 158))

		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = "CmdrEditBox"
		screenGui.ResetOnSpawn = false

		local textBox = Instance.new("TextBox")

		for key, value in pairs(TEXT_BOX_PROPERTIES) do
			textBox[key] = value
		end

		textBox.Text = text:gsub(delimeter, "\n")
		textBox.Parent = screenGui

		screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

		local thread = coroutine.running()

		textBox.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				coroutine.resume(thread, textBox.Text:gsub("\n", delimeter))
				screenGui:Destroy()
				unlock()
			end
		end)

		return coroutine.yield()
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="202">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">history</string>
										<string name="ScriptGuid">{AE337331-92F9-4D39-8617-972C1C42ABA0}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "history";
	Aliases = {};
	AutoExec = {
		"alias \"!|Displays previous command from history.\" run ${history $1{number|Line Number}}";
		"alias \"^|Runs the previous command, replacing all occurrences of A with B.\" run ${run replace ${history -1} $1{string|A} $2{string|B}}";
		"alias \"!!|Reruns the last command.\" ! -1";
	};
	Description = "Displays previous commands from history.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Line Number";
			Description = "Command line number (can be negative to go from end)"
		},
	};

	ClientRun = function(context, line)
		local history = context.Dispatcher:GetHistory()

		if line <= 0 then
			line = #history + line
		end

		return history[line] or ""
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="203">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">hover</string>
										<string name="ScriptGuid">{EDF0B579-F2A3-4154-8062-6A7DB51BF1B6}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

return {
	Name = "hover";
	Description = "Returns the name of the player you are hovering over.";
	Group = "DefaultUtil";
	Args = {};

	ClientRun = function()
		local mouse = Players.LocalPlayer:GetMouse()
		local target = mouse.Target

		if not target then
			return ""
		end

		local p = Players:GetPlayerFromCharacter(target:FindFirstAncestorOfClass("Model"))

		return p and p.Name or ""
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="204">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">jsonArrayDecode</string>
										<string name="ScriptGuid">{CC921643-F32A-4746-A1D1-D004A23AF158}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "json-array-decode";
	Aliases = {};
	Description = "Decodes a JSON Array into a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "json";
			Name = "JSON";
			Description = "The JSON array."
		},
	};

	ClientRun = function(_, value)
		if type(value) ~= "table" then
			value = { value }
		end

		return table.concat(value, ",")
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000045f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="205">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">jsonArrayEncode</string>
										<string name="ScriptGuid">{E72FF74B-8D5D-4403-8489-231969F48F23}</string>
										<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

return {
	Name = "json-array-encode";
	Aliases = {};
	Description = "Encodes a comma-separated list into a JSON array";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		},
	};

	Run = function(_, text)
		return HttpService:JSONEncode(text:split(","))
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000460</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="206">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">len</string>
										<string name="ScriptGuid">{BA377563-2B4D-408D-8C91-87CDE7575E52}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "len";
	Aliases = {};
	Description = "Returns the length of a comma-separated list";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, list)
		return #(list:split(","))
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000461</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="207">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">math</string>
										<string name="ScriptGuid">{B830DDB7-B06D-48BD-A842-51415F2F0E41}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "math";
	Aliases = {};
	Description = "Perform a math operation on 2 values.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"+|Perform an addition.\" math + $1{number|Number} $2{number|Number}";
		"alias \"-|Perform a subtraction.\" math - $1{number|Number} $2{number|Number}";
		"alias \"*|Perform a multiplication.\" math * $1{number|Number} $2{number|Number}";
		"alias \"/|Perform a division.\" math / $1{number|Number} $2{number|Number}";
		"alias \"**|Perform an exponentiation.\" math ** $1{number|Number} $2{number|Number}";
		"alias \"%|Perform a modulus.\" math % $1{number|Number} $2{number|Number}";
	};
	Args = {
		{
			Type = "mathOperator";
			Name = "Operation";
			Description = "A math operation."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		};
		{
			Type = "number";
			Name = "Value";
			Description = "A number value."
		}
	};

	ClientRun = function(_, operation, a, b)
		return operation.Perform(a, b)
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000462</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="208">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">pick</string>
										<string name="ScriptGuid">{7632A153-B438-405C-A016-01E86691F5A3}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "pick";
	Aliases = {};
	Description = "Picks a value out of a comma-separated list.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "Index to pick";
			Description = "The index of the item you want to pick";
		},
		{
			Type = "string";
			Name = "CSV";
			Description = "The comma-separated list"
		}
	};

	Run = function(_, index, list)
		return list:split(",")[index] or ""
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000463</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="209">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">rand</string>
										<string name="ScriptGuid">{1DB0B0C3-2BD4-4B7D-8E52-A7A26CD2B0B3}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "rand";
	Aliases = {};
	Description = "Returns a random number between min and max";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "integer";
			Name = "First number";
			Description = "If second number is nil, random number is between 1 and this value. If second number is provided, number is between this number and the second number."
		},
		{
			Type = "integer";
			Name = "Second number";
			Description = "The upper bound.";
			Optional = true;
		}
	};

	Run = function(_, min, max)
		return tostring(max and math.random(min, max) or math.random(min))
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000464</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="210">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replace</string>
										<string name="ScriptGuid">{8E5E5561-65B5-467D-BD84-0383F29A7F13}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "replace";
	Aliases = {"gsub", "//"};
	Description = "Replaces text A with text B";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"map|Maps a CSV into another CSV\" replace $1{string|CSV} ([^,]+) \"$2{string|mapped value|Use %1 to insert the element}\"",
		"alias \"join|Joins a CSV with a specified delimiter\" replace $1{string|CSV} , $2{string|Delimiter}"
	},
	Args = {
		{
			Type = "string";
			Name = "Haystack";
			Description = "The source string upon which to perform replacement."
		},
		{
			Type = "string";
			Name = "Needle";
			Description = "The string pattern search for."
		},
		{
			Type = "string";
			Name = "Replacement";
			Description = "The string to replace matches (%1 to insert matches).";
			Default = "";
		},
	};

	Run = function(_, haystack, needle, replacement)
		return haystack:gsub(needle, replacement)
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000465</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="211">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">resolve</string>
										<string name="ScriptGuid">{300ED402-579C-4A60-A6A6-D997876620EF}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "resolve";
	Aliases = {};
	Description = "Resolves Argument Value Operators into lists. E.g., resolve players * gives you a list of all players.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"me|Displays your username\" resolve players ."
	};
	Args = {
		{
			Type = "type";
			Name = "Type";
			Description = "The type for which to resolve"
		},
		function (context)
			if context:GetArgument(1):Validate() == false then
				return
			end

			return {
				Type = context:GetArgument(1):GetValue();
				Name = "Argument Value Operator";
				Description = "The value operator to resolve. One of: * ** . ? ?N";
				Optional = true;
			}
		end
	};

	Run = function(context)
		return table.concat(context:GetArgument(2).RawSegments, ",")
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000466</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="212">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">run</string>
										<string name="ScriptGuid">{2945FB97-B5F3-41ED-B7FD-4124457439EA}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "run";
	Aliases = {">"};
	AutoExec = {
		"alias \"discard|Run a command and discard the output.\" replace ${run $1} .* \\\"\\\""
	};
	Description = "Runs a given command string (replacing embedded commands).";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run"
		},
	};

	Run = function(context, commandString)
		return context.Cmdr.Util.RunCommandString(context.Dispatcher, commandString)
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000467</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="213">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">runLines</string>
										<string name="ScriptGuid">{BC501939-3B27-4433-8AFC-4B38429584E6}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "run-lines";
	Aliases = {};
	Description = "Splits input by newlines and runs each line as its own command. This is used by the init-run command.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "string";
			Name = "Script";
			Description = "The script to parse.";
			Default = "";
		}
	};

	ClientRun = function(context, text)
		if #text == 0 then
			return ""
		end

		local shouldPrintOutput = context.Dispatcher:Run("var", "INIT_PRINT_OUTPUT") ~= ""

		local commands = text:gsub("\n+", "\n"):split("\n")

		for _, command in ipairs(commands) do
			if command:sub(1, 1) == "#" then
				continue
			end

			local output = context.Dispatcher:EvaluateAndRun(command)

			if shouldPrintOutput then
				context:Reply(output)
			end
		end

		return ""
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000468</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="214">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">runif</string>
										<string name="ScriptGuid">{C0619AC3-E710-4804-8A9C-F980A1FB6841}</string>
										<ProtectedString name="Source"><![CDATA[local conditions = {
	startsWith = function (text, arg)
		if text:sub(1, #arg) == arg then
			return text:sub(#arg + 1)
		end
	end
}

return {
	Name = "runif";
	Aliases = {};
	Description = "Runs a given command string if a certain condition is met.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "conditionFunction";
			Name = "Condition";
			Description = "The condition function"
		},
		{
			Type = "string";
			Name = "Argument";
			Description = "The argument to the condition function"
		},
		{
			Type = "string";
			Name = "Test against";
			Description = "The text to test against."
		},
		{
			Type = "string";
			Name = "Command";
			Description = "The command string to run if requirements are met. If omitted, return value from condition function is used.";
			Optional = true;
		},
	};

	Run = function(context, condition, arg, testAgainst, command)
		local conditionFunc = conditions[condition]

		if not conditionFunc then
			return ("Condition %q is not valid."):format(condition)
		end

		local text = conditionFunc(testAgainst, arg)

		if text then
			return context.Dispatcher:EvaluateAndRun(context.Cmdr.Util.RunEmbeddedCommands(context.Dispatcher, command or text))
		end

		return ""
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000469</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="215">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">unbind</string>
										<string name="ScriptGuid">{5FB85900-3615-4475-8EC1-3AD11014B7E3}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "unbind";
	Aliases = {};
	Description = "Unbinds an input previously bound with Bind";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "userInput ! bindableResource @ player";
			Name = "Input/Key";
			Description = "The key or input type you'd like to unbind."
		}
	};

	ClientRun = function(context, inputEnum)
		local binds = context:GetStore("CMDR_Binds")

		if binds[inputEnum] then
			binds[inputEnum]:Disconnect()
			binds[inputEnum] = nil
			return "Unbound command from input."
		else
			return "That input wasn't bound."
		end
	end
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="216">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">var</string>
										<string name="ScriptGuid">{8726019B-44CA-444E-B1B6-7B88F31E1391}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "var";
	Aliases = {};
	Description = "Gets a stored variable.";
	Group = "DefaultUtil";
	AutoExec = {
		"alias \"init-edit|Edit your initialization script\" edit ${var init} \\\\\n && var= init ||",
		"alias \"init-run|Re-runs the initialization script manually.\" run-lines ${var init}",
		"init-run",
	},
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to get, retrieved from your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="217">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">varServer</string>
										<string name="ScriptGuid">{D4F74B68-1307-4D41-9BF3-F6B3E77687D2}</string>
										<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key
		local value = DataStore:GetAsync(keyPath) or ""
		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end
		return value
	else
		local store = context:GetStore(namespace)

		local value = store[key] or ""

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="218">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">varSet</string>
										<string name="ScriptGuid">{22325873-86B9-477E-BA19-F5817A0C9140}</string>
										<ProtectedString name="Source"><![CDATA[return {
	Name = "var=";
	Aliases = {};
	Description = "Sets a stored value.";
	Group = "DefaultUtil";
	Args = {
		{
			Type = "storedKey";
			Name = "Key";
			Description = "The key to set, saved in your user data store. Keys prefixed with . are not saved. Keys prefixed with $ are game-wide. Keys prefixed with $. are game-wide and non-saved.";
		},
		{
			Type = "string";
			Name = "Value";
			Description = "Value or values to set.";
			Default = "";
		}
	};

	ClientRun = function(context, key)
		context:GetStore("vars_used")[key] = true
	end
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="219">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">varSetServer</string>
										<string name="ScriptGuid">{F15F01BF-B9CF-4957-A569-64464A638482}</string>
										<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local queue = {}
local DataStoresActive, DataStore
task.spawn(function()
	DataStoresActive, DataStore = pcall(function()
		local DataStore = DataStoreService:GetDataStore("_package/eryn.io/Cmdr")
		DataStore:GetAsync("test_key")
		return DataStore
	end)

	while #queue > 0 do
		coroutine.resume(table.remove(queue, 1))
	end
end)

return function (context, key, value)
	if DataStoresActive == nil then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	local gameWide = false
	local saved = true

	if key:sub(1, 1) == "$" then
		key = key:sub(2)
		gameWide = true
	end

	if key:sub(1, 1) == "." then
		key = key:sub(2)
		saved = false
	end

	if saved and not DataStoresActive then
		return "# You must publish this place to the web to use saved keys."
	end

	local namespace = "var_" .. (gameWide and "global" or tostring(context.Executor.UserId))

	if saved then
		local keyPath = namespace .. "_" .. key

		DataStore:SetAsync(keyPath, value)

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	else
		local store = context:GetStore(namespace)

		store[key] = value

		if type(value) == "table" then
			return table.concat(value, ",") or ""
		end

		return value
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046e</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="220">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">help</string>
									<string name="ScriptGuid">{F7DEBB86-5D44-4A26-A878-89E5B0277111}</string>
									<ProtectedString name="Source"><![CDATA[local ARGUMENT_SHORTHANDS = [[
Argument Shorthands
-------------------
.   Me/Self
*   All/Everyone
**  Others
?   Random
?N  List of N random values
]]

local TIPS = [[
Tips
----
• Utilize the Tab key to automatically complete commands
• Easily select and copy command output
]]

return {
	Name = "help";
	Description = "Displays a list of all commands, or inspects one command.";
	Group = "Help";
	Args = {
		{
			Type = "command";
			Name = "Command";
			Description = "The command to view information on";
			Optional = true;
		},
	};

	ClientRun = function (context, commandName)
		if commandName then
			local command = context.Cmdr.Registry:GetCommand(commandName)
			context:Reply(`Command: {command.Name}`, Color3.fromRGB(230, 126, 34))
			if command.Aliases and #command.Aliases > 0 then
				context:Reply(`Aliases: {table.concat(command.Aliases, ", ")}`, Color3.fromRGB(230, 230, 230))
			end
			context:Reply(command.Description, Color3.fromRGB(230, 230, 230))
			for i, arg in ipairs(command.Args) do
				context:Reply(
					`#{i} {arg.Name}{if arg.Optional == true then "?" else ""}: {arg.Type} - {arg.Description}`
				)
			end
		else
			context:Reply(ARGUMENT_SHORTHANDS)
			context:Reply(TIPS)

			local commands = context.Cmdr.Registry:GetCommands()
			table.sort(commands, function(a, b)
				return if a.Group and b.Group then a.Group < b.Group else a.Group
			end)
			local lastGroup
			for _, command in ipairs(commands) do
				command.Group = command.Group or "No Group"
				if lastGroup ~= command.Group then
					context:Reply(`\n{command.Group}\n{string.rep("-", #command.Group)}`)
					lastGroup = command.Group
				end
				context:Reply(if command.Description then `{command.Name} - {command.Description}` else command.Name)
			end
		end
		return ""
	end;
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000046f</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="221">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BuiltInTypes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000470</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="222">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BindableResource</string>
									<string name="ScriptGuid">{EDD302E0-15B8-43CB-AD3C-8A8036C8A35F}</string>
									<ProtectedString name="Source"><![CDATA[return function (registry)
	registry:RegisterType("bindableResource", registry.Cmdr.Util.MakeEnumType("BindableResource", {"Chat"}))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000471</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="223">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BrickColor</string>
									<string name="ScriptGuid">{A62C02F6-9C98-4591-A0F7-7A58443EE19F}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local brickColorNames = {
    "White", "Grey", "Light yellow", "Brick yellow", "Light green (Mint)", "Light reddish violet", "Pastel Blue",
    "Light orange brown", "Nougat", "Bright red", "Med. reddish violet", "Bright blue", "Bright yellow", "Earth orange",
    "Black", "Dark grey", "Dark green", "Medium green", "Lig. Yellowich orange", "Bright green", "Dark orange",
    "Light bluish violet", "Transparent", "Tr. Red", "Tr. Lg blue", "Tr. Blue", "Tr. Yellow", "Light blue",
    "Tr. Flu. Reddish orange", "Tr. Green", "Tr. Flu. Green", "Phosph. White", "Light red", "Medium red", "Medium blue",
    "Light grey", "Bright violet", "Br. yellowish orange", "Bright orange", "Bright bluish green", "Earth yellow",
    "Bright bluish violet", "Tr. Brown", "Medium bluish violet", "Tr. Medi. reddish violet", "Med. yellowish green",
    "Med. bluish green", "Light bluish green", "Br. yellowish green", "Lig. yellowish green", "Med. yellowish orange",
    "Br. reddish orange", "Bright reddish violet", "Light orange", "Tr. Bright bluish violet", "Gold", "Dark nougat",
    "Silver", "Neon orange", "Neon green", "Sand blue", "Sand violet", "Medium orange", "Sand yellow", "Earth blue",
    "Earth green", "Tr. Flu. Blue", "Sand blue metallic", "Sand violet metallic", "Sand yellow metallic",
    "Dark grey metallic", "Black metallic", "Light grey metallic", "Sand green", "Sand red", "Dark red",
    "Tr. Flu. Yellow", "Tr. Flu. Red", "Gun metallic", "Red flip/flop", "Yellow flip/flop", "Silver flip/flop", "Curry",
    "Fire Yellow", "Flame yellowish orange", "Reddish brown", "Flame reddish orange", "Medium stone grey", "Royal blue",
    "Dark Royal blue", "Bright reddish lilac", "Dark stone grey", "Lemon metalic", "Light stone grey", "Dark Curry",
    "Faded green", "Turquoise", "Light Royal blue", "Medium Royal blue", "Rust", "Brown", "Reddish lilac", "Lilac",
    "Light lilac", "Bright purple", "Light purple", "Light pink", "Light brick yellow", "Warm yellowish orange",
    "Cool yellow", "Dove blue", "Medium lilac", "Slime green", "Smoky grey", "Dark blue", "Parsley green", "Steel blue",
    "Storm blue", "Lapis", "Dark indigo", "Sea green", "Shamrock", "Fossil", "Mulberry", "Forest green", "Cadet blue",
    "Electric blue", "Eggplant", "Moss", "Artichoke", "Sage green", "Ghost grey", "Lilac", "Plum", "Olivine",
    "Laurel green", "Quill grey", "Crimson", "Mint", "Baby blue", "Carnation pink", "Persimmon", "Maroon", "Gold",
    "Daisy orange", "Pearl", "Fog", "Salmon", "Terra Cotta", "Cocoa", "Wheat", "Buttermilk", "Mauve", "Sunrise",
    "Tawny", "Rust", "Cashmere", "Khaki", "Lily white", "Seashell", "Burgundy", "Cork", "Burlap", "Beige", "Oyster",
    "Pine Cone", "Fawn brown", "Hurricane grey", "Cloudy grey", "Linen", "Copper", "Dirt brown", "Bronze", "Flint",
    "Dark taupe", "Burnt Sienna", "Institutional white", "Mid gray", "Really black", "Really red", "Deep orange",
    "Alder", "Dusty Rose", "Olive", "New Yeller", "Really blue", "Navy blue", "Deep blue", "Cyan", "CGA brown",
    "Magenta", "Pink", "Deep orange", "Teal", "Toothpaste", "Lime green", "Camo", "Grime", "Lavender",
    "Pastel light blue", "Pastel orange", "Pastel violet", "Pastel blue-green", "Pastel green", "Pastel yellow",
    "Pastel brown", "Royal purple", "Hot pink"
}

local brickColorFinder = Util.MakeFuzzyFinder(brickColorNames)

local brickColorType =  {
	Prefixes = "% teamColor";

    Transform = function(text)
        local brickColors = {}
        for i, name in pairs(brickColorFinder(text)) do
            brickColors[i] = BrickColor.new(name)
        end
        return brickColors
    end;

    Validate = function(brickColors)
        return #brickColors > 0, "No valid brick colors with that name could be found."
    end;

    Autocomplete = function(brickColors)
        return Util.GetNames(brickColors)
    end;

    Parse = function(brickColors)
        return brickColors[1]
    end;
}

local brickColor3Type = {
	Transform = brickColorType.Transform;
	Validate = brickColorType.Validate;
	Autocomplete = brickColorType.Autocomplete;

	Parse = function(brickColors)
		return brickColors[1].Color
	end;
}

return function(registry)
    registry:RegisterType("brickColor", brickColorType)
	registry:RegisterType("brickColors", Util.MakeListableType(brickColorType, {
		Prefixes = "% teamColors"
	}))

	registry:RegisterType("brickColor3", brickColor3Type)
    registry:RegisterType("brickColor3s", Util.MakeListableType(brickColor3Type))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000472</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="224">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Color3</string>
									<string name="ScriptGuid">{ECFA6B7E-C42B-41AE-A399-35FD0D621434}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local color3Type = Util.MakeSequenceType({
	Prefixes = "# hexColor3 ! brickColor3";
	ValidateEach = function(value, i)
		if value == nil then
			return false, ("Invalid or missing number at position %d in Color3 type."):format(i)
		elseif value < 0 or value > 255 then
			return false, ("Number out of acceptable range 0-255 at position %d in Color3 type."):format(i)
		elseif value % 1 ~= 0 then
			return false, ("Number is not an integer at position %d in Color3 type."):format(i)
		end

		return true
	end;
	TransformEach = tonumber;
	Constructor = Color3.fromRGB;
	Length = 3;
})

local function parseHexDigit(x)
	if #x == 1 then
		x = x .. x
	end

	return tonumber(x, 16)
end

local hexColor3Type = {
	Transform = function(text)
		local r, g, b = text:match("^#?(%x%x?)(%x%x?)(%x%x?)$")
		return Util.Each(parseHexDigit, r, g, b)
	end;

	Validate = function(r, g, b)
		return r ~= nil and g ~= nil and b ~= nil, "Invalid hex color"
	end;

	Parse = function(...)
		return Color3.fromRGB(...)
	end;
}

return function (cmdr)
	cmdr:RegisterType("color3", color3Type)
	cmdr:RegisterType("color3s", Util.MakeListableType(color3Type, {
		Prefixes = "# hexColor3s ! brickColor3s"
	}))

	cmdr:RegisterType("hexColor3", hexColor3Type)
	cmdr:RegisterType("hexColor3s", Util.MakeListableType(hexColor3Type))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000473</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="225">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Command</string>
									<string name="ScriptGuid">{66E1CD92-03C2-42C8-A251-BCBBE1436A05}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local commandType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetCommandNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands > 0, "No command with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("command", commandType)
	cmdr:RegisterType("commands", Util.MakeListableType(commandType))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000474</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="226">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ConditionFunction</string>
									<string name="ScriptGuid">{AE170828-2D32-4A0B-953D-DCCB52419897}</string>
									<ProtectedString name="Source"><![CDATA[return function (registry)
	registry:RegisterType("conditionFunction", registry.Cmdr.Util.MakeEnumType("ConditionFunction", {"startsWith"}))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000475</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="227">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Duration</string>
									<string name="ScriptGuid">{0C2C6BC3-1ABF-4693-9527-D4C5596A0A46}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local unitTable = {
    Years = 31556926,
    Months = 2629744,
    Weeks = 604800,
    Days = 86400,
    Hours = 3600,
    Minutes = 60,
    Seconds = 1
}

local searchKeyTable = {}
for key, _ in pairs(unitTable) do
    table.insert(searchKeyTable, key)
end
local unitFinder = Util.MakeFuzzyFinder(searchKeyTable)

local function stringToSecondDuration(stringDuration)
    -- The duration cannot be null or an empty string.
    if stringDuration == nil or stringDuration == "" then
        return nil
    end
    -- Allow 0 by itself (without a unit) to indicate 0 seconds
    local durationNum = tonumber(stringDuration)
    if durationNum and durationNum == 0 then
        return 0, 0, true
    end
    -- The duration must end with a unit,
    -- if it doesn't then return true as the fourth value to indicate the need to offer autocomplete for units.
    local endOnlyString = stringDuration:gsub("-?%d+%a+", "")
    local endNumber = endOnlyString:match("-?%d+")
    if endNumber then
        return nil, tonumber(endNumber), true
    end
    local seconds = nil
    local rawNum, rawUnit
    for rawComponent in stringDuration:gmatch("-?%d+%a+") do
        rawNum, rawUnit = rawComponent:match("(-?%d+)(%a+)")
        local unitNames = unitFinder(rawUnit)
        -- There were no matching units, it's invalid. Return the parsed number to be used for autocomplete
        if #unitNames == 0 then
            return nil, tonumber(rawNum)
        end
        if seconds == nil then seconds = 0 end
        -- While it was already defaulting to use minutes when using just "m", this does it without worrying
        -- about any consistency between list ordering.
        seconds = seconds + (rawUnit:lower() == "m" and 60 or unitTable[unitNames[1]]) * tonumber(rawNum)
    end
    -- If no durations were provided, return nil.
    if seconds == nil then
        return nil
    else
        return seconds, tonumber(rawNum)
    end
end

local function mapUnits(units, rawText, lastNumber, subStart)
    subStart = subStart or 1
    local returnTable = {}
    for i, unit in pairs(units) do
        if lastNumber == 1 then
            returnTable[i] = rawText .. unit:sub(subStart, #unit - 1)
        else
            returnTable[i] = rawText .. unit:sub(subStart)
        end
    end
    return returnTable
end

local durationType = {
    Transform = function(text)
        return text, stringToSecondDuration(text)
    end;

    Validate = function(_, duration)
        return duration ~= nil
    end;

    Autocomplete = function(rawText, duration, lastNumber, isUnitMissing, matchedUnits)
        local returnTable = {}
        if isUnitMissing or matchedUnits then
            local unitsTable = isUnitMissing == true and unitFinder("") or matchedUnits
            if isUnitMissing == true then
                -- Concat the entire unit name to existing text.
                returnTable = mapUnits(unitsTable, rawText, lastNumber)
            else
                -- Concat the rest of the unit based on what already exists of the unit name.
                local existingUnitLength = rawText:match("^.*(%a+)$"):len()
                returnTable = mapUnits(unitsTable, rawText, existingUnitLength + 1)
            end
        elseif duration ~= nil then
            local endingUnit = rawText:match("^.*-?%d+(%a+)%s?$")
            -- Assume there is a singular match at this point
            local fuzzyUnits = unitFinder(endingUnit)
            -- List all possible fuzzy matches. This is for the Minutes/Months ambiguity case.
            returnTable = mapUnits(fuzzyUnits, rawText, lastNumber, #endingUnit + 1)
            -- Sort alphabetically in the Minutes/Months case, so Minutes are displayed on top.
            table.sort(returnTable)
        end
        return returnTable
    end;

    Parse = function(_, duration)
        return duration
    end;
}

return function(registry)
    registry:RegisterType("duration", durationType)
    registry:RegisterType("durations", Util.MakeListableType(durationType))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000476</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="228">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">JSON</string>
									<string name="ScriptGuid">{A033F3CA-56DA-4BB8-A016-8A2B0FB192E7}</string>
									<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

return function(registry)
	registry:RegisterType("json", {
		Validate = function(text)
			return pcall(HttpService.JSONDecode, HttpService, text)
		end;

		Parse = function(text)
			return HttpService:JSONDecode(text)
		end
	})
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000477</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="229">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MathOperator</string>
									<string name="ScriptGuid">{43812A64-41BA-42D8-98B8-91C304F3C71D}</string>
									<ProtectedString name="Source"><![CDATA[return function(registry)
	registry:RegisterType("mathOperator", registry.Cmdr.Util.MakeEnumType("Math Operator", {
		{
			Name = "+";
			Perform = function(a, b)
				return a + b
			end
		};
		{
			Name = "-";
			Perform = function(a, b)
				return a - b
			end
		};
		{
			Name = "*";
			Perform = function(a, b)
				return a * b
			end
		};
		{
			Name = "/";
			Perform = function(a, b)
				return a / b
			end
		};
		{
			Name = "**";
			Perform = function(a, b)
				return a ^ b
			end
		};
		{
			Name = "%";
			Perform = function(a, b)
				return a % b
			end
		}
	}))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000478</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="230">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Player</string>
									<string name="ScriptGuid">{8DD561F0-1D0B-4EC5-8490-EED6260A80CD}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local playerType = {
	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return findPlayer(text)
	end;

	Validate = function (players)
		return #players > 0, "No player with that name could be found."
	end;

	Autocomplete = function (players)
		return Util.GetNames(players)
	end;

	Parse = function (players)
		return players[1]
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("player", playerType)
	cmdr:RegisterType("players", Util.MakeListableType(playerType, {
		Prefixes = "% teamPlayers";
	}))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000479</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="231">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">PlayerId</string>
									<string name="ScriptGuid">{5368D65A-A2AA-4646-98E5-E541459B8AA8}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)
local Players = game:GetService("Players")

local nameCache = {}
local function getUserId(name)
	if nameCache[name] then
		return nameCache[name]
	elseif Players:FindFirstChild(name) then
		nameCache[name] = Players[name].UserId
		return Players[name].UserId
	else
		local ok, userid = pcall(Players.GetUserIdFromNameAsync, Players, name)

		if not ok then
			return nil
		end

		nameCache[name] = userid
		return userid
	end
end

local playerIdType = {
	DisplayName = "Full Player Name";
	Prefixes = "# integer";

	Transform = function (text)
		local findPlayer = Util.MakeFuzzyFinder(Players:GetPlayers())

		return text, findPlayer(text)
	end;

	ValidateOnce = function (text)
		return getUserId(text) ~= nil, "No player with that name could be found."
	end;

	Autocomplete = function (_, players)
		return Util.GetNames(players)
	end;

	Parse = function (text)
		return getUserId(text)
	end;

	Default = function(player)
		return player.Name
	end;

	ArgumentOperatorAliases = {
		me = ".";
		all = "*";
		others = "**";
		random = "?";
	};
}

return function (cmdr)
	cmdr:RegisterType("playerId", playerIdType)
	cmdr:RegisterType("playerIds", Util.MakeListableType(playerIdType, {
		Prefixes = "# integers"
	}))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="232">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Primitives</string>
									<string name="ScriptGuid">{A7D75D68-C933-490F-9FB8-FF56E369F968}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local stringType = {
	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return tostring(value)
	end;
}

local numberType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil
	end;

	Parse = function (value)
		return value
	end;
}

local intType = {
	Transform = function (text)
		return tonumber(text)
	end;

	Validate = function (value)
		return value ~= nil and value == math.floor(value), "Only whole numbers are valid."
	end;

	Parse = function (value)
		return value
	end
}

local positiveIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value > 0, "Only positive whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local nonNegativeIntType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0, "Only non-negative whole numbers are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local byteType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 255, "Only bytes are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local digitType = {
	Transform = function (text)
		return tonumber(text)
	end,

	Validate = function (value)
		return value ~= nil and value == math.floor(value) and value >= 0 and value <= 9, "Only digits are valid."
	end,

	Parse = function (value)
		return value
	end,
}

local boolType do
	local truthy = Util.MakeDictionary({"true", "t", "yes", "y", "on", "enable", "enabled", "1", "+"});
	local falsy = Util.MakeDictionary({"false"; "f"; "no"; "n"; "off"; "disable"; "disabled"; "0"; "-"});

	boolType = {
		Transform = function (text)
			return text:lower()
		end;

		Validate = function (value)
			return truthy[value] ~= nil or falsy[value] ~= nil, "Please use true/yes/on or false/no/off."
		end;

		Parse = function (value)
			if truthy[value] then
				return true
			elseif falsy[value] then
				return false
			else
				return nil
			end
		end;
	}
end

return function (cmdr)
	cmdr:RegisterType("string", stringType)
	cmdr:RegisterType("number", numberType)
	cmdr:RegisterType("integer", intType)
	cmdr:RegisterType("positiveInteger", positiveIntType)
	cmdr:RegisterType("nonNegativeInteger", nonNegativeIntType)
	cmdr:RegisterType("byte", byteType)
	cmdr:RegisterType("digit", digitType)
	cmdr:RegisterType("boolean", boolType)

	cmdr:RegisterType("strings", Util.MakeListableType(stringType))
	cmdr:RegisterType("numbers", Util.MakeListableType(numberType))
	cmdr:RegisterType("integers", Util.MakeListableType(intType))
	cmdr:RegisterType("positiveIntegers", Util.MakeListableType(positiveIntType))
	cmdr:RegisterType("nonNegativeIntegers", Util.MakeListableType(nonNegativeIntType))
	cmdr:RegisterType("bytes", Util.MakeListableType(byteType))
	cmdr:RegisterType("digits", Util.MakeListableType(digitType))
	cmdr:RegisterType("booleans", Util.MakeListableType(boolType))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="233">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">StoredKey</string>
									<string name="ScriptGuid">{1ED93575-3A0E-4EFB-AB2A-585CA00FEA84}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local VALID_STORED_KEY_NAME_PATTERNS = {
	"^%a[%w_]*$",
	"^%$%a[%w_]*$",
	"^%.%a[%w_]*$",
	"^%$%.%a[%w_]*$",
}

return function (registry)
	local storedKeyType = {
		Autocomplete = function(text)
			local find = registry.Cmdr.Util.MakeFuzzyFinder(registry.Cmdr.Util.DictionaryKeys(registry:GetStore("vars_used") or {}))

			return find(text)
		end;

		Validate = function(text)
			for _, pattern in ipairs(VALID_STORED_KEY_NAME_PATTERNS) do
				if text:match(pattern) then
					return true
				end
			end

			return false, "Key names must start with an optional modifier: . $ or $. and must begin with a letter."
		end;

		Parse = function(text)
			return text
		end;
	}
	registry:RegisterType("storedKey", storedKeyType)
	registry:RegisterType("storedKeys", Util.MakeListableType(storedKeyType))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="234">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Team</string>
									<string name="ScriptGuid">{38841F06-41E0-4CEC-8011-3A6F18FC921E}</string>
									<ProtectedString name="Source"><![CDATA[local Teams = game:GetService("Teams")
local Util = require(script.Parent.Parent.Shared.Util)

local teamType = {
	Transform = function (text)
		local findTeam = Util.MakeFuzzyFinder(Teams:GetTeams())

		return findTeam(text)
	end;

	Validate = function (teams)
		return #teams > 0, "No team with that name could be found."
	end;

	Autocomplete = function (teams)
		return Util.GetNames(teams)
	end;

	Parse = function (teams)
		return teams[1];
	end;
}

local teamPlayersType = {
	Listable = true;
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1]:GetPlayers()
	end;
}

local teamColorType = {
	Transform = teamType.Transform;
	Validate = teamType.Validate;
	Autocomplete = teamType.Autocomplete;

	Parse = function (teams)
		return teams[1].TeamColor
	end;
}

return function (cmdr)
	cmdr:RegisterType("team", teamType)
	cmdr:RegisterType("teams", Util.MakeListableType(teamType))

	cmdr:RegisterType("teamPlayers", teamPlayersType)

	cmdr:RegisterType("teamColor", teamColorType)
	cmdr:RegisterType("teamColors", Util.MakeListableType(teamColorType))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="235">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Type</string>
									<string name="ScriptGuid">{416FC6B8-AA48-446F-97E7-E98747B91A10}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

return function (cmdr)
	local typeType = {
		Transform = function (text)
			local findCommand = Util.MakeFuzzyFinder(cmdr:GetTypeNames())

			return findCommand(text)
		end;

		Validate = function (commands)
			return #commands > 0, "No type with that name could be found."
		end;

		Autocomplete = function (commands)
			return commands
		end;

		Parse = function (commands)
			return commands[1]
		end;
	}

	cmdr:RegisterType("type", typeType)
	cmdr:RegisterType("types", Util.MakeListableType(typeType))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="236">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">URL</string>
									<string name="ScriptGuid">{4BC34FFF-91D6-4180-8006-DAE7774D59A6}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local storedKeyType = {
	Validate = function(text)
		if text:match("^https?://.+$") then
			return true
		end

		return false, "URLs must begin with http:// or https://"
	end;

	Parse = function(text)
		return text
	end;
}

return function (cmdr)
	cmdr:RegisterType("url", storedKeyType)
	cmdr:RegisterType("urls", Util.MakeListableType(storedKeyType))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000047f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="237">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">UserInput</string>
									<string name="ScriptGuid">{6E51D0A1-3603-415B-85D1-FCCD60EB47BD}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local combinedInputEnums = Enum.UserInputType:GetEnumItems()

for _, e in pairs(Enum.KeyCode:GetEnumItems()) do
	combinedInputEnums[#combinedInputEnums + 1] = e
end

local userInputType = {
	Transform = function (text)
		local findEnum = Util.MakeFuzzyFinder(combinedInputEnums)

		return findEnum(text)
	end;

	Validate = function (enums)
		return #enums > 0
	end;

	Autocomplete = function (enums)
		return Util.GetNames(enums)
	end;

	Parse = function (enums)
		return enums[1];
	end;
}

return function (cmdr)
	cmdr:RegisterType("userInput", userInputType)
	cmdr:RegisterType("userInputs", Util.MakeListableType(userInputType))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000480</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="238">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Vector</string>
									<string name="ScriptGuid">{3987A753-0046-48C2-BE67-DEDBCBCBF0D2}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Parent.Shared.Util)

local function validateVector(value, i)
	if value == nil then
		return false, ("Invalid or missing number at position %d in Vector type."):format(i)
	end

	return true
end

local vector3Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector3.new;
	Length = 3;
})

local vector2Type = Util.MakeSequenceType({
	ValidateEach = validateVector;
	TransformEach = tonumber;
	Constructor = Vector2.new;
	Length = 2;
})

return function (cmdr)
	cmdr:RegisterType("vector3", vector3Type)
	cmdr:RegisterType("vector3s", Util.MakeListableType(vector3Type))

	cmdr:RegisterType("vector2", vector2Type)
	cmdr:RegisterType("vector2s", Util.MakeListableType(vector2Type))
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000481</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="239">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CmdrClient</string>
								<string name="ScriptGuid">{2B6F3D88-D321-4818-8494-4709D1DEBF50}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local Shared = script:WaitForChild("Shared")
local Util = require(Shared:WaitForChild("Util"))

if RunService:IsClient() == false then
	error("Server scripts cannot require the client library. Please require the server library to use Cmdr in your own code.")
end

local Cmdr do
	Cmdr = setmetatable({
		ReplicatedRoot = script;
		RemoteFunction = script:WaitForChild("CmdrFunction");
		RemoteEvent = script:WaitForChild("CmdrEvent");
		ActivationKeys = {[Enum.KeyCode.F2] = true};
		Enabled = true;
		MashToEnable = false;
		ActivationUnlocksMouse = false;
		HideOnLostFocus = true;
		PlaceName = "Cmdr";
		Util = Util;
		Events = {};
	}, {
		-- This sucks, and may be redone or removed
		-- Proxies dispatch methods on to main Cmdr object
		__index = function (self, k)
			local r = self.Dispatcher[k]
			if r and type(r) == "function" then
				return function (_, ...)
					return r(self.Dispatcher, ...)
				end
			end
		end
	})

	Cmdr.Registry = require(Shared.Registry)(Cmdr)
	Cmdr.Dispatcher = require(Shared.Dispatcher)(Cmdr)
end

if StarterGui:WaitForChild("Cmdr") and wait() and Player:WaitForChild("PlayerGui"):FindFirstChild("Cmdr") == nil then
	StarterGui.Cmdr:Clone().Parent = Player.PlayerGui
end

local Interface = require(script.CmdrInterface)(Cmdr)

--- Sets a list of keyboard keys (Enum.KeyCode) that can be used to open the commands menu
function Cmdr:SetActivationKeys (keysArray)
	self.ActivationKeys = Util.MakeDictionary(keysArray)
end

--- Sets the place name label on the interface
function Cmdr:SetPlaceName (name)
	self.PlaceName = name
	Interface.Window:UpdateLabel()
end

--- Sets whether or not the console is enabled
function Cmdr:SetEnabled (enabled)
	self.Enabled = enabled
end

--- Sets if activation will free the mouse.
function Cmdr:SetActivationUnlocksMouse (enabled)
	self.ActivationUnlocksMouse = enabled
end

--- Shows Cmdr window
function Cmdr:Show ()
	if not self.Enabled then
		return
	end

	Interface.Window:Show()
end

--- Hides Cmdr window
function Cmdr:Hide ()
	Interface.Window:Hide()
end

--- Toggles Cmdr window
function Cmdr:Toggle ()
	if not self.Enabled then
		return self:Hide()
	end

	Interface.Window:SetVisible(not Interface.Window:IsVisible())
end

--- Enables the "Mash to open" feature
function Cmdr:SetMashToEnable(isEnabled)
	self.MashToEnable = isEnabled

	if isEnabled then
		self:SetEnabled(false)
	end
end

--- Sets the hide on 'lost focus' feature.
function Cmdr:SetHideOnLostFocus(enabled)
	self.HideOnLostFocus = enabled
end

--- Sets the handler for a certain event type
function Cmdr:HandleEvent(name, callback)
	self.Events[name] = callback
end

-- Only register when we aren't in studio because don't want to overwrite what the server portion did
if RunService:IsServer() == false then
	Cmdr.Registry:RegisterTypesIn(script:WaitForChild("Types"))
	Cmdr.Registry:RegisterCommandsIn(script:WaitForChild("Commands"))
end

-- Hook up event listener
Cmdr.RemoteEvent.OnClientEvent:Connect(function(name, ...)
	if Cmdr.Events[name] then
		Cmdr.Events[name](...)
	end
end)

require(script.DefaultEventHandlers)(Cmdr)

return Cmdr
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000482</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="240">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CmdrInterface</string>
									<string name="ScriptGuid">{D83D2A82-391B-472E-A05B-B7591466AAC0}</string>
									<ProtectedString name="Source"><![CDATA[-- Here be dragons

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function (Cmdr)
	local Util = Cmdr.Util

	local Window = require(script:WaitForChild("Window"))
	Window.Cmdr = Cmdr

	local AutoComplete = require(script:WaitForChild("AutoComplete"))(Cmdr)
	Window.AutoComplete = AutoComplete


	-- Sets the Window.ProcessEntry callback so that we can dispatch our commands out
	function Window.ProcessEntry(text)
		text = Util.TrimString(text)

		if #text == 0 then return end

		Window:AddLine(Window:GetLabel() .. " " .. text, Color3.fromRGB(255, 223, 93))

		Window:AddLine(Cmdr.Dispatcher:EvaluateAndRun(text, Player, {
			IsHuman = true
		}))
	end

	-- Sets the Window.OnTextChanged callback so we can update the auto complete
	function Window.OnTextChanged (text)
		local command = Cmdr.Dispatcher:Evaluate(text, Player, true)
		local arguments = Util.SplitString(text)
		local commandText = table.remove(arguments, 1)
		local atEnd = false
		if command then
			arguments = Util.MashExcessArguments(arguments, #command.Object.Args)

			atEnd = #arguments == #command.Object.Args
		end

		local entryComplete = commandText and #arguments > 0

		if text:sub(#text, #text):match("%s") and not atEnd then
			entryComplete = true
			arguments[#arguments + 1] = ""
		end

		if command and entryComplete then
			local commandValid, errorText = command:Validate()

			Window:SetIsValidInput(commandValid, ("Validation errors: %s"):format(errorText or ""))

			local acItems = {}

			local lastArgument = command:GetArgument(#arguments)
			if lastArgument then
				local typedText = lastArgument.TextSegmentInProgress

				local isPartial = false
				if lastArgument.RawSegmentsAreAutocomplete then
					for i, segment in ipairs(lastArgument.RawSegments) do
						acItems[i] = {segment, segment}
					end
				else
					local items, options = lastArgument:GetAutocomplete()
					options = options or {}
					isPartial = options.IsPartial or false

					for i, item in pairs(items) do
						acItems[i] = {typedText, item}
					end
				end

				local valid = true

				if #typedText > 0 then
					valid, errorText = lastArgument:Validate()
				end

				if not atEnd and valid then
					Window:HideInvalidState()
				end

				return AutoComplete:Show(acItems, {
					at = atEnd and #text - #typedText + (text:sub(#text, #text):match("%s") and -1 or 0);
					prefix = #lastArgument.RawSegments == 1 and lastArgument.Prefix or "";
					isLast = #command.Arguments == #command.ArgumentDefinitions and #typedText > 0;
					numArgs = #arguments;
					command = command;
					arg = lastArgument;
					name = lastArgument.Name .. (lastArgument.Required and "" or "?");
					type = lastArgument.Type.DisplayName;
					description = (valid == false and errorText) or lastArgument.Object.Description;
					invalid = not valid;
					isPartial = isPartial;
				})
			end
		elseif commandText and #arguments == 0 then
			Window:SetIsValidInput(true)
			local exactCommand = Cmdr.Registry:GetCommand(commandText)
			local exactMatch
			if exactCommand then
				exactMatch = {exactCommand.Name, exactCommand.Name, options = {
					name = exactCommand.Name;
					description = exactCommand.Description;
				}}

				local arg = exactCommand.Args and exactCommand.Args[1]

				if type(arg) == "function" then
					arg = arg(command)
				end

				if
					arg
					and (not arg.Optional
					and arg.Default == nil)
				then
					Window:SetIsValidInput(false, "This command has required arguments.")
					Window:HideInvalidState()
				end
			else
				Window:SetIsValidInput(false, ("%q is not a valid command name. Use the help command to see all available commands."):format(commandText))
			end

			local acItems = {exactMatch}
			for _, cmd in pairs(Cmdr.Registry:GetCommandNames()) do
				if commandText:lower() == cmd:lower():sub(1, #commandText) and (exactMatch == nil or exactMatch[1] ~= commandText) then
					local commandObject = Cmdr.Registry:GetCommand(cmd)
					acItems[#acItems + 1] = {commandText, cmd, options = {
						name = commandObject.Name;
						description = commandObject.Description;
					}}
				end
			end

			return AutoComplete:Show(acItems)
		end

		Window:SetIsValidInput(false, "Use the help command to see all available commands.")
		AutoComplete:Hide()
	end

	Window:UpdateLabel()
	Window:UpdateWindowHeight()

	return {
		Window = Window;
		AutoComplete = AutoComplete;
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000483</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="241">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">AutoComplete</string>
										<string name="ScriptGuid">{D06562A4-7243-4E93-B102-9F8C260273B2}</string>
										<ProtectedString name="Source"><![CDATA[-- luacheck: ignore 212
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

return function(Cmdr)
	local AutoComplete = {
		Items = {},
		ItemOptions = {},
		SelectedItem = 0,
	}

	local Util = Cmdr.Util

	local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Autocomplete")
	local AutoItem = Gui:WaitForChild("TextButton")
	local Title = Gui:WaitForChild("Title")
	local Description = Gui:WaitForChild("Description")
	local Entry = Gui.Parent:WaitForChild("Frame"):WaitForChild("Entry")
	AutoItem.Parent = nil

	local defaultBarThickness = Gui.ScrollBarThickness

	-- Helper function that sets text and resizes labels
	local function SetText(obj, textObj, text, sizeFromContents)
		obj.Visible = text ~= nil
		textObj.Text = text or ""

		if sizeFromContents then
			textObj.Size = UDim2.new(
				0,
				Util.GetTextSize(text or "", textObj, Vector2.new(1000, 1000), 1, 0).X,
				obj.Size.Y.Scale,
				obj.Size.Y.Offset
			)
		end
	end

	local function UpdateContainerSize()
		Gui.Size = UDim2.new(
			0,
			math.max(Title.Field.TextBounds.X + Title.Field.Type.TextBounds.X, Gui.Size.X.Offset),
			0,
			math.min(Gui.UIListLayout.AbsoluteContentSize.Y, Gui.Parent.AbsoluteSize.Y - Gui.AbsolutePosition.Y - 10)
		)
	end

	-- Update the info display (Name, type, and description) based on given options.
	local function UpdateInfoDisplay(options)
		-- Update the objects' text and sizes
		SetText(Title, Title.Field, options.name, true)
		SetText(
			Title.Field.Type,
			Title.Field.Type,
			options.type and ": " .. options.type:sub(1, 1):upper() .. options.type:sub(2)
		)
		SetText(Description, Description.Label, options.description)

		Description.Label.TextColor3 = options.invalid and Color3.fromRGB(255, 73, 73) or Color3.fromRGB(255, 255, 255)
		Description.Size = UDim2.new(1, 0, 0, 40)

		-- Flow description text
		while not Description.Label.TextFits do
			Description.Size = Description.Size + UDim2.new(0, 0, 0, 2)

			if Description.Size.Y.Offset > 500 then
				break
			end
		end

		-- Update container
		task.wait()
		Gui.UIListLayout:ApplyLayout()
		UpdateContainerSize()
		Gui.ScrollBarThickness = defaultBarThickness
	end

	--- Shows the auto complete menu with the given list and possible options
	-- item = {typedText, suggestedText, options?=options}
	-- The options table is optional. `at` should only be passed into AutoComplete::Show
	-- name, type, and description may be passed in an options dictionary inside the items as well
	-- options.at?: the character index at which to show the menu
	-- options.name?: The name to display in the info box
	-- options.type?: The type to display in the info box
	-- options.prefix?: The current type prefix (%Team)
	-- options.description?: The description for the currently active info box
	-- options.invalid?: If true, description is shown in red.
	-- options.isLast?: If true, auto complete won't keep going after this argument.
	function AutoComplete:Show(items, options)
		options = options or {}

		-- Remove old options.
		for _, item in pairs(self.Items) do
			if item.gui then
				item.gui:Destroy()
			end
		end

		-- Reset state
		self.SelectedItem = 1
		self.Items = items
		self.Prefix = options.prefix or ""
		self.LastItem = options.isLast or false
		self.Command = options.command
		self.Arg = options.arg
		self.NumArgs = options.numArgs
		self.IsPartial = options.isPartial

		-- Generate the new option labels
		local autocompleteWidth = 200

		Gui.ScrollBarThickness = 0

		for i, item in pairs(self.Items) do
			local leftText = item[1]
			local rightText = item[2]

			local btn = AutoItem:Clone()
			btn.Name = leftText .. rightText
			btn.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1

			local start, stop = string.find(rightText:lower(), leftText:lower(), 1, true)
			btn.Typed.Text = string.rep(" ", start - 1) .. leftText
			btn.Suggest.Text = string.sub(rightText, 0, start - 1)
				.. string.rep(" ", #leftText)
				.. string.sub(rightText, stop + 1)


			btn.Parent = Gui
			btn.LayoutOrder = i

			local maxBounds = math.max(btn.Typed.TextBounds.X, btn.Suggest.TextBounds.X) + 20
			if maxBounds > autocompleteWidth then
				autocompleteWidth = maxBounds
			end

			item.gui = btn
		end

		Gui.UIListLayout:ApplyLayout()

		-- Todo: Use TextService to find accurate position for auto complete box
		local text = Entry.TextBox.Text
		local words = Util.SplitString(text)
		if text:sub(#text, #text) == " " and not options.at then
			words[#words + 1] = "e"
		end
		table.remove(words, #words)
		local extra = (options.at and options.at or (#table.concat(words, " ") + 1)) * 7

		-- Update the auto complete container
		Gui.Position =
			UDim2.new(0, Entry.TextBox.AbsolutePosition.X - 10 + extra, 0, Entry.TextBox.AbsolutePosition.Y + 30)
		Gui.Size = UDim2.new(0, autocompleteWidth, 0, Gui.UIListLayout.AbsoluteContentSize.Y)
		Gui.Visible = true

		-- Finally, update thge info display
		UpdateInfoDisplay(self.Items[1] and self.Items[1].options or options)
	end

	--- Returns the selected item in the auto complete
	function AutoComplete:GetSelectedItem()
		if Gui.Visible == false then
			return nil
		end

		return AutoComplete.Items[AutoComplete.SelectedItem]
	end

	--- Hides the auto complete
	function AutoComplete:Hide()
		Gui.Visible = false
	end

	--- Returns if the menu is visible
	function AutoComplete:IsVisible()
		return Gui.Visible
	end

	--- Changes the user's item selection by the given delta
	function AutoComplete:Select(delta)
		if not Gui.Visible then
			return
		end

		self.SelectedItem = self.SelectedItem + delta

		if self.SelectedItem > #self.Items then
			self.SelectedItem = 1
		elseif self.SelectedItem < 1 then
			self.SelectedItem = #self.Items
		end

		for i, item in pairs(self.Items) do
			item.gui.BackgroundTransparency = i == self.SelectedItem and 0.5 or 1
		end

		Gui.CanvasPosition = Vector2.new(
			0,
			math.max(
				0,
				Title.Size.Y.Offset
					+ Description.Size.Y.Offset
					+ self.SelectedItem * AutoItem.Size.Y.Offset
					- Gui.Size.Y.Offset
			)
		)

		if self.Items[self.SelectedItem] and self.Items[self.SelectedItem].options then
			UpdateInfoDisplay(self.Items[self.SelectedItem].options or {})
		end
	end

	Gui.Parent:GetPropertyChangedSignal("AbsoluteSize"):Connect(UpdateContainerSize)

	return AutoComplete
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000484</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="242">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Window</string>
										<string name="ScriptGuid">{B62C8708-359F-4F80-B721-7F9C2B9152CD}</string>
										<ProtectedString name="Source"><![CDATA[-- Here be dragons
-- luacheck: ignore 212
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local TextChatService = game:GetService("TextChatService")
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local WINDOW_MAX_HEIGHT = 300
local MOUSE_TOUCH_ENUM = { Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.Touch }

--- Window handles the command bar GUI
local Window = {
	Valid = true,
	AutoComplete = nil,
	ProcessEntry = nil,
	OnTextChanged = nil,
	Cmdr = nil,
	HistoryState = nil,
}

local Gui = Player:WaitForChild("PlayerGui"):WaitForChild("Cmdr"):WaitForChild("Frame")
local Line = Gui:WaitForChild("Line")
local Entry = Gui:WaitForChild("Entry")

Line.Parent = nil

--- Update the text entry label
function Window:UpdateLabel()
	Entry.TextLabel.Text = Player.Name .. "@" .. self.Cmdr.PlaceName .. "$"
end

--- Get the text entry label
function Window:GetLabel()
	return Entry.TextLabel.Text
end

--- Recalculate the window height
function Window:UpdateWindowHeight()
	local windowHeight = Gui.UIListLayout.AbsoluteContentSize.Y
		+ Gui.UIPadding.PaddingTop.Offset
		+ Gui.UIPadding.PaddingBottom.Offset
	Gui.Size = UDim2.new(Gui.Size.X.Scale, Gui.Size.X.Offset, 0, math.clamp(windowHeight, 0, WINDOW_MAX_HEIGHT))
	Gui.CanvasPosition = Vector2.new(0, windowHeight)
end

--- Add a line to the command bar
function Window:AddLine(text, options)
	options = options or {}
	text = tostring(text)

	if typeof(options) == "Color3" then
		options = { Color = options }
	end

	if #text == 0 then
		Window:UpdateWindowHeight()
		return
	end

	local str = self.Cmdr.Util.EmulateTabstops(text or "nil", 8)

	local line = Line:Clone()
	line.Text = str
	line.TextColor3 = options.Color or line.TextColor3
	line.RichText = options.RichText or false
	line.Parent = Gui
end

--- Returns if the command bar is visible
function Window:IsVisible()
	return Gui.Visible
end

--- Sets the command bar visible or not
function Window:SetVisible(visible)
	Gui.Visible = visible

	if visible then
		self.PreviousChatWindowConfigurationEnabled = TextChatService.ChatWindowConfiguration.Enabled
		self.PreviousChatInputBarConfigurationEnabled = TextChatService.ChatInputBarConfiguration.Enabled
		TextChatService.ChatWindowConfiguration.Enabled = false
		TextChatService.ChatInputBarConfiguration.Enabled = false

		Entry.TextBox:CaptureFocus()
		self:SetEntryText("")

		if self.Cmdr.ActivationUnlocksMouse then
			self.PreviousMouseBehavior = UserInputService.MouseBehavior
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	else
		TextChatService.ChatWindowConfiguration.Enabled = if self.PreviousChatWindowConfigurationEnabled ~= nil then 
			self.PreviousChatWindowConfigurationEnabled else true
		TextChatService.ChatInputBarConfiguration.Enabled = if self.PreviousChatInputBarConfigurationEnabled ~= nil then 
			self.PreviousChatInputBarConfigurationEnabled else true

		Entry.TextBox:ReleaseFocus()
		self.AutoComplete:Hide()

		if self.PreviousMouseBehavior then
			UserInputService.MouseBehavior = self.PreviousMouseBehavior
			self.PreviousMouseBehavior = nil
		end
	end
end

--- Hides the command bar
function Window:Hide()
	return self:SetVisible(false)
end

--- Shows the command bar
function Window:Show()
	return self:SetVisible(true)
end

--- Sets the text in the command bar text box, and captures focus
function Window:SetEntryText(text)
	Entry.TextBox.Text = text

	if self:IsVisible() then
		Entry.TextBox:CaptureFocus()
		Entry.TextBox.CursorPosition = #text + 1
		Window:UpdateWindowHeight()
	end
end

--- Gets the text in the command bar text box
function Window:GetEntryText()
	return Entry.TextBox.Text:gsub("\t", "")
end

--- Sets whether the command is in a valid state or not.
-- Cannot submit if in invalid state.
function Window:SetIsValidInput(isValid, errorText)
	Entry.TextBox.TextColor3 = isValid and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 73, 73)
	self.Valid = isValid
	self._errorText = errorText
end

function Window:HideInvalidState()
	Entry.TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
end

--- Event handler for text box focus lost
function Window:LoseFocus(submit)
	local text = Entry.TextBox.Text

	self:ClearHistoryState()

	if Gui.Visible and not GuiService.MenuIsOpen then
		-- self:SetEntryText("")
		Entry.TextBox:CaptureFocus()
	elseif GuiService.MenuIsOpen and Gui.Visible then
		self:Hide()
	end

	if submit and self.Valid then
		wait()
		self:SetEntryText("")
		self.ProcessEntry(text)
	elseif submit then
		self:AddLine(self._errorText, Color3.fromRGB(255, 153, 153))
	end
end

function Window:TraverseHistory(delta)
	local history = self.Cmdr.Dispatcher:GetHistory()

	if self.HistoryState == nil then
		self.HistoryState = {
			Position = #history + 1,
			InitialText = self:GetEntryText(),
		}
	end

	self.HistoryState.Position = math.clamp(self.HistoryState.Position + delta, 1, #history + 1)

	self:SetEntryText(
		self.HistoryState.Position == #history + 1 and self.HistoryState.InitialText
			or history[self.HistoryState.Position]
	)
end

function Window:ClearHistoryState()
	self.HistoryState = nil
end

function Window:SelectVertical(delta)
	if self.AutoComplete:IsVisible() and not self.HistoryState then
		self.AutoComplete:Select(delta)
	else
		self:TraverseHistory(delta)
	end
end

local lastPressTime = 0
local pressCount = 0
--- Handles user input when the box is focused
function Window:BeginInput(input, gameProcessed)
	if GuiService.MenuIsOpen then
		self:Hide()
	end

	if gameProcessed and self:IsVisible() == false then
		return
	end

	if self.Cmdr.ActivationKeys[input.KeyCode] then -- Activate the command bar
		if self.Cmdr.MashToEnable and not self.Cmdr.Enabled then
			if tick() - lastPressTime < 1 then
				if pressCount >= 5 then
					return self.Cmdr:SetEnabled(true)
				else
					pressCount = pressCount + 1
				end
			else
				pressCount = 1
			end
			lastPressTime = tick()
		elseif self.Cmdr.Enabled then
			self:SetVisible(not self:IsVisible())
			wait()
			self:SetEntryText("")

			if GuiService.MenuIsOpen then -- Special case for menu getting stuck open (roblox bug)
				self:Hide()
			end
		end

		return
	end

	if self.Cmdr.Enabled == false or not self:IsVisible() then
		if self:IsVisible() then
			self:Hide()
		end

		return
	end

	if self.Cmdr.HideOnLostFocus and table.find(MOUSE_TOUCH_ENUM, input.UserInputType) then
		local ps = input.Position
		local ap = Gui.AbsolutePosition
		local as = Gui.AbsoluteSize
		if ps.X < ap.X or ps.X > ap.X + as.X or ps.Y < ap.Y or ps.Y > ap.Y + as.Y then
			self:Hide()
		end
	elseif input.KeyCode == Enum.KeyCode.Down then -- Auto Complete Down
		self:SelectVertical(1)
	elseif input.KeyCode == Enum.KeyCode.Up then -- Auto Complete Up
		self:SelectVertical(-1)
	elseif input.KeyCode == Enum.KeyCode.Return then -- Eat new lines
		wait()
		self:SetEntryText(self:GetEntryText():gsub("\n", ""):gsub("\r", ""))
	elseif input.KeyCode == Enum.KeyCode.Tab then -- Auto complete
		local item = self.AutoComplete:GetSelectedItem()
		local text = self:GetEntryText()
		if item and not (text:sub(#text, #text):match("%s") and self.AutoComplete.LastItem) then
			local replace = item[2]
			local newText
			local insertSpace = true
			local command = self.AutoComplete.Command

			if command then
				local lastArg = self.AutoComplete.Arg

				newText = command.Alias
				insertSpace = self.AutoComplete.NumArgs ~= #command.ArgumentDefinitions
					and self.AutoComplete.IsPartial == false

				local args = command.Arguments
				for i = 1, #args do
					local arg = args[i]
					local segments = arg.RawSegments
					if arg == lastArg then
						segments[#segments] = replace
					end

					local argText = arg.Prefix .. table.concat(segments, ",")

					-- Put auto completion options in quotation marks if they have a space
					if argText:find(" ") or argText == "" then
						argText = ("%q"):format(argText)
					end

					newText = ("%s %s"):format(newText, argText)

					if arg == lastArg then
						break
					end
				end
			else
				newText = replace
			end
			-- need to wait a frame so we can eat the \t
			wait()
			-- Update the text box
			self:SetEntryText(newText .. (insertSpace and " " or ""))
		else
			-- Still need to eat the \t even if there is no auto-complete to show
			wait()
			self:SetEntryText(self:GetEntryText())
		end
	else
		self:ClearHistoryState()
	end
end

-- Hook events
Entry.TextBox.FocusLost:Connect(function(submit)
	return Window:LoseFocus(submit)
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	return Window:BeginInput(input, gameProcessed)
end)

Entry.TextBox:GetPropertyChangedSignal("Text"):Connect(function()
	Gui.CanvasPosition = Vector2.new(0, Gui.AbsoluteCanvasSize.Y)

	if Entry.TextBox.Text:match("\t") then -- Eat \t
		Entry.TextBox.Text = Entry.TextBox.Text:gsub("\t", "")
		return
	end
	if Window.OnTextChanged then
		return Window.OnTextChanged(Entry.TextBox.Text)
	end
end)

Gui.ChildAdded:Connect(function()
	task.defer(Window.UpdateWindowHeight)
end)

return Window
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000485</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="243">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">DefaultEventHandlers</string>
									<string name="ScriptGuid">{5FF763FF-AA09-4403-9954-4BA4106B434B}</string>
									<ProtectedString name="Source"><![CDATA[local StarterGui = game:GetService("StarterGui")
local Window = require(script.Parent.CmdrInterface.Window)

return function (Cmdr)
	Cmdr:HandleEvent("Message", function (text)
		StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = ("[Announcement] %s"):format(text);
			Color = Color3.fromRGB(249, 217, 56);
		})
	end)

	Cmdr:HandleEvent("AddLine", function (...)
		Window:AddLine(...)
	end)
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000486</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="244">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CreateGui</string>
								<string name="ScriptGuid">{E29CFC15-F7F9-4A12-8AFE-C890E173F91B}</string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Cmdr = Instance.new("ScreenGui")
	Cmdr.DisplayOrder = 1000
	Cmdr.Name = "Cmdr"
	Cmdr.ResetOnSpawn = false
	Cmdr.AutoLocalize = false

	local Frame = Instance.new("ScrollingFrame")
	Frame.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
	Frame.BackgroundTransparency = 0.4
	Frame.BorderSizePixel = 0
	Frame.CanvasSize = UDim2.new(0, 0, 0, 0)
	Frame.Name = "Frame"
	Frame.Position = UDim2.new(0.025, 0, 0, 25)
	Frame.ScrollBarThickness = 6
	Frame.ScrollingDirection = Enum.ScrollingDirection.Y
	Frame.Selectable = false
	Frame.Size = UDim2.new(0.95, 0, 0, 0)
	Frame.Visible = false
	Frame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Frame.Parent = Cmdr

	local Autocomplete = Instance.new("ScrollingFrame")
	Autocomplete.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Autocomplete.BackgroundTransparency = 0.5
	Autocomplete.BorderSizePixel = 0
	Autocomplete.CanvasSize = UDim2.new(0, 0, 0, 0)
	Autocomplete.Name = "Autocomplete"
	Autocomplete.Position = UDim2.new(0, 167, 0, 75)
	Autocomplete.ScrollBarThickness = 6
	Autocomplete.ScrollingDirection = Enum.ScrollingDirection.Y
	Autocomplete.Selectable = false
	Autocomplete.Size = UDim2.new(0, 200, 0, 200)
	Autocomplete.Visible = false
	Autocomplete.AutomaticCanvasSize = Enum.AutomaticSize.Y
	Autocomplete.Parent = Cmdr

	local UIListLayout = Instance.new("UIListLayout")
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Parent = Frame

	local Line = Instance.new("TextBox")
	Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Line.BackgroundTransparency = 1
	Line.Font = Enum.Font.Code
	Line.Name = "Line"
	Line.Size = UDim2.new(1, 0, 0, 20)
	Line.AutomaticSize = Enum.AutomaticSize.Y
	Line.TextColor3 = Color3.fromRGB(255, 255, 255)
	Line.TextSize = 14
	Line.TextXAlignment = Enum.TextXAlignment.Left
	Line.TextEditable = false
	Line.ClearTextOnFocus = false
	Line.Parent = Frame

	local UIPadding = Instance.new("UIPadding")
	UIPadding.PaddingBottom = UDim.new(0, 10)
	UIPadding.PaddingLeft = UDim.new(0, 10)
	UIPadding.PaddingRight = UDim.new(0, 10)
	UIPadding.PaddingTop = UDim.new(0, 10)
	UIPadding.Parent = Frame

	local Entry = Instance.new("Frame")
	Entry.BackgroundTransparency = 1
	Entry.LayoutOrder = 999999999
	Entry.Name = "Entry"
	Entry.Size = UDim2.new(1, 0, 0, 20)
	Entry.Parent = Frame

	local UIListLayout2 = Instance.new("UIListLayout")
	UIListLayout2.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout2.Parent = Autocomplete

	local Title = Instance.new("Frame")
	Title.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Title.BackgroundTransparency = 0.2
	Title.BorderSizePixel = 0
	Title.LayoutOrder = -2
	Title.Name = "Title"
	Title.Size = UDim2.new(1, 0, 0, 40)
	Title.Parent = Autocomplete

	local Description = Instance.new("Frame")
	Description.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	Description.BackgroundTransparency = 0.2
	Description.BorderSizePixel = 0
	Description.LayoutOrder = -1
	Description.Name = "Description"
	Description.Size = UDim2.new(1, 0, 0, 20)
	Description.Parent = Autocomplete

	local TextButton = Instance.new("TextButton")
	TextButton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
	TextButton.BackgroundTransparency = 0.5
	TextButton.BorderSizePixel = 0
	TextButton.Font = Enum.Font.Code
	TextButton.Size = UDim2.new(1, 0, 0, 30)
	TextButton.Text = ""
	TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextButton.TextSize = 14
	TextButton.TextXAlignment = Enum.TextXAlignment.Left
	TextButton.Parent = Autocomplete

	local UIListLayout3 = Instance.new("UIListLayout")
	UIListLayout3.FillDirection = Enum.FillDirection.Horizontal
	UIListLayout3.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout3.Padding = UDim.new(0, 7)
	UIListLayout3.Parent = Entry

	local TextBox = Instance.new("TextBox")
	TextBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.BackgroundTransparency = 1
	TextBox.ClearTextOnFocus = false
	TextBox.Font = Enum.Font.Code
	TextBox.LayoutOrder = 999999999
	TextBox.Position = UDim2.new(0, 140, 0, 0)
	TextBox.Size = UDim2.new(1, 0, 0, 20)
	TextBox.Text = "x"
	TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextBox.TextSize = 14
	TextBox.TextXAlignment = Enum.TextXAlignment.Left
	TextBox.Selectable = false
	TextBox.Parent = Entry

	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1
	TextLabel.Font = Enum.Font.Code
	TextLabel.Size = UDim2.new(0, 0, 0, 20)
	TextLabel.AutomaticSize = Enum.AutomaticSize.X
	TextLabel.Text = ""
	TextLabel.TextColor3 = Color3.fromRGB(255, 223, 93)
	TextLabel.TextSize = 14
	TextLabel.TextXAlignment = Enum.TextXAlignment.Left
	TextLabel.Parent = Entry

	local Field = Instance.new("TextLabel")
	Field.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Field.BackgroundTransparency = 1
	Field.Font = Enum.Font.SourceSansBold
	Field.Name = "Field"
	Field.Size = UDim2.new(0, 37, 1, 0)
	Field.Text = "from"
	Field.TextColor3 = Color3.fromRGB(255, 255, 255)
	Field.TextSize = 20
	Field.TextXAlignment = Enum.TextXAlignment.Left
	Field.Parent = Title

	local UIPadding2 = Instance.new("UIPadding")
	UIPadding2.PaddingLeft = UDim.new(0, 10)
	UIPadding2.Parent = Title

	local Label = Instance.new("TextLabel")
	Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Label.BackgroundTransparency = 1
	Label.Font = Enum.Font.SourceSansLight
	Label.Name = "Label"
	Label.Size = UDim2.new(1, 0, 1, 0)
	Label.Text = "The players to teleport. The players to teleport. The players to teleport. The players to teleport. "
	Label.TextColor3 = Color3.fromRGB(255, 255, 255)
	Label.TextSize = 16
	Label.TextWrapped = true
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.TextYAlignment = Enum.TextYAlignment.Top
	Label.Parent = Description

	local UIPadding3 = Instance.new("UIPadding")
	UIPadding3.PaddingBottom = UDim.new(0, 10)
	UIPadding3.PaddingLeft = UDim.new(0, 10)
	UIPadding3.PaddingRight = UDim.new(0, 10)
	UIPadding3.Parent = Description

	local Typed = Instance.new("TextLabel")
	Typed.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Typed.BackgroundTransparency = 1
	Typed.Font = Enum.Font.Code
	Typed.Name = "Typed"
	Typed.Size = UDim2.new(1, 0, 1, 0)
	Typed.Text = "Lab"
	Typed.TextColor3 = Color3.fromRGB(131, 222, 255)
	Typed.TextSize = 14
	Typed.TextXAlignment = Enum.TextXAlignment.Left
	Typed.Parent = TextButton

	local UIPadding4 = Instance.new("UIPadding")
	UIPadding4.PaddingLeft = UDim.new(0, 10)
	UIPadding4.Parent = TextButton

	local Suggest = Instance.new("TextLabel")
	Suggest.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.BackgroundTransparency = 1
	Suggest.Font = Enum.Font.Code
	Suggest.Name = "Suggest"
	Suggest.Size = UDim2.new(1, 0, 1, 0)
	Suggest.Text = "   el"
	Suggest.TextColor3 = Color3.fromRGB(255, 255, 255)
	Suggest.TextSize = 14
	Suggest.TextXAlignment = Enum.TextXAlignment.Left
	Suggest.Parent = TextButton

	local Type = Instance.new("TextLabel")
	Type.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Type.BackgroundTransparency = 1
	Type.BorderColor3 = Color3.fromRGB(255, 153, 153)
	Type.Font = Enum.Font.SourceSans
	Type.Name = "Type"
	Type.Position = UDim2.new(1, 0, 0, 0)
	Type.Size = UDim2.new(0, 0, 1, 0)
	Type.Text = ": Players"
	Type.TextColor3 = Color3.fromRGB(255, 255, 255)
	Type.TextSize = 15
	Type.TextXAlignment = Enum.TextXAlignment.Left
	Type.Parent = Field

	Cmdr.Parent = game:GetService("StarterGui")
	return Cmdr
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000487</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="245">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Initialize</string>
								<string name="ScriptGuid">{DDF0A95D-18EB-4C7E-B947-9666AD4B596C}</string>
								<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local CreateGui = require(script.Parent.CreateGui)

--- Handles initial preparation of the game server-side.
return function (cmdr)
	local ReplicatedRoot, RemoteFunction, RemoteEvent

	local function Create (class, name, parent)
		local object = Instance.new(class)
		object.Name = name
		object.Parent = parent or ReplicatedRoot

		return object
	end

	ReplicatedRoot = script.Parent.CmdrClient
	ReplicatedRoot.Parent = ReplicatedStorage

	RemoteFunction = Create("RemoteFunction", "CmdrFunction")
	RemoteEvent = Create("RemoteEvent", "CmdrEvent")

	Create("Folder", "Commands")
	Create("Folder", "Types")

	script.Parent.Shared.Parent = ReplicatedRoot

	cmdr.ReplicatedRoot = ReplicatedRoot
	cmdr.RemoteFunction = RemoteFunction
	cmdr.RemoteEvent = RemoteEvent

	cmdr:RegisterTypesIn(script.Parent.BuiltInTypes)

	script.Parent.BuiltInTypes:Destroy()
	script.Parent.BuiltInCommands.Name = "Server commands"

	if StarterGui:FindFirstChild("Cmdr") == nil then
		CreateGui()
	end
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000488</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="246">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Shared</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000489</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="247">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Argument</string>
									<string name="ScriptGuid">{001634A1-6FDA-44C4-BA70-EB55983EC613}</string>
									<ProtectedString name="Source"><![CDATA[local Util = require(script.Parent.Util)

local function unescapeOperators(text)
	for _, operator in ipairs({"%.", "%?", "%*", "%*%*"}) do
		text = text:gsub("\\" .. operator, operator:gsub("%%", ""))
	end

	return text
end

local Argument = {}
Argument.__index = Argument

--- Returns a new ArgumentContext, an object that handles parsing and validating arguments
function Argument.new (command, argumentObject, value)
	local self = {
		Command = command; -- The command that owns this argument
		Type = nil; -- The type definition
		Name = argumentObject.Name; -- The name for this specific argument
		Object = argumentObject; -- The raw ArgumentObject (definition)
		Required = argumentObject.Default == nil and argumentObject.Optional ~= true; -- If the argument is required or not.
		Executor = command.Executor; -- The player who is running the command
		RawValue = value; -- The raw, unparsed value
		RawSegments = {}; -- The raw, unparsed segments (if the raw value was comma-sep)
		TransformedValues = {}; -- The transformed value (generated later)
		Prefix = ""; -- The prefix for this command (%Team)
		TextSegmentInProgress = ""; -- The text of the raw segment the user is currently typing.
		RawSegmentsAreAutocomplete = false;
	}

	if type(argumentObject.Type) == "table" then
		self.Type = argumentObject.Type
	else
		local parsedType, parsedRawValue, prefix = Util.ParsePrefixedUnionType(
			command.Cmdr.Registry:GetTypeName(argumentObject.Type),
			value
		)

		self.Type = command.Dispatcher.Registry:GetType(parsedType)
		self.RawValue = parsedRawValue
		self.Prefix = prefix

		if self.Type == nil then
			error(string.format("%s has an unregistered type %q", self.Name or "<none>", parsedType or "<none>"))
		end
	end

	setmetatable(self, Argument)

	self:Transform()

	return self
end

function Argument:GetDefaultAutocomplete()
	if self.Type.Autocomplete then
		local strings, options = self.Type.Autocomplete(self:TransformSegment(""))
		return strings, options or {}
	end

	return {}
end

--- Calls the transform function on this argument.
-- The return value(s) from this function are passed to all of the other argument methods.
-- Called automatically at instantiation
function Argument:Transform()
	if #self.TransformedValues ~= 0 then
		return
	end

	local rawValue = self.RawValue
	if self.Type.ArgumentOperatorAliases then
		rawValue = self.Type.ArgumentOperatorAliases[rawValue] or rawValue
	end

	if rawValue == "." and self.Type.Default then
		rawValue = self.Type.Default(self.Executor) or ""
		self.RawSegmentsAreAutocomplete = true
	end

	if rawValue == "?" and self.Type.Autocomplete then
		local strings, options = self:GetDefaultAutocomplete()

		if not options.IsPartial and #strings > 0 then
			rawValue = strings[math.random(1, #strings)]
			self.RawSegmentsAreAutocomplete = true
		end

	end

	if self.Type.Listable and #self.RawValue > 0 then
		local randomMatch = rawValue:match("^%?(%d+)$")
		if randomMatch then
			local maxSize = tonumber(randomMatch)

			if maxSize and maxSize > 0 then
				local items = {}
				local remainingItems, options = self:GetDefaultAutocomplete()

				if not options.IsPartial and #remainingItems > 0 then
					for _ = 1, math.min(maxSize, #remainingItems) do
						table.insert(items, table.remove(remainingItems, math.random(1, #remainingItems)))
					end

					rawValue = table.concat(items, ",")
					self.RawSegmentsAreAutocomplete = true
				end
			end
		elseif rawValue == "*" or rawValue == "**" then
			local strings, options = self:GetDefaultAutocomplete()

			if not options.IsPartial and #strings > 0 then
				if rawValue == "**" and self.Type.Default then
					local defaultString = self.Type.Default(self.Executor) or ""

					for i, string in ipairs(strings) do
						if string == defaultString then
							table.remove(strings, i)
						end
					end
				end

				rawValue = table.concat(
					strings,
					","
				)
				self.RawSegmentsAreAutocomplete = true
			end
		end

		rawValue = unescapeOperators(rawValue)

		local rawSegments = Util.SplitStringSimple(rawValue, ",")

		if #rawSegments == 0 then
			rawSegments = {""}
		end

		if rawValue:sub(#rawValue, #rawValue) == "," then
			rawSegments[#rawSegments + 1] = "" -- makes auto complete tick over right after pressing ,
		end

		for i, rawSegment in ipairs(rawSegments) do
			self.RawSegments[i] = rawSegment
			self.TransformedValues[i] = { self:TransformSegment(rawSegment) }
		end

		self.TextSegmentInProgress = rawSegments[#rawSegments]
	else
		rawValue = unescapeOperators(rawValue)

		self.RawSegments[1] = unescapeOperators(rawValue)
		self.TransformedValues[1] = { self:TransformSegment(rawValue) }
		self.TextSegmentInProgress = self.RawValue
	end
end

function Argument:TransformSegment(rawSegment)
	if self.Type.Transform then
		return self.Type.Transform(rawSegment, self.Executor)
	else
		return rawSegment
	end
end

--- Returns whatever the Transform method gave us.
function Argument:GetTransformedValue(segment)
	return unpack(self.TransformedValues[segment])
end

--- Validates that the argument will work without any type errors.
function Argument:Validate(isFinal)
	if self.RawValue == nil or #self.RawValue == 0 and self.Required == false then
		return true
	end

	if self.Required and (self.RawSegments[1] == nil or #self.RawSegments[1] == 0) then
		return false, "This argument is required."
	end

	if self.Type.Validate or self.Type.ValidateOnce then
		for i = 1, #self.TransformedValues do
			if self.Type.Validate then
				local valid, errorText = self.Type.Validate(self:GetTransformedValue(i))

				if not valid then
					return valid, errorText or "Invalid value"
				end
			end

			if isFinal and self.Type.ValidateOnce then
				local validOnce, errorTextOnce = self.Type.ValidateOnce(self:GetTransformedValue(i))

				if not validOnce then
					return validOnce, errorTextOnce
				end
			end
		end

		return true
	else
		return true
	end
end

--- Gets a list of all possible values that could match based on the current value.
function Argument:GetAutocomplete()
	if self.Type.Autocomplete then
		return self.Type.Autocomplete(self:GetTransformedValue(#self.TransformedValues))
	else
		return {}
	end
end

function Argument:ParseValue(i)
	if self.Type.Parse then
		return self.Type.Parse(self:GetTransformedValue(i))
	else
		return self:GetTransformedValue(i)
	end
end

--- Returns the final value of the argument.
function Argument:GetValue()
	if #self.RawValue == 0 and not self.Required and self.Object.Default ~= nil then
		return self.Object.Default
	end

	if not self.Type.Listable then
		return self:ParseValue(1)
	end

	local values = {}

	for i = 1, #self.TransformedValues do
		local parsedValue = self:ParseValue(i)

		if type(parsedValue) ~= "table" then
			error(("Listable types must return a table from Parse (%s)"):format(self.Type.Name))
		end

		for _, value in pairs(parsedValue) do
			values[value] = true -- Put them into a dictionary to ensure uniqueness
		end
	end

	local valueArray = {}

	for value in pairs(values) do
		valueArray[#valueArray + 1] = value
	end

	return valueArray
end

return Argument
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="248">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Command</string>
									<string name="ScriptGuid">{397568D6-5255-4401-931D-5834ABC07A3B}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Argument = require(script.Parent.Argument)

local IsServer = RunService:IsServer()

local Command = {}
Command.__index = Command

--- Returns a new CommandContext, an object which is created for every command validation.
-- This is also what's passed as the context to the "Run" functions in commands
function Command.new (options)
	local self = {
		Dispatcher = options.Dispatcher; -- The dispatcher that created this command context
		Cmdr = options.Dispatcher.Cmdr; -- A quick reference to Cmdr for command context
		Name = options.CommandObject.Name; -- The command name (not alias)
		RawText = options.Text; -- The raw text used to trigger this command
		Object = options.CommandObject; -- The command object (definition)
		Group = options.CommandObject.Group; -- The group this command is in
		State = {}; -- A table which will hold any custom command state information
		Aliases = options.CommandObject.Aliases;
		Alias = options.Alias; -- The command name that was used
		Description = options.CommandObject.Description;
		Executor = options.Executor; -- The player who ran the command
		ArgumentDefinitions = options.CommandObject.Args; -- The argument definitions from the command definition
		RawArguments = options.Arguments; -- Array of strings which are the unparsed values for the arguments
		Arguments = {}; -- A table which will hold ArgumentContexts for each argument
		Data = options.Data; -- A special container for any additional data the command needs to collect from the client
		Response = nil; -- Will be set at the very end when the command is run and a string is returned from the Run function.
	}

	setmetatable(self, Command)

	return self
end

--- Parses all of the command arguments into ArgumentContexts
-- Called by the command dispatcher automatically
-- allowIncompleteArguments: if true, will not throw an error for missing arguments
function Command:Parse (allowIncompleteArguments)
	local hadOptional = false
	for i, definition in ipairs(self.ArgumentDefinitions) do
		if type(definition) == "function" then
			definition = definition(self)

			if definition == nil then
				break
			end
		end

		local required = (definition.Default == nil and definition.Optional ~= true)

		if required and hadOptional then
			error(("Command %q: Required arguments cannot occur after optional arguments."):format(self.Name))
		elseif not required then
			hadOptional = true
		end

		if self.RawArguments[i] == nil and required and allowIncompleteArguments ~= true then
			return false, ("Required argument #%d %s is missing."):format(i, definition.Name)
		elseif self.RawArguments[i] or allowIncompleteArguments then
			self.Arguments[i] = Argument.new(self, definition, self.RawArguments[i] or "")
		end
	end

	return true
end

--- Validates that all of the arguments are in a valid state.
-- This must be called before :Run() is called.
-- Returns boolean (true if ok), errorText
function Command:Validate (isFinal)
	self._Validated = true
	local errorText = ""
	local success = true

	for i, arg in pairs(self.Arguments) do
		local argSuccess, argErrorText = arg:Validate(isFinal)

		if not argSuccess then
			success = false
			errorText = ("%s; #%d %s: %s"):format(errorText, i, arg.Name, argErrorText or "error")
		end
	end

	return success, errorText:sub(3)
end

--- Returns the last argument that has a value.
-- Useful for getting the autocomplete for the argument the user is working on.
function Command:GetLastArgument()
	for i = #self.Arguments, 1, -1 do
		if self.Arguments[i].RawValue then
			return self.Arguments[i]
		end
	end
end

--- Returns a table containing the parsed values for all of the arguments.
function Command:GatherArgumentValues ()
	local values = {}

	for i = 1, #self.ArgumentDefinitions do
		local arg = self.Arguments[i]
		if arg then
			values[i] = arg:GetValue()
		elseif type(self.ArgumentDefinitions[i]) == "table" then
			values[i] = self.ArgumentDefinitions[i].Default
		end
	end

	return values, #self.ArgumentDefinitions
end

--- Runs the command. Handles dispatching to the server if necessary.
-- Command:Validate() must be called before this is called or it will throw.
function Command:Run ()
	if self._Validated == nil then
		error("Must validate a command before running.")
	end

	local beforeRunHook = self.Dispatcher:RunHooks("BeforeRun", self)
	if beforeRunHook then
		return beforeRunHook
	end

	if not IsServer and self.Object.Data and self.Data == nil then
		local values, length = self:GatherArgumentValues()
		self.Data = self.Object.Data(self, unpack(values, 1, length))
	end

	if not IsServer and self.Object.ClientRun then
		local values, length = self:GatherArgumentValues()
		self.Response = self.Object.ClientRun(self, unpack(values, 1, length))
	end

	if self.Response == nil then
		if self.Object.Run then -- We can just Run it here on this machine
			local values, length = self:GatherArgumentValues()
			self.Response = self.Object.Run(self, unpack(values, 1, length))

		elseif IsServer then -- Uh oh, we're already on the server and there's no Run function.
			if self.Object.ClientRun then
				warn(self.Name, "command fell back to the server because ClientRun returned nil, but there is no server implementation! Either return a string from ClientRun, or create a server implementation for this command.")
			else
				warn(self.Name, "command has no implementation!")
			end

			self.Response = "No implementation."
		else -- We're on the client, so we send this off to the server to let the server see what it can do with it.
			self.Response = self.Dispatcher:Send(self.RawText, self.Data)
		end
	end

	local afterRunHook = self.Dispatcher:RunHooks("AfterRun", self)
	if afterRunHook then
		return afterRunHook
	else
		return self.Response
	end
end

--- Returns an ArgumentContext for the specific index
function Command:GetArgument (index)
	return self.Arguments[index]
end

-- Below are functions that are only meant to be used in command implementations --

--- Returns the extra data associated with this command.
-- This needs to be used instead of just context.Data for reliability when not using a remote command.
function Command:GetData ()
	if self.Data then
		return self.Data
	end

	if self.Object.Data and not IsServer then
		self.Data = self.Object.Data(self)
	end

	return self.Data
end

--- Sends an event message to a player
function Command:SendEvent(player, event, ...)
	assert(typeof(player) == "Instance", "Argument #1 must be a Player")
	assert(player:IsA("Player"), "Argument #1 must be a Player")
	assert(type(event) == "string", "Argument #2 must be a string")

	if IsServer then
		self.Dispatcher.Cmdr.RemoteEvent:FireClient(player, event, ...)
	elseif self.Dispatcher.Cmdr.Events[event] then
		assert(player == Players.LocalPlayer, "Event messages can only be sent to the local player on the client.")
		self.Dispatcher.Cmdr.Events[event](...)
	end
end

--- Sends an event message to all players
function Command:BroadcastEvent(...)
	if not IsServer then
		error("Can't broadcast event messages from the client.", 2)
	end

	self.Dispatcher.Cmdr.RemoteEvent:FireAllClients(...)
end

--- Alias of self:SendEvent(self.Executor, "AddLine", text)
function Command:Reply(...)
	return self:SendEvent(self.Executor, "AddLine", ...)
end

--- Alias of Registry:GetStore(...)
function Command:GetStore(...)
	return self.Dispatcher.Cmdr.Registry:GetStore(...)
end

--- Returns true if the command has an implementation on the caller's machine.
function Command:HasImplementation()
	return ((RunService:IsClient() and self.Object.ClientRun) or self.Object.Run) and true or false
end

return Command
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="249">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Dispatcher</string>
									<string name="ScriptGuid">{97A3B5F0-A14F-491D-AF30-59AA1D16569C}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Util = require(script.Parent.Util)
local Command = require(script.Parent.Command)

local HISTORY_SETTING_NAME = "CmdrCommandHistory"
local displayedBeforeRunHookWarning = false

--- The dispatcher handles creating and running commands during the game.
local Dispatcher = {
	Cmdr = nil;
	Registry = nil;
}

--- Takes in raw command information and generates a command out of it.
-- text and executor are required arguments.
-- allowIncompleteData, when true, will ignore errors about arguments missing so we can parse live as the user types.
-- data is for special networked Data about the command gathered on the client. Purely Optional.
-- returns the command if successful, or (false, errorText) if not
function Dispatcher:Evaluate (text, executor, allowIncompleteArguments, data)
	if RunService:IsClient() == true and executor ~= Players.LocalPlayer then
		error("Can't evaluate a command that isn't sent by the local player.")
	end

	local arguments = Util.SplitString(text)
	local commandName = table.remove(arguments, 1)
	local commandObject = self.Registry:GetCommand(commandName)

	if commandObject then
		-- No need to continue splitting when there are no more arguments. We'll just mash any additional arguments into the last one.
		arguments = Util.MashExcessArguments(arguments, #commandObject.Args)

		-- Create the CommandContext and parse it.
		local command = Command.new({
			Dispatcher = self,
			Text = text,
			CommandObject = commandObject,
			Alias = commandName,
			Executor = executor,
			Arguments = arguments,
			Data = data
		})
		local success, errorText = command:Parse(allowIncompleteArguments)

		if success then
			return command
		else
			return false, errorText
		end
	else
		return false, ("%q is not a valid command name. Use the help command to see all available commands."):format(tostring(commandName))
	end
end

--- A helper that evaluates and runs the command in one go.
-- Either returns any validation errors as a string, or the output of the command as a string. Definitely a string, though.
function Dispatcher:EvaluateAndRun (text, executor, options)
	executor = executor or Players.LocalPlayer
	options = options or {}

	if RunService:IsClient() and options.IsHuman then
		self:PushHistory(text)
	end

	local command, errorText = self:Evaluate(text, executor, nil, options.Data)

	if not command then
		return errorText
	end

	local ok, out = xpcall(function()
		local valid, errorText = command:Validate(true) -- luacheck: ignore

		if not valid then
			return errorText
		end

		return command:Run() or "Command executed."
	end, function(value)
		return debug.traceback(tostring(value))
	end)

	if not ok then
		warn(("Error occurred while evaluating command string %q\n%s"):format(text, tostring(out)))
	end

	return ok and out or "An error occurred while running this command. Check the console for more information."
end

--- Send text as the local user to remote server to be evaluated there.
function Dispatcher:Send (text, data)
	if RunService:IsClient() == false then
		error("Dispatcher:Send can only be called from the client.")
	end

	return self.Cmdr.RemoteFunction:InvokeServer(text, {
		Data = data
	})
end

--- Invoke a command programmatically as the local user e.g. from a settings menu
-- Command should be the first argument, all arguments afterwards should be the arguments to the command.
function Dispatcher:Run (...)
	if not Players.LocalPlayer then
		error("Dispatcher:Run can only be called from the client.")
	end

	local args = {...}
	local text = args[1]

	for i = 2, #args do
		text = text .. " " .. tostring(args[i])
	end

	local command, errorText = self:Evaluate(text, Players.LocalPlayer)

	if not command then
		error(errorText) -- We do a full-on error here since this is code-invoked and they should know better.
	end

	local success, errorText = command:Validate(true) -- luacheck: ignore

	if not success then
		error(errorText)
	end

	return command:Run()
end

--- Runs hooks matching name and returns nil for ok or a string for cancellation
function Dispatcher:RunHooks(hookName, commandContext, ...)
	if not self.Registry.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	if
		hookName == "BeforeRun"
		and #self.Registry.Hooks[hookName] == 0
		and commandContext.Group ~= "DefaultUtil"
		and commandContext.Group ~= "UserAlias"
		and commandContext:HasImplementation()
	then

		if RunService:IsStudio() then
			if displayedBeforeRunHookWarning == false then
				commandContext:Reply((RunService:IsServer() and "<Server>" or "<Client>") .. " Commands will not run in-game if no BeforeRun hook is configured. Learn more: https://eryn.io/Cmdr/guide/Hooks.html", Color3.fromRGB(255,228,26))
				displayedBeforeRunHookWarning = true
			end
		else
			return "Command blocked for security as no BeforeRun hook is configured."
		end
	end

	for _, hook in ipairs(self.Registry.Hooks[hookName]) do
		local value = hook.callback(commandContext, ...)

		if value ~= nil then
			return tostring(value)
		end
	end
end

function Dispatcher:PushHistory(text)
	assert(RunService:IsClient(), "PushHistory may only be used from the client.")

	local history = self:GetHistory()

	-- Remove duplicates
	if Util.TrimString(text) == "" or text == history[#history] then
		return
	end

	history[#history + 1] = text

	TeleportService:SetTeleportSetting(HISTORY_SETTING_NAME, history)
end

function Dispatcher:GetHistory()
	assert(RunService:IsClient(), "GetHistory may only be used from the client.")

	return TeleportService:GetTeleportSetting(HISTORY_SETTING_NAME) or {}
end

return function (cmdr)
	Dispatcher.Cmdr = cmdr
	Dispatcher.Registry = cmdr.Registry

	return Dispatcher
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="250">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Registry</string>
									<string name="ScriptGuid">{BD939352-4C70-4EF9-9988-3A005268BAE7}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Util = require(script.Parent.Util)

--- The registry keeps track of all the commands and types that Cmdr knows about.
local Registry = {
	TypeMethods = Util.MakeDictionary({"Transform", "Validate", "Autocomplete", "Parse", "DisplayName", "Listable", "ValidateOnce", "Prefixes", "Default", "ArgumentOperatorAliases"});
	CommandMethods = Util.MakeDictionary({"Name", "Aliases", "AutoExec", "Description", "Args", "Run", "ClientRun", "Data", "Group"});
	CommandArgProps = Util.MakeDictionary({"Name", "Type", "Description", "Optional", "Default"});
	Types = {};
	TypeAliases = {};
	Commands = {};
	CommandsArray = {};
	Cmdr = nil;
	Hooks = {
		BeforeRun = {};
		AfterRun = {}
	};
	Stores = setmetatable({}, {
		__index = function (self, k)
			self[k] = {}
			return self[k]
		end
	});
	AutoExecBuffer = {};
}

--- Registers a type in the system.
-- name: The type Name. This must be unique.
function Registry:RegisterType (name, typeObject)
	if not name or typeof(name) ~= "string" then
		error("Invalid type name provided: nil")
	end

	if not name:find("^[%d%l]%w*$") then
		error(('Invalid type name provided: "%s", type names must be alphanumeric and start with a lower-case letter or a digit.'):format(name))
	end

	for key in pairs(typeObject) do
		if self.TypeMethods[key] == nil then
			error("Unknown key/method in type \"" .. name .. "\": " .. key)
		end
	end

	if self.Types[name] ~= nil then
		error(('Type "%s" has already been registered.'):format(name))
	end

	typeObject.Name = name
	typeObject.DisplayName = typeObject.DisplayName or name

	self.Types[name] = typeObject

	if typeObject.Prefixes then
		self:RegisterTypePrefix(name, typeObject.Prefixes)
	end
end

function Registry:RegisterTypePrefix (name, union)
	if not self.TypeAliases[name] then
		self.TypeAliases[name] = name
	end

	self.TypeAliases[name] = ("%s %s"):format(self.TypeAliases[name], union)
end

function Registry:RegisterTypeAlias (name, alias)
	assert(self.TypeAliases[name] == nil, ("Type alias %s already exists!"):format(alias))
	self.TypeAliases[name] = alias
end

--- Helper method that registers types from all module scripts in a specific container.
function Registry:RegisterTypesIn (container)
	for _, object in pairs(container:GetChildren()) do
		if object:IsA("ModuleScript") then
			object.Parent = self.Cmdr.ReplicatedRoot.Types

			require(object)(self)
		else
			self:RegisterTypesIn(object)
		end
	end
end

-- These are exactly the same thing. No one will notice. Except for you, dear reader.
Registry.RegisterHooksIn = Registry.RegisterTypesIn

--- Registers a command based purely on its definition.
-- Prefer using Registry:RegisterCommand for proper handling of server/client model.
function Registry:RegisterCommandObject (commandObject, fromCmdr)
	for key in pairs(commandObject) do
		if self.CommandMethods[key] == nil then
			error("Unknown key/method in command " .. (commandObject.Name or "unknown command") .. ": " .. key)
		end
	end

	if commandObject.Args then
		for i, arg in pairs(commandObject.Args) do
			if type(arg) == "table" then
				for key in pairs(arg) do
					if self.CommandArgProps[key] == nil then
						error(('Unknown property in command "%s" argument #%d: %s'):format(commandObject.Name or "unknown", i, key))
					end
				end
			end
		end
	end

	if commandObject.AutoExec and RunService:IsClient() then
		table.insert(self.AutoExecBuffer, commandObject.AutoExec)
		self:FlushAutoExecBufferDeferred()
	end

	-- Unregister the old command if it exists...
	local oldCommand = self.Commands[commandObject.Name:lower()]
	if oldCommand and oldCommand.Aliases then
		for _, alias in pairs(oldCommand.Aliases) do
			self.Commands[alias:lower()] = nil
		end
	elseif not oldCommand then
		table.insert(self.CommandsArray, commandObject)
	end

	self.Commands[commandObject.Name:lower()] = commandObject

	if commandObject.Aliases then
		for _, alias in pairs(commandObject.Aliases) do
			self.Commands[alias:lower()] = commandObject
		end
	end
end

--- Registers a command definition and its server equivalent.
-- Handles replicating the definition to the client.
function Registry:RegisterCommand (commandScript, commandServerScript, filter)
	local commandObject = require(commandScript)
	assert(
		typeof(commandObject) == "table",
		`Invalid return value from command script "{commandScript.Name}" (CommandDefinition expected, got {typeof(commandObject)})`
	)

	if commandServerScript then
		assert(RunService:IsServer(), "The commandServerScript parameter is not valid for client usage.")
		commandObject.Run = require(commandServerScript)
	end

	if filter and not filter(commandObject) then
		return
	end

	self:RegisterCommandObject(commandObject)

	commandScript.Parent = self.Cmdr.ReplicatedRoot.Commands
end

--- A helper method that registers all commands inside a specific container.
function Registry:RegisterCommandsIn (container, filter)
	local skippedServerScripts = {}
	local usedServerScripts = {}

	for _, commandScript in pairs(container:GetChildren()) do
		if commandScript:IsA("ModuleScript") then
			if not commandScript.Name:find("Server") then
				local serverCommandScript = container:FindFirstChild(commandScript.Name .. "Server")

				if serverCommandScript then
					usedServerScripts[serverCommandScript] = true
				end

				self:RegisterCommand(commandScript, serverCommandScript, filter)
			else
				skippedServerScripts[commandScript] = true
			end
		else
			self:RegisterCommandsIn(commandScript, filter)
		end
	end

	for skippedScript in pairs(skippedServerScripts) do
		if not usedServerScripts[skippedScript] then
			warn("Command script " .. skippedScript.Name .. " was skipped because it has 'Server' in its name, and has no equivalent shared script.")
		end
	end
end

--- Registers the default commands, with an optional filter function or array of groups.
function Registry:RegisterDefaultCommands (arrayOrFunc)
	assert(RunService:IsServer(), "RegisterDefaultCommands cannot be called from the client.")

	local isArray = type(arrayOrFunc) == "table"

	if isArray then
		arrayOrFunc = Util.MakeDictionary(arrayOrFunc)
	end

	self:RegisterCommandsIn(self.Cmdr.DefaultCommandsFolder, isArray and function (command)
		return arrayOrFunc[command.Group] or false
	end or arrayOrFunc)
end

--- Gets a command definition by name. (Can be an alias)
function Registry:GetCommand (name)
	name = name or ""
	return self.Commands[name:lower()]
end

--- Returns a unique array of all registered commands (not including aliases)
function Registry:GetCommands ()
	return self.CommandsArray
end

--- Returns an array of the names of all registered commands (not including aliases)
function Registry:GetCommandNames ()
	local commands = {}

	for _, command in pairs(self.CommandsArray) do
		table.insert(commands, command.Name)
	end

	return commands
end

Registry.GetCommandsAsStrings = Registry.GetCommandNames

--- Returns an array of the names of all registered types (not including aliases)
function Registry:GetTypeNames ()
	local typeNames = {}

	for typeName in pairs(self.Types) do
		table.insert(typeNames, typeName)
	end

	return typeNames
end


--- Gets a type definition by name.
function Registry:GetType (name)
	return self.Types[name]
end

--- Returns a type name, parsing aliases.
function Registry:GetTypeName (name)
	return self.TypeAliases[name] or name
end

--- Adds a hook to be called when any command is run
function Registry:RegisterHook(hookName, callback, priority)
	if not self.Hooks[hookName] then
		error(("Invalid hook name: %q"):format(hookName), 2)
	end

	table.insert(self.Hooks[hookName], { callback = callback; priority = priority or 0; } )
	table.sort(self.Hooks[hookName], function(a, b) return a.priority < b.priority end)
end

-- Backwards compatability (deprecated)
Registry.AddHook = Registry.RegisterHook

--- Returns the store with the given name
-- Used for commands that require persistent state, like bind or ban
function Registry:GetStore(name)
	return self.Stores[name]
end

--- Calls self:FlushAutoExecBuffer at the end of the frame
function Registry:FlushAutoExecBufferDeferred()
	if self.AutoExecFlushConnection then
		return
	end

	self.AutoExecFlushConnection = RunService.Heartbeat:Connect(function()
		self.AutoExecFlushConnection:Disconnect()
		self.AutoExecFlushConnection = nil
		self:FlushAutoExecBuffer()
	end)
end

--- Runs all pending auto exec commands in Registry.AutoExecBuffer
function Registry:FlushAutoExecBuffer()
	for _, commandGroup in ipairs(self.AutoExecBuffer) do
		for _, command in ipairs(commandGroup) do
			self.Cmdr.Dispatcher:EvaluateAndRun(command)
		end
	end

	self.AutoExecBuffer = {}
end

return function (cmdr)
	Registry.Cmdr = cmdr

	return Registry
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="251">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Util</string>
									<string name="ScriptGuid">{9C8BE305-C113-4DE7-BBEB-A2E4F3A94A64}</string>
									<ProtectedString name="Source"><![CDATA[local TextService = game:GetService("TextService")

local Util = {}

--- Takes an array and flips its values into dictionary keys with value of true.
function Util.MakeDictionary(array)
	local dictionary = {}

	for i = 1, #array do
		dictionary[array[i]] = true
	end

	return dictionary
end

--- Takes a dictionary and returns its keys.
function Util.DictionaryKeys(dict)
	local keys = {}

	for key in pairs(dict) do
		table.insert(keys, key)
	end

	return keys
end

-- Takes an array of instances and returns (array<names>, array<instances>)
local function transformInstanceSet(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name
	end

	return names, instances
end

--- Returns a function that is a fuzzy finder for the specified set or container.
-- Can pass an array of strings, array of instances, array of EnumItems,
-- array of dictionaries with a Name key or an instance (in which case its children will be used)
-- Exact matches will be inserted in the front of the resulting array
function Util.MakeFuzzyFinder(setOrContainer)
	local names
	local instances = {}

	if typeof(setOrContainer) == "Enum" then
		setOrContainer = setOrContainer:GetEnumItems()
	end

	if typeof(setOrContainer) == "Instance" then
		names, instances = transformInstanceSet(setOrContainer:GetChildren())
	elseif typeof(setOrContainer) == "table" then
		if
			typeof(setOrContainer[1]) == "Instance" or typeof(setOrContainer[1]) == "EnumItem" or
				(typeof(setOrContainer[1]) == "table" and typeof(setOrContainer[1].Name) == "string")
		 then
			names, instances = transformInstanceSet(setOrContainer)
		elseif type(setOrContainer[1]) == "string" then
			names = setOrContainer
		elseif setOrContainer[1] ~= nil then
			error("MakeFuzzyFinder only accepts tables of instances or strings.")
		else
			names = {}
		end
	else
		error("MakeFuzzyFinder only accepts a table, Enum, or Instance.")
	end

	-- Searches the set (checking exact matches first)
	return function(text, returnFirst)
		local results = {}

		for i, name in pairs(names) do
			local value = instances and instances[i] or name

			-- Continue on checking for non-exact matches...
			-- Still need to loop through everything, even on returnFirst, because possibility of an exact match.
			if name:lower() == text:lower() then
				if returnFirst then
					return value
				else
					table.insert(results, 1, value)
				end
			elseif name:lower():find(text:lower(), 1, true) then
				results[#results + 1] = value
			end
		end

		if returnFirst then
			return results[1]
		end

		return results
	end
end

--- Takes an array of instances and returns an array of those instances' names.
function Util.GetNames(instances)
	local names = {}

	for i = 1, #instances do
		names[i] = instances[i].Name or tostring(instances[i])
	end

	return names
end

--- Splits a string using a simple separator (no quote parsing)
function Util.SplitStringSimple(inputstr, sep)
	if sep == nil then
		sep = "%s"
	end
	local t = {}
	local i = 1
	for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
		t[i] = str
		i = i + 1
	end
	return t
end

local function charCode(n)
	return utf8.char(tonumber(n, 16))
end

--- Parses escape sequences into their fully qualified characters
function Util.ParseEscapeSequences(text)
	return text:gsub("\\(.)", {
		t = "\t";
		n = "\n";
	})
	:gsub("\\u(%x%x%x%x)", charCode)
	:gsub("\\x(%x%x)", charCode)
end

function Util.EncodeEscapedOperator(text, op)
	local first = op:sub(1, 1)
	local escapedOp = op:gsub(".", "%%%1")
	local escapedFirst = "%" .. first

	return text:gsub("(" .. escapedFirst .. "+)(" .. escapedOp .. ")", function(esc, op)
			return (esc:sub(1, #esc-1) .. op):gsub(".", function(char)
					return "\\u" .. string.format("%04x", string.byte(char), 16)
			end)
	end)
end

local OPERATORS = {"&&", "||", ";"}
function Util.EncodeEscapedOperators(text)
	for _, operator in ipairs(OPERATORS) do
		text = Util.EncodeEscapedOperator(text, operator)
	end

	return text
end

local function encodeControlChars(text)
	return (
		text
		:gsub("\\\\", "___!CMDR_ESCAPE!___")
		:gsub("\\\"", "___!CMDR_QUOTE!___")
		:gsub("\\'", "___!CMDR_SQUOTE!___")
		:gsub("\\\n", "___!CMDR_NL!___")
	)
end

local function decodeControlChars(text)
	return (
		text
		:gsub("___!CMDR_ESCAPE!___", "\\")
		:gsub("___!CMDR_QUOTE!___", "\"")
		:gsub("___!CMDR_NL!___", "\n")
	)
end

--- Splits a string by space but taking into account quoted sequences which will be treated as a single argument.
function Util.SplitString(text, max)
	text = encodeControlChars(text)
	max = max or math.huge
	local t = {}
	local spat, epat = [=[^(['"])]=], [=[(['"])$]=]
	local buf, quoted
	for str in text:gmatch("[^ ]+") do
		str = Util.ParseEscapeSequences(str)
		local squoted = str:match(spat)
		local equoted = str:match(epat)
		local escaped = str:match([=[(\*)['"]$]=])
		if squoted and not quoted and not equoted then
			buf, quoted = str, squoted
		elseif buf and equoted == quoted and #escaped % 2 == 0 then
			str, buf, quoted = buf .. " " .. str, nil, nil
		elseif buf then
			buf = buf .. " " .. str
		end
		if not buf then
			t[#t + (#t > max and 0 or 1)] = decodeControlChars(str:gsub(spat, ""):gsub(epat, ""))
		end
	end

	if buf then
		t[#t + (#t > max and 0 or 1)] = decodeControlChars(buf)
	end

	return t
end

--- Takes an array of arguments and a max value.
-- Any indicies past the max value will be appended to the last valid argument.
function Util.MashExcessArguments(arguments, max)
	local t = {}
	for i = 1, #arguments do
		if i > max then
			t[max] = ("%s %s"):format(t[max] or "", arguments[i])
		else
			t[i] = arguments[i]
		end
	end
	return t
end

--- Trims whitespace from both sides of a string.
function Util.TrimString(str)
	local _, from = string.find(str, "^%s*")
	-- trim the string in two steps to prevent quadratic backtracking when no "%S" match is found
	return from == #str and "" or string.match(str, ".*%S", from + 1)
end

--- Returns the text bounds size based on given text, label (from which properties will be pulled), and optional Vector2 container size.
function Util.GetTextSize(text, label, size)
	return TextService:GetTextSize(text, label.TextSize, label.Font, size or Vector2.new(label.AbsoluteSize.X, 0))
end

--- Makes an Enum type.
function Util.MakeEnumType(name, values)
	local findValue = Util.MakeFuzzyFinder(values)
	return {
		Validate = function(text)
			return findValue(text, true) ~= nil, ("Value %q is not a valid %s."):format(text, name)
		end,
		Autocomplete = function(text)
			local list = findValue(text)
			return type(list[1]) ~= "string" and Util.GetNames(list) or list
		end,
		Parse = function(text)
			return findValue(text, true)
		end
	}
end

--- Parses a prefixed union type argument (such as %Team)
function Util.ParsePrefixedUnionType(typeValue, rawValue)
	local split = Util.SplitStringSimple(typeValue)

	-- Check prefixes in order from longest to shortest
	local types = {}
	for i = 1, #split, 2 do
		types[#types + 1] = {
			prefix = split[i - 1] or "",
			type = split[i]
		}
	end

	table.sort(
		types,
		function(a, b)
			return #a.prefix > #b.prefix
		end
	)

	for i = 1, #types do
		local t = types[i]

		if rawValue:sub(1, #t.prefix) == t.prefix then
			return t.type, rawValue:sub(#t.prefix + 1), t.prefix
		end
	end
end

--- Creates a listable type from a singlular type
function Util.MakeListableType(type, override)
	local listableType = {
		Listable = true,
		Transform = type.Transform,
		Validate = type.Validate,
		ValidateOnce = type.ValidateOnce,
		Autocomplete = type.Autocomplete,
		Default = type.Default,
		ArgumentOperatorAliases = type.ArgumentOperatorAliases,
		Parse = function(...)
			return {type.Parse(...)}
		end
	}

	if override then
		for key, value in pairs(override) do
			listableType[key] = value
		end
	end

	return listableType
end

local function encodeCommandEscape(text)
	return (text:gsub("\\%$", "___!CMDR_DOLLAR!___"))
end

local function decodeCommandEscape(text)
	return (text:gsub("___!CMDR_DOLLAR!___", "$"))
end

function Util.RunCommandString(dispatcher, commandString)
	commandString = Util.ParseEscapeSequences(commandString)
	commandString = Util.EncodeEscapedOperators(commandString)

	local commands = commandString:split("&&")

	local output = ""
	for i, command in ipairs(commands) do
		local outputEncoded = output:gsub("%$", "\\x24"):gsub("%%","%%%%")
		command = command:gsub("||", output:find("%s") and ("%q"):format(outputEncoded) or outputEncoded)

		output = tostring(
			dispatcher:EvaluateAndRun(
				(
					Util.RunEmbeddedCommands(dispatcher, command)
				)
			)
		)


		if i == #commands then
			return output
		end
	end
end

--- Runs embedded commands and replaces them
function Util.RunEmbeddedCommands(dispatcher, str)
	str = encodeCommandEscape(str)

	local results = {}
	-- We need to do this because you can't yield in the gsub function
	for text in str:gmatch("$(%b{})") do
		local doQuotes = true
		local commandString = text:sub(2, #text-1)

		if commandString:match("^{.+}$") then -- Allow double curly for literal replacement
			doQuotes = false
			commandString = commandString:sub(2, #commandString-1)
		end

		results[text] = Util.RunCommandString(dispatcher, commandString)

		if doQuotes then
			if results[text]:find("%s") or results[text] == "" then
				results[text] = string.format("%q", results[text])
			end
		end
	end

	return decodeCommandEscape(str:gsub("$(%b{})", results))
end

--- Replaces arguments in the format $1, $2, $something with whatever the
-- given function returns for it.
function Util.SubstituteArgs(str, replace)
	str = encodeCommandEscape(str)
	-- Convert numerical keys to strings
	if type(replace) == "table" then
		for i = 1, #replace do
			local k = tostring(i)
			replace[k] = replace[i]

			if replace[k]:find("%s") then
				replace[k] = string.format("%q", replace[k])
			end
		end
	end
	return decodeCommandEscape(str:gsub("($%d+)%b{}", "%1"):gsub("$(%w+)", replace))
end

--- Creates an alias command
function Util.MakeAliasCommand(name, commandString)
	local commandName, commandDescription = unpack(name:split("|"))
	local args = {}

	commandString = Util.EncodeEscapedOperators(commandString)

	local seenArgs = {}

	for arg in commandString:gmatch("$(%d+)") do
		if seenArgs[arg] == nil then
			seenArgs[arg] = true
			local options = commandString:match(`${arg}(%b\{})`)

			local argOptional, argType, argName, argDescription
			if options then
				options = options:sub(2, #options - 1) -- remove braces
				argType, argName, argDescription = unpack(options:split("|"))
			end

			argOptional = argType and not not argType:match("%?$")
			argType = if argType then argType:match("^%w+") else "string"
			argName = argName or `Argument {arg}`
			argDescription = argDescription or ""

			table.insert(args, {
				Type = argType,
				Name = argName,
				Description = argDescription,
				Optional = argOptional,
			})
		end
	end

	return {
		Name = commandName,
		Aliases = {},
		Description = `<Alias> {commandDescription or commandString}`,
		Group = "UserAlias",
		Args = args,
		Run = function(context)
			return Util.RunCommandString(context.Dispatcher, Util.SubstituteArgs(commandString, context.RawArguments))
		end,
	}
end

--- Makes a type that contains a sequence, e.g. Vector3 or Color3
function Util.MakeSequenceType(options)
	options = options or {}

	assert(options.Parse ~= nil or options.Constructor ~= nil, "MakeSequenceType: Must provide one of: Constructor, Parse")

	options.TransformEach = options.TransformEach or function(...)
		return ...
	end

	options.ValidateEach = options.ValidateEach or function()
		return true
	end

	return {
		Prefixes = options.Prefixes;

		Transform = function (text)
			return Util.Map(Util.SplitPrioritizedDelimeter(text, {",", "%s"}), function(value)
				return options.TransformEach(value)
			end)
		end;

		Validate = function (components)
			if options.Length and #components > options.Length then
				return false, ("Maximum of %d values allowed in sequence"):format(options.Length)
			end

			for i = 1, options.Length or #components do
				local valid, reason = options.ValidateEach(components[i], i)

				if not valid then
					return false, reason
				end
			end

			return true
		end;

		Parse = options.Parse or function(components)
			return options.Constructor(unpack(components))
		end
	}
end

--- Splits a string by a single delimeter chosen from the given set.
-- The first matching delimeter from the set becomes the split character.
function Util.SplitPrioritizedDelimeter(text, delimeters)
	for i, delimeter in ipairs(delimeters) do
		if text:find(delimeter) or i == #delimeters then
			return Util.SplitStringSimple(text, delimeter)
		end
	end
end

--- Maps values of an array through a callback and returns an array of mapped values
function Util.Map(array, callback)
	local results = {}

	for i, v in ipairs(array) do
		results[i] = callback(v, i)
	end

	return results
end

--- Maps arguments #2-n through callback and returns values as tuple
function Util.Each(callback, ...)
	local results = {}
	for i, value in ipairs({...}) do
		results[i] = callback(value)
	end
	return unpack(results)
end

--- Emulates tabstops with spaces
function Util.EmulateTabstops(text, tabWidth)
	local column = 0
	local textLength = #text
	local result = table.create(textLength)
	for i = 1, textLength do
		local char = string.sub(text, i, i)
		if char == "\t" then
			local spaces = tabWidth - column % tabWidth
			table.insert(result, string.rep(" ", spaces))
			column += spaces
		else
			table.insert(result, char)
			if char == "\n" then
				column = 0 -- Reset column counter on newlines
			elseif char ~= "\r" then
				column += 1
			end
		end
	end
	return table.concat(result)
end

function Util.Mutex()
	local queue = {}
	local locked = false

	return function ()
		if locked then
			table.insert(queue, coroutine.running())
			coroutine.yield()
		else
			locked = true
		end

		return function()
			if #queue > 0 then
				coroutine.resume(table.remove(queue, 1))
			else
				locked = false
			end
		end
	end
end

return Util
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048e</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="252">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">evaera_promise@4.0.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000048f</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="253">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">promise</string>
							<string name="ScriptGuid">{CB4F0873-07E3-46E0-826A-7E2B8EF664CD}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000490</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="254">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">init.spec</string>
								<string name="ScriptGuid">{3D31A427-AE7C-4EAE-83D0-F267B59E8663}</string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Promise = require(script.Parent)
	Promise.TEST = true

	local timeEvent = Instance.new("BindableEvent")
	Promise._timeEvent = timeEvent.Event

	local advanceTime
	do
		local injectedPromiseTime = 0

		Promise._getTime = function()
			return injectedPromiseTime
		end

		function advanceTime(delta)
			delta = delta or (1 / 60)

			injectedPromiseTime = injectedPromiseTime + delta
			timeEvent:Fire(delta)
		end
	end

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.Status", function()
		it("should error if indexing nil value", function()
			expect(function()
				local _ = Promise.Status.wrong
			end).to.throw()
		end)
	end)

	describe("Unhandled rejection signal", function()
		it("should call unhandled rejection callbacks", function()
			local badPromise = Promise.new(function(_resolve, reject)
				reject(1, 2)
			end)

			local callCount = 0

			local function callback(promise, rejectionA, rejectionB)
				callCount += 1

				expect(promise).to.equal(badPromise)
				expect(rejectionA).to.equal(1)
				expect(rejectionB).to.equal(2)
			end

			local unregister = Promise.onUnhandledRejection(callback)

			advanceTime()

			expect(callCount).to.equal(1)

			unregister()

			Promise.new(function(_resolve, reject)
				reject(3, 4)
			end)

			advanceTime()

			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should work with C functions", function()
			expect(function()
				Promise.new(tick):andThen(tick)
			end).to.never.throw()
		end)

		it("should have a nice tostring", function()
			expect(tostring(Promise.resolve()):gmatch("Promise(Resolved)")).to.be.ok()
		end)

		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.new(function(resolve)
				bindable.Event:Wait()
				resolve(5)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should preserve stack traces of resolve-chained promises", function()
			local function nestedCall(text)
				error(text)
			end

			local promise = Promise.new(function(resolve)
				resolve(Promise.new(function()
					nestedCall("sample text")
				end))
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(promise._values[1])
			expect(trace:find("sample text")).to.be.ok()
			expect(trace:find("nestedCall")).to.be.ok()
			expect(trace:find("runExecutor")).to.be.ok()
			expect(trace:find("runPlanNode")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
		end)

		it("should report errors from Promises with _error (< v2)", function()
			local oldPromise = Promise.reject()
			oldPromise._error = "Sample error"

			local newPromise = Promise.resolve():andThenReturn(oldPromise)

			expect(newPromise:getStatus()).to.equal(Promise.Status.Rejected)

			local trace = tostring(newPromise._values[1])
			expect(trace:find("Sample error")).to.be.ok()
			expect(
				trace:find("...Rejected because it was chained to the following Promise, which encountered an error:")
			).to.be.ok()
			expect(trace:find("%[No stack trace available")).to.be.ok()
		end)

		it("should allow callable tables", function()
			local promise = Promise.new(setmetatable({}, {
				__call = function(_, resolve)
					resolve(1)
				end,
			}))

			local called = false
			promise:andThen(setmetatable({}, {
				__call = function(_, var)
					expect(var).to.equal(1)
					called = true
				end,
			}))

			expect(called).to.equal(true)
		end)

		itSKIP("should close the thread after resolve", function()
			local count = 0
			Promise.new(function(resolve)
				count += 1
				resolve()
				Promise.delay(1):await()
				count += 1
			end)

			task.wait(1)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise.defer", function()
		it("should execute after the time event", function()
			local callCount = 0
			local promise = Promise.defer(function(resolve, reject, onCancel, nothing)
				expect(type(resolve)).to.equal("function")
				expect(type(reject)).to.equal("function")
				expect(type(onCancel)).to.equal("function")
				expect(type(nothing)).to.equal("nil")

				callCount = callCount + 1

				resolve("foo")
			end)

			expect(callCount).to.equal(0)
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)

			advanceTime()
			expect(callCount).to.equal(1)
		end)
	end)

	describe("Promise.delay", function()
		it("should schedule promise resolution", function()
			local promise = Promise.delay(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should allow for delays to be cancelled", function()
			local promise = Promise.delay(2)

			Promise.delay(1):andThen(function()
				promise:cancel()
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime()
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			advanceTime(1)
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5, 6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
			expect(promise._values[2]).to.equal(6)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6, 7)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
			expect(promise._values[2]).to.equal(7)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should allow yielding", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.resolve():andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should run andThens on a new thread", function()
			local bindable = Instance.new("BindableEvent")

			local resolve
			local parentPromise = Promise.new(function(_resolve)
				resolve = _resolve
			end)

			local deadlockedPromise = parentPromise:andThen(function()
				bindable.Event:Wait()
				return 5
			end)

			local successfulPromise = parentPromise:andThen(function()
				return "foo"
			end)

			expect(parentPromise:getStatus()).to.equal(Promise.Status.Started)
			resolve()
			expect(successfulPromise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(successfulPromise._values[1]).to.equal("foo")
			expect(deadlockedPromise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(function(...)
				badCallCount = badCallCount + 1
			end, function(...)
				argsLength, args = pack(...)
				callCount = callCount + 1
			end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.resolve(1):andThen(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(tostring(promise._values[1]):find("init.spec")).to.be.ok()
			expect(tostring(promise._values[1]):find("runExecutor")).to.be.ok()
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end, function()
				badCallCount = badCallCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(function()
				badCallCount = badCallCount + 1
			end, function(...)
				args = { ... }
				argsLength = select("#", ...)
				callCount = callCount + 1
			end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should propagate errors through multiple levels", function()
			local x, y, z
			Promise.new(function(resolve, reject)
				reject(1, 2, 3)
			end):andThen(function() end):catch(function(a, b, c)
				x, y, z = a, b, c
			end)

			expect(x).to.equal(1)
			expect(y).to.equal(2)
			expect(z).to.equal(3)
		end)

		it("should not call queued callbacks from a cancelled sub-promise", function()
			local resolve
			local count = 0

			local root = Promise.new(function(r)
				resolve = r
			end)

			root:andThen(function()
				count += 1
			end)

			root
				:andThen(function()
					count += 1
				end)
				:cancel()

			resolve("foo")

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:cancel", function()
		it("should mark promises as cancelled and not resolve or reject them", function()
			local callCount = 0
			local finallyCallCount = 0
			local promise = Promise.new(function() end)
				:andThen(function()
					callCount = callCount + 1
				end)
				:finally(function()
					finallyCallCount = finallyCallCount + 1
				end)

			promise:cancel()
			promise:cancel() -- Twice to check call counts

			expect(callCount).to.equal(0)
			expect(finallyCallCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should call the cancellation hook once", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject, onCancel)
				onCancel(function()
					callCount = callCount + 1
				end)
			end)

			promise:cancel()
			promise:cancel() -- Twice to check call count

			expect(callCount).to.equal(1)
		end)

		it("should propagate cancellations", function()
			local promise = Promise.new(function() end)

			local consumer1 = promise:andThen()
			local consumer2 = promise:andThen()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer1:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Started)

			consumer2:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer2:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should affect downstream promises", function()
			local promise = Promise.new(function() end)
			local consumer = promise:andThen()

			promise:cancel()

			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should track consumers", function()
			local pending = Promise.new(function() end)
			local p0 = Promise.resolve()
			local p1 = p0:andThen(function()
				return pending
			end)
			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end)
			local p3 = p2:andThen(function() end)

			expect(p1._parent).to.never.equal(p0)
			expect(p2._parent).to.never.equal(p1)
			expect(p2._consumers[p3]).to.be.ok()
			expect(p3._parent).to.equal(p2)
		end)

		it("should cancel resolved pending promises", function()
			local p1 = Promise.new(function() end)

			local p2 = Promise.new(function(resolve)
				resolve(p1)
			end):finally(function() end)

			p2:cancel()

			expect(p1._status).to.equal(Promise.Status.Cancelled)
			expect(p2._status).to.equal(Promise.Status.Cancelled)
		end)

		it("should close the promise thread", function()
			local count = 0
			local promise = Promise.new(function()
				count += 1
				Promise.delay(1):await()
				count += 1
			end)

			promise:cancel()
			advanceTime(2)

			expect(count).to.equal(1)
		end)
	end)

	describe("Promise:finally", function()
		it("should be called upon resolve, reject, or cancel", function()
			local callCount = 0

			local function finally()
				callCount = callCount + 1
			end

			-- Resolved promise
			Promise.new(function(resolve, reject)
				resolve()
			end):finally(finally)

			-- Chained promise
			Promise.resolve():andThen(function() end):finally(finally):finally(finally)

			-- Rejected promise
			Promise.reject():finally(finally)

			local cancelledPromise = Promise.new(function() end):finally(finally)
			cancelledPromise:cancel()

			expect(callCount).to.equal(5)
		end)

		it("should not forward return values", function()
			local value

			Promise.resolve(2)
				:finally(function()
					return 1
				end)
				:andThen(function(v)
					value = v
				end)

			expect(value).to.equal(2)
		end)

		it("should not consume rejections", function()
			local catchRan = false
			local thenRan = false
			Promise.reject(5)
				:finally(function()
					return 42
				end)
				:andThen(function()
					thenRan = true
				end)
				:catch(function(value)
					catchRan = true
					expect(value).to.equal(5)
				end)

			expect(catchRan).to.equal(true)
			expect(thenRan).to.equal(false)
		end)

		it("should wait for returned promises", function()
			local resolve
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(r)
					resolve = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("foo")
		end)

		it("should reject with a returned rejected promise's value", function()
			local reject
			local promise = Promise.reject("foo"):finally(function()
				return Promise.new(function(_, r)
					reject = r
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			reject("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			local _, value = promise:_unwrap()
			expect(value).to.equal("bar")
		end)

		it("should reject when handler errors", function()
			local errorValue = {}
			local promise = Promise.reject("bar"):finally(function()
				error(errorValue)
			end)

			local ok, value = promise:_unwrap()

			expect(ok).to.equal(false)
			expect(value).to.equal(errorValue)
		end)

		it("should not prevent cancellation", function()
			local promise = Promise.new(function() end)

			local finallyRan = false
			promise:finally(function()
				finallyRan = true
			end)

			local consumer = promise:andThen(function() end)

			consumer:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(finallyRan).to.equal(true)
		end)

		it("should propagate cancellation downwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			root:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should propagate cancellation upwards", function()
			local finallyRan = false
			local andThenRan = false
			local root = Promise.new(function() end)

			local consumer = root:finally(function()
				finallyRan = true
			end)

			consumer:cancel()

			expect(root:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(consumer:getStatus()).to.equal(Promise.Status.Cancelled)

			expect(finallyRan).to.equal(true)
			expect(andThenRan).to.equal(false)
		end)

		it("should cancel returned promise if cancelled", function()
			local internal = Promise.new(function() end)

			local promise = Promise.resolve():finally(function()
				return internal
			end)

			promise:cancel()

			expect(internal:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({ {}, {}, {} })
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = { resolve, testValues[i] }
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
			expect(b:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({ a, b })

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.all(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel pending promises if one rejects", function()
			local p = Promise.new(function() end)
			expect(Promise.all({
				Promise.resolve(),
				Promise.reject(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.all(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.fold", function()
		it("should return the initial value in a promise when the list is empty", function()
			local initialValue = {}
			local result = Promise.fold({}, function()
				error("should not be called")
			end, initialValue)

			expect(Promise.is(result)).to.equal(true)
			expect(result:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result:expect()).to.equal(initialValue)
		end)

		it("should accept promises in the list", function()
			local resolve

			local sum = Promise.fold({ Promise.new(function(r)
				resolve = r
			end), 2, 3 }, function(sum, element)
				return sum + element
			end, 0)

			resolve(1)

			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should always return a promise even if the list or reducer don't use them", function()
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.delay(1):andThenReturn(sum + element)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			advanceTime(2)
			expect(sum:getStatus()).to.equal(Promise.Status.Resolved)
			expect(sum:expect()).to.equal(6)
		end)

		it("should return the first rejected promise", function()
			local errorMessage = "foo"
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 2 then
					return Promise.reject(errorMessage)
				else
					return sum + element
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			local status, rejection = sum:awaitStatus()
			expect(status).to.equal(Promise.Status.Rejected)
			expect(rejection).to.equal(errorMessage)
		end)

		it("should return the first canceled promise", function()
			local secondPromise
			local sum = Promise.fold({ 1, 2, 3 }, function(sum, element, index)
				if index == 1 then
					return sum + element
				elseif index == 2 then
					secondPromise = Promise.delay(1):andThenReturn(sum + element)
					return secondPromise
				else
					error("this should not run if the promise is cancelled")
				end
			end, 0)
			expect(Promise.is(sum)).to.equal(true)
			expect(sum:getStatus()).to.equal(Promise.Status.Started)
			secondPromise:cancel()
			expect(sum:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.race", function()
		it("should resolve with the first settled value", function()
			local promise = Promise.race({
				Promise.resolve(1),
				Promise.resolve(2),
			}):andThen(function(value)
				expect(value).to.equal(1)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should cancel other promises", function()
			local promise = Promise.new(function() end)
			promise:andThen(function() end)
			local promises = {
				promise,
				Promise.new(function() end),
				Promise.new(function(resolve)
					resolve(2)
				end),
			}

			local promise = Promise.race(promises)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(2)
			expect(promises[1]:getStatus()).to.equal(Promise.Status.Started)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Resolved)

			local p = Promise.new(function() end)
			expect(Promise.race({
				Promise.reject(),
				Promise.resolve(),
				p,
			}):getStatus()).to.equal(Promise.Status.Rejected)
			expect(p:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should error if a non-array table is passed in", function()
			local ok, err = pcall(function()
				Promise.race(Promise.new(function() end))
			end)

			expect(ok).to.be.ok()
			expect(err:find("Non%-promise")).to.be.ok()
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.race(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise.promisify", function()
		it("should wrap functions", function()
			local function test(n)
				return n + 1
			end

			local promisified = Promise.promisify(test)
			local promise = promisified(1)
			local success, result = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(result).to.equal(2)
		end)

		it("should catch errors after a yield", function()
			local bindable = Instance.new("BindableEvent")
			local test = Promise.promisify(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			local promise = test()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise.tap", function()
		it("should thread through values", function()
			local first, second

			Promise.resolve(1)
				:andThen(function(v)
					return v + 1
				end)
				:tap(function(v)
					first = v
					return v + 1
				end)
				:andThen(function(v)
					second = v
				end)

			expect(first).to.equal(2)
			expect(second).to.equal(2)
		end)

		it("should chain onto promises", function()
			local resolveInner, finalValue

			local promise = Promise.resolve(1)
				:tap(function()
					return Promise.new(function(resolve)
						resolveInner = resolve
					end)
				end)
				:andThen(function(v)
					finalValue = v
				end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(finalValue).to.never.be.ok()

			resolveInner(1)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(finalValue).to.equal(1)
		end)
	end)

	describe("Promise.try", function()
		it("should catch synchronous errors", function()
			local errorText
			Promise.try(function()
				error("errortext")
			end):catch(function(e)
				errorText = tostring(e)
			end)

			expect(errorText:find("errortext")).to.be.ok()
		end)

		it("should reject with error objects", function()
			local object = {}
			local success, value = Promise.try(function()
				error(object)
			end):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal(object)
		end)

		it("should catch asynchronous errors", function()
			local bindable = Instance.new("BindableEvent")
			local promise = Promise.try(function()
				bindable.Event:Wait()
				error("errortext")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			bindable:Fire()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(tostring(promise._values[1]):find("errortext")).to.be.ok()
		end)
	end)

	describe("Promise:andThenReturn", function()
		it("should return the given values", function()
			local value1, value2

			Promise.resolve():andThenReturn(1, 2):andThen(function(one, two)
				value1 = one
				value2 = two
			end)

			expect(value1).to.equal(1)
			expect(value2).to.equal(2)
		end)
	end)

	describe("Promise:andThenCall", function()
		it("should call the given function with arguments", function()
			local value1, value2
			Promise.resolve():andThenCall(function(a, b)
				value1 = a
				value2 = b
			end, 3, 4)

			expect(value1).to.equal(3)
			expect(value2).to.equal(4)
		end)
	end)

	describe("Promise.some", function()
		it("should resolve once the goal is reached", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.reject(),
				Promise.resolve(2),
			}, 2)
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should error if the goal can't be reached", function()
			expect(Promise.some({
				Promise.resolve(),
				Promise.reject(),
			}, 2):getStatus()).to.equal(Promise.Status.Rejected)

			local reject
			local p = Promise.some({
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject("foo")
			expect(p:getStatus()).to.equal(Promise.Status.Rejected)
			expect(p._values[1]).to.equal("foo")
		end)

		it("should cancel pending Promises once the goal is reached", function()
			local resolve
			local pending1 = Promise.new(function() end)
			local pending2 = Promise.new(function(r)
				resolve = r
			end)

			local some = Promise.some({
				pending1,
				pending2,
				Promise.resolve(),
			}, 2)

			expect(some:getStatus()).to.equal(Promise.Status.Started)
			expect(pending1:getStatus()).to.equal(Promise.Status.Started)
			expect(pending2:getStatus()).to.equal(Promise.Status.Started)

			resolve()

			expect(some:getStatus()).to.equal(Promise.Status.Resolved)
			expect(pending1:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(pending2:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should error if passed a non-number", function()
			expect(function()
				Promise.some({}, "non-number")
			end).to.throw()
		end)

		it("should return an empty array if amount is 0", function()
			local p = Promise.some({
				Promise.resolve(2),
			}, 0)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(0)
		end)

		it("should not return extra values", function()
			local p = Promise.some({
				Promise.resolve(1),
				Promise.resolve(2),
				Promise.resolve(3),
				Promise.resolve(4),
			}, 2)

			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#p._values[1]).to.equal(2)
			expect(p._values[1][1]).to.equal(1)
			expect(p._values[1][2]).to.equal(2)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.some(promises, 3):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)

		describe("Promise.any", function()
			it("should return the value directly", function()
				local p = Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.resolve(1),
				})

				expect(p:getStatus()).to.equal(Promise.Status.Resolved)
				expect(p._values[1]).to.equal(1)
			end)

			it("should error if all are rejected", function()
				expect(Promise.any({
					Promise.reject(),
					Promise.reject(),
					Promise.reject(),
				}):getStatus()).to.equal(Promise.Status.Rejected)
			end)
		end)
	end)

	describe("Promise.allSettled", function()
		it("should resolve with an array of PromiseStatuses", function()
			local reject
			local p = Promise.allSettled({
				Promise.resolve(),
				Promise.reject(),
				Promise.resolve(),
				Promise.new(function(_, r)
					reject = r
				end),
			})

			expect(p:getStatus()).to.equal(Promise.Status.Started)
			reject()
			expect(p:getStatus()).to.equal(Promise.Status.Resolved)
			expect(p._values[1][1]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][2]).to.equal(Promise.Status.Rejected)
			expect(p._values[1][3]).to.equal(Promise.Status.Resolved)
			expect(p._values[1][4]).to.equal(Promise.Status.Rejected)
		end)

		it("should cancel promises if it is cancelled", function()
			local p = Promise.new(function() end)
			p:andThen(function() end)

			local promises = {
				Promise.new(function() end),
				Promise.new(function() end),
				p,
			}

			Promise.allSettled(promises):cancel()

			expect(promises[1]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[2]:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(promises[3]:getStatus()).to.equal(Promise.Status.Started)
		end)
	end)

	describe("Promise:await", function()
		it("should return the correct values", function()
			local promise = Promise.resolve(5, 6, nil, 7)

			local a, b, c, d, e = promise:await()

			expect(a).to.equal(true)
			expect(b).to.equal(5)
			expect(c).to.equal(6)
			expect(d).to.equal(nil)
			expect(e).to.equal(7)
		end)

		it("should work if yielding is needed", function()
			local ran = false
			task.spawn(function()
				local _, actualTime = Promise.delay(1):await()
				expect(type(actualTime)).to.equal("number")
				ran = true
			end)

			advanceTime(2)
			expect(ran).to.equal(true)
		end)
	end)

	describe("Promise:expect", function()
		it("should throw the correct values", function()
			local rejectionValue = {}
			local promise = Promise.reject(rejectionValue)

			local success, value = pcall(function()
				promise:expect()
			end)

			expect(success).to.equal(false)
			expect(value).to.equal(rejectionValue)
		end)
	end)

	describe("Promise:now", function()
		it("should resolve if the Promise is resolved", function()
			local success, value = Promise.resolve("foo"):now():_unwrap()

			expect(success).to.equal(true)
			expect(value).to.equal("foo")
		end)

		it("should reject if the Promise is not resolved", function()
			local success, value = Promise.new(function() end):now():_unwrap()

			expect(success).to.equal(false)
			expect(Promise.Error.isKind(value, "NotResolvedInTime")).to.equal(true)
		end)

		it("should reject with a custom rejection value", function()
			local success, value = Promise.new(function() end):now("foo"):_unwrap()

			expect(success).to.equal(false)
			expect(value).to.equal("foo")
		end)
	end)

	describe("Promise.each", function()
		it("should iterate", function()
			local ok, result = Promise.each({
				"foo",
				"bar",
				"baz",
				"qux",
			}, function(...)
				return { ... }
			end):_unwrap()

			expect(ok).to.equal(true)
			expect(result[1][1]).to.equal("foo")
			expect(result[1][2]).to.equal(1)
			expect(result[2][1]).to.equal("bar")
			expect(result[2][2]).to.equal(2)
			expect(result[3][1]).to.equal("baz")
			expect(result[3][2]).to.equal(3)
			expect(result[4][1]).to.equal("qux")
			expect(result[4][2]).to.equal(4)
		end)

		it("should iterate serially", function()
			local resolves = {}
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function(resolve)
					table.insert(resolves, function()
						resolve(value:upper())
					end)
				end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(#resolves).to.equal(1)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.never.be.ok()

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.equal(1)
			expect(callCounts[3]).to.equal(1)

			table.remove(resolves, 1)()

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(type(promise._values[1])).to.equal("table")
			expect(type(promise._values[2])).to.equal("nil")

			local result = promise._values[1]

			expect(result[1]).to.equal("FOO")
			expect(result[2]).to.equal("BAR")
			expect(result[3]).to.equal("BAZ")
		end)

		it("should reject with the value if the predicate promise rejects", function()
			local promise = Promise.each({ 1, 2, 3 }, function()
				return Promise.reject("foobar")
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
		end)

		it("should allow Promises to be in the list and wait when it gets to them", function()
			local innerResolve
			local innerPromise = Promise.new(function(resolve)
				innerResolve = resolve
			end)

			local promise = Promise.each({
				innerPromise,
			}, function(value)
				return value * 2
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			innerResolve(2)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1][1]).to.equal(4)
		end)

		it("should reject with the value if a Promise from the list rejects", function()
			local called = false
			local promise = Promise.each({ 1, 2, Promise.reject("foobar") }, function(value)
				called = true
				return "never"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("foobar")
			expect(called).to.equal(false)
		end)

		it("should reject immediately if there's a cancelled Promise in the list initially", function()
			local cancelled = Promise.new(function() end)
			cancelled:cancel()

			local called = false
			local promise = Promise.each({ 1, 2, cancelled }, function()
				called = true
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(called).to.equal(false)
			expect(promise._values[1].kind).to.equal(Promise.Error.Kind.AlreadyCancelled)
		end)

		it("should stop iteration if Promise.each is cancelled", function()
			local callCounts = {}

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				callCounts[index] = (callCounts[index] or 0) + 1

				return Promise.new(function() end)
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()

			promise:cancel()

			expect(promise:getStatus()).to.equal(Promise.Status.Cancelled)
			expect(callCounts[1]).to.equal(1)
			expect(callCounts[2]).to.never.be.ok()
		end)

		it("should cancel the Promise returned from the predicate if Promise.each is cancelled", function()
			local innerPromise

			local promise = Promise.each({
				"foo",
				"bar",
				"baz",
			}, function(value, index)
				innerPromise = Promise.new(function() end)
				return innerPromise
			end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)

		it("should cancel Promises in the list if Promise.each is cancelled", function()
			local innerPromise = Promise.new(function() end)

			local promise = Promise.each({ innerPromise }, function() end)

			promise:cancel()

			expect(innerPromise:getStatus()).to.equal(Promise.Status.Cancelled)
		end)
	end)

	describe("Promise.retry", function()
		it("should retry N times", function()
			local counter = 0

			local promise = Promise.retry(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 5 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 5, "foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)

		it("should reject if threshold is exceeded", function()
			local promise = Promise.retry(function()
				return Promise.reject("fail")
			end, 5)

			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal("fail")
		end)
	end)

	describe("Promise.retryWithDelay", function()
		it("should retry after a delay", function()
			local counter = 0

			local promise = Promise.retryWithDelay(function(parameter)
				expect(parameter).to.equal("foo")

				counter = counter + 1

				if counter == 3 then
					return Promise.resolve("ok")
				end

				return Promise.reject("fail")
			end, 3, 10, "foo")

			expect(counter).to.equal(1)

			advanceTime(11)

			expect(counter).to.equal(2)

			advanceTime(11)

			expect(counter).to.equal(3)

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("ok")
		end)
	end)

	describe("Promise.fromEvent", function()
		it("should convert a Promise into an event", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)

		it("should convert a Promise into an event with the predicate", function()
			local event = Instance.new("BindableEvent")

			local promise = Promise.fromEvent(event.Event, function(param)
				return param == "foo"
			end)

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("bar")

			expect(promise:getStatus()).to.equal(Promise.Status.Started)

			event:Fire("foo")

			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal("foo")
		end)
	end)

	describe("Promise.is", function()
		it("should work with current version", function()
			local promise = Promise.resolve(1)

			expect(Promise.is(promise)).to.equal(true)
		end)

		it("should work with any object with an andThen", function()
			local obj = {
				andThen = function()
					return 1
				end,
			}

			expect(Promise.is(obj)).to.equal(true)
		end)

		it("should work with older promises", function()
			local OldPromise = {}
			OldPromise.prototype = {}
			OldPromise.__index = OldPromise.prototype

			function OldPromise.prototype:andThen() end

			local oldPromise = setmetatable({}, OldPromise)

			expect(Promise.is(oldPromise)).to.equal(true)
		end)
	end)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000491</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="255">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">mattschrubb_zoneplus@3.2.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000492</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="256">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">zoneplus</string>
							<string name="ScriptGuid">{D74D62CF-446A-4080-BC50-9C95F39C4383}</string>
							<ProtectedString name="Source"><![CDATA[-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local localPlayer = runService:IsClient() and players.LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local Enum_ = require(script.Enum)
local enum = Enum_.enums
local Janitor = require(script.Janitor)
local Signal = require(script.Signal)
local ZonePlusReference = require(script.ZonePlusReference)
local referenceObject = ZonePlusReference.getObject()
local zoneControllerModule = script.ZoneController
local trackerModule = zoneControllerModule.Tracker
local collectiveWorldModelModule = zoneControllerModule.CollectiveWorldModel
local ZoneController = require(zoneControllerModule)
local referenceLocation = (game:GetService("RunService"):IsClient() and "Client") or "Server"
local referencePresent = referenceObject and referenceObject:FindFirstChild(referenceLocation)
if referencePresent then
	return require(referenceObject.Value)
end

local Zone = {}
Zone.__index = Zone
if not referencePresent then
	ZonePlusReference.addToReplicatedStorage()
end
Zone.enum = enum



-- CONSTRUCTORS
function Zone.new(container)
	local self = {}
	setmetatable(self, Zone)
	
	-- Validate container
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	local containerType = typeof(container)
	if not(containerType == "table" or containerType == "Instance") then
		error(INVALID_TYPE_WARNING)
	end

	-- Configurable
	self.accuracy = enum.Accuracy.High
	self.autoUpdate = true
	self.respectUpdateQueue = true
	--self.maxPartsAddition = 20
	--self.ignoreRecommendedMaxParts = false

	-- Variable
	local janitor = Janitor.new()
	self.janitor = janitor
	self._updateConnections = janitor:add(Janitor.new(), "destroy")
	self.container = container
	self.zoneParts = {}
	self.overlapParams = {}
	self.region = nil
	self.volume = nil
	self.boundMin = nil
	self.boundMax = nil
	self.recommendedMaxParts = nil
	self.zoneId = httpService:GenerateGUID()
	self.activeTriggers = {}
	self.occupants = {}
	self.trackingTouchedTriggers = {}
	self.enterDetection = enum.Detection.Centre
	self.exitDetection = enum.Detection.Centre
	self._currentEnterDetection = nil -- This will update automatically internally
	self._currentExitDetection = nil -- This will also update automatically internally
	self.totalPartVolume = 0
	self.allZonePartsAreBlocks = true
	self.trackedItems = {}
	self.settingsGroupName = nil
	self.worldModel = workspace
	self.onItemDetails = {}
	self.itemsToUntrack = {}

	-- This updates _currentEnterDetection and _currentExitDetection right away to prevent nil comparisons
	ZoneController.updateDetection(self)

	-- Signals
	self.updated = janitor:add(Signal.new(), "destroy")
	local triggerTypes = {
		"player",
		"part",
		"localPlayer",
		"item"
	}
	local triggerEvents = {
		"entered",
		"exited",
	}
	for _, triggerType in pairs(triggerTypes) do
		local activeConnections = 0
		local previousActiveConnections = 0
		for i, triggerEvent in pairs(triggerEvents) do
			-- this enables us to determine when a developer connects to an event
			-- so that we can act accoridngly (i.e. begin or end a checker loop)
			local signal = janitor:add(Signal.new(true), "destroy")
			local triggerEventUpper = triggerEvent:sub(1,1):upper()..triggerEvent:sub(2)
			local signalName = triggerType..triggerEventUpper
			self[signalName] = signal
			signal.connectionsChanged:Connect(function(increment)
				if triggerType == "localPlayer" and not localPlayer and increment == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(triggerEventUpper))
				end
				previousActiveConnections = activeConnections
				activeConnections += increment
				if previousActiveConnections == 0 and activeConnections > 0 then
					-- At least 1 connection active, begin loop
					ZoneController._registerConnection(self, triggerType, triggerEventUpper)
				elseif previousActiveConnections > 0 and activeConnections == 0 then
					-- All connections have disconnected, end loop
					ZoneController._deregisterConnection(self, triggerType)
				end
			end)
		end
	end

	-- Setup touched receiver functions where applicable
	Zone.touchedConnectionActions = {}
	for _, triggerType in pairs(triggerTypes) do
		local methodName = ("_%sTouchedZone"):format(triggerType)
		local correspondingMethod = self[methodName]
		if correspondingMethod then
			self.trackingTouchedTriggers[triggerType] = {}
			Zone.touchedConnectionActions[triggerType] = function(touchedItem)
				correspondingMethod(self, touchedItem)
			end
		end
	end

	-- This constructs the zones boundaries, region, etc
	self:_update()

	-- Register/deregister zone
	ZoneController._registerZone(self)
	janitor:add(function()
		ZoneController._deregisterZone(self)
	end, true)
	
	return self
end

function Zone.fromRegion(cframe, size)
	local MAX_PART_SIZE = 2024
	local container = Instance.new("Model")
	local function createCube(cubeCFrame, cubeSize)
		if cubeSize.X > MAX_PART_SIZE or cubeSize.Y > MAX_PART_SIZE or cubeSize.Z > MAX_PART_SIZE then
			local quarterSize = cubeSize * 0.25
			local halfSize = cubeSize * 0.5
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
		else
			local part = Instance.new("Part")
			part.CFrame = cubeCFrame
			part.Size = cubeSize
			part.Anchored = true
			part.Parent = container
		end
	end
	createCube(cframe, size)
	local zone = Zone.new(container)
	zone:relocate()
	return zone
end



-- PRIVATE METHODS
function Zone:_calculateRegion(tableOfParts, dontRound)
	local bounds = {["Min"] = {}, ["Max"] = {}}
	for boundType, details in pairs(bounds) do
		details.Values = {}
		function details.parseCheck(v, currentValue)
			if boundType == "Min" then
				return (v <= currentValue)
			elseif boundType == "Max" then
				return (v >= currentValue)
			end
		end
		function details:parse(valuesToParse)
			for i,v in pairs(valuesToParse) do
				local currentValue = self.Values[i] or v
				if self.parseCheck(v, currentValue) then
					self.Values[i] = v
				end
			end
		end
	end
	for _, part in pairs(tableOfParts) do
		local sizeHalf = part.Size * 0.5
		local corners = {
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
		}
		for _, cornerCFrame in pairs(corners) do
			local x, y, z = cornerCFrame:GetComponents()
			local values = {x, y, z}
			bounds.Min:parse(values)
			bounds.Max:parse(values)
		end
	end
	local minBound = {}
	local maxBound = {}
	-- Rounding a regions coordinates to multiples of 4 ensures the region optimises the region
	-- by ensuring it aligns on the voxel grid
	local function roundToFour(to_round)
		local ROUND_TO = 4
		local divided = (to_round+ROUND_TO/2) / ROUND_TO
		local rounded = ROUND_TO * math.floor(divided)
		return rounded
	end
	for boundName, boundDetail in pairs(bounds) do
		for _, v in pairs(boundDetail.Values) do
			local newTable = (boundName == "Min" and minBound) or maxBound
			local newV = v
			if not dontRound then
				local roundOffset = (boundName == "Min" and -2) or 2
				newV = roundToFour(v+roundOffset) -- +-2 to ensures the zones region is not rounded down/up
			end
			table.insert(newTable, newV)
		end
	end
	local boundMin = Vector3.new(unpack(minBound))
	local boundMax = Vector3.new(unpack(maxBound))
	local region = Region3.new(boundMin, boundMax)
	return region, boundMin, boundMax
end

function Zone:_displayBounds()
	if not self.displayBoundParts then
		self.displayBoundParts = true
		local boundParts = {BoundMin = self.boundMin, BoundMax = self.boundMax}
		for boundName, boundCFrame in pairs(boundParts) do
			local part = Instance.new("Part")
			part.Anchored = true
			part.CanCollide = false
			part.Transparency = 0.5
			part.Size = Vector3.new(1,1,1)
			part.Color = Color3.fromRGB(255,0,0)
			part.CFrame = CFrame.new(boundCFrame)
			part.Name = boundName
			part.Parent = workspace
			self.janitor:add(part, "Destroy")
		end
	end
end

function Zone:_update()
	local container = self.container
	local zoneParts = {}
	local updateQueue = 0
	self._updateConnections:clean()

	local containerType = typeof(container)
	local holders = {}
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	if containerType == "table" then
		for _, part in pairs(container) do
			if part:IsA("BasePart") then
				table.insert(zoneParts, part)
			end
		end
	elseif containerType == "Instance" then
		if container:IsA("BasePart") then
			table.insert(zoneParts, container)
		else
			table.insert(holders, container)
			for _, part in pairs(container:GetDescendants()) do
				if part:IsA("BasePart") then
					table.insert(zoneParts, part)
				else
					table.insert(holders, part)
				end
			end
		end
	end
	self.zoneParts = zoneParts
	self.overlapParams = {}
	
	local allZonePartsAreBlocksNew = true
	for _, zonePart in pairs(zoneParts) do
		local success, shapeName = pcall(function() return zonePart.Shape.Name end)
		if shapeName ~= "Block" then
			allZonePartsAreBlocksNew = false
		end
	end
	self.allZonePartsAreBlocks = allZonePartsAreBlocksNew
	
	local zonePartsWhitelist = OverlapParams.new()
	zonePartsWhitelist.FilterType = Enum.RaycastFilterType.Whitelist
	zonePartsWhitelist.MaxParts = #zoneParts
	zonePartsWhitelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsWhitelist = zonePartsWhitelist

	local zonePartsIgnorelist = OverlapParams.new()
	zonePartsIgnorelist.FilterType = Enum.RaycastFilterType.Blacklist
	zonePartsIgnorelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsIgnorelist = zonePartsIgnorelist
	
	-- this will call update on the zone when the container parts size or position changes, and when a
	-- child is removed or added from a holder (anything which isn't a basepart)
	local function update()
		if self.autoUpdate then
			local executeTime = os.clock()
			if self.respectUpdateQueue then
				updateQueue += 1
				executeTime += 0.1
			end
			local updateConnection
			updateConnection = runService.Heartbeat:Connect(function()
				if os.clock() >= executeTime then
					updateConnection:Disconnect()
					if self.respectUpdateQueue then
						updateQueue -= 1
					end
					if updateQueue == 0 and self.zoneId then
						self:_update()
					end
				end
			end)
		end
	end
	local partProperties = {"Size", "Position"}
	local function verifyDefaultCollision(instance)
		if instance.CollisionGroupId ~= 0 then
			error("Zone parts must belong to the 'Default' (0) CollisionGroup! Consider using zone:relocate() if you wish to move zones outside of workspace to prevent them interacting with other parts.")
		end
	end
	for _, part in pairs(zoneParts) do
		for _, prop in pairs(partProperties) do
			self._updateConnections:add(part:GetPropertyChangedSignal(prop):Connect(update), "Disconnect")
		end
		verifyDefaultCollision(part)
		self._updateConnections:add(part:GetPropertyChangedSignal("CollisionGroupId"):Connect(function()
			verifyDefaultCollision(part)
		end), "Disconnect")
	end
	local containerEvents = {"ChildAdded", "ChildRemoved"}
	for _, holder in pairs(holders) do
		for _, event in pairs(containerEvents) do
			self._updateConnections:add(self.container[event]:Connect(function(child)
				if child:IsA("BasePart") then
					update()
				end
			end), "Disconnect")
		end
	end
	
	local region, boundMin, boundMax = self:_calculateRegion(zoneParts)
	local exactRegion, _, _ = self:_calculateRegion(zoneParts, true)
	self.region = region
	self.exactRegion = exactRegion
	self.boundMin = boundMin
	self.boundMax = boundMax
	local rSize = region.Size
	self.volume = rSize.X*rSize.Y*rSize.Z
	
	-- Update: I was going to use this for the old part detection until the CanTouch property was released
	-- everything below is now irrelevant however I'll keep just in case I use again for future
	-------------------------------------------------------------------------------------------------
	-- When a zones region is determined, we also check for parts already existing within the zone
	-- these parts are likely never to move or interact with the zone, so we set the number of these
	-- to the baseline MaxParts value. 'recommendMaxParts' is then determined through the sum of this
	-- and maxPartsAddition. This ultimately optimises region checks as they can be generated with
	-- minimal MaxParts (i.e. recommendedMaxParts can be used instead of math.huge every time)
	--[[
	local result = self.worldModel:FindPartsInRegion3(region, nil, math.huge)
	local maxPartsBaseline = #result
	self.recommendedMaxParts = maxPartsBaseline + self.maxPartsAddition
	--]]
	
	self:_updateTouchedConnections()
	
	self.updated:Fire()
end

function Zone:_updateOccupants(trackerName, newOccupants)
	local previousOccupants = self.occupants[trackerName]
	if not previousOccupants then
		previousOccupants = {}
		self.occupants[trackerName] = previousOccupants
	end
	local signalsToFire = {}
	for occupant, prevItem in pairs(previousOccupants) do
		local newItem = newOccupants[occupant]
		if newItem == nil or newItem ~= prevItem then
			previousOccupants[occupant] = nil
			if not signalsToFire.exited then
				signalsToFire.exited = {}
			end
			table.insert(signalsToFire.exited, occupant)
		end
	end
	for occupant, _ in pairs(newOccupants) do
		if previousOccupants[occupant] == nil then
			local isAPlayer = occupant:IsA("Player")
			previousOccupants[occupant] = (isAPlayer and occupant.Character) or true
			if not signalsToFire.entered then
				signalsToFire.entered = {}
			end
			table.insert(signalsToFire.entered, occupant)
		end
	end 
	return signalsToFire
end

function Zone:_formTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:clean()
	else
		touchedJanitor = self.janitor:add(Janitor.new(), "destroy")
		self[touchedJanitorName] = touchedJanitor
	end
	self:_updateTouchedConnection(triggerType)
end

function Zone:_updateTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if not touchedJanitor then return end
	for _, basePart in pairs(self.zoneParts) do
		touchedJanitor:add(basePart.Touched:Connect(self.touchedConnectionActions[triggerType], self), "Disconnect")
	end
end

function Zone:_updateTouchedConnections()
	for triggerType, _ in pairs(self.touchedConnectionActions) do
		local touchedJanitorName = "_touchedJanitor"..triggerType
		local touchedJanitor = self[touchedJanitorName]
		if touchedJanitor then
			touchedJanitor:cleanup()
			self:_updateTouchedConnection(triggerType)
		end
	end
end

function Zone:_disconnectTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:cleanup()
		self[touchedJanitorName] = nil
	end
end

local function round(number, decimalPlaces)
	return math.round(number * 10^decimalPlaces) * 10^-decimalPlaces
end
function Zone:_partTouchedZone(part)
	local trackingDict = self.trackingTouchedTriggers["part"]
	if trackingDict[part] then return end
	local nextCheck = 0
	local verifiedEntrance = false
	local enterPosition = part.Position
	local enterTime = os.clock()
	local partJanitor = self.janitor:add(Janitor.new(), "destroy")
	trackingDict[part] = partJanitor
	local instanceClassesToIgnore = {Seat = true, VehicleSeat = true}
	local instanceNamesToIgnore = {HumanoidRootPart = true}
	if not (instanceClassesToIgnore[part.ClassName] or not instanceNamesToIgnore[part.Name])  then
		part.CanTouch = false
	end
	--
	local partVolume = round((part.Size.X * part.Size.Y * part.Size.Z), 5)
	self.totalPartVolume += partVolume
	--
	partJanitor:add(heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			----
			local cooldown = enum.Accuracy.getProperty(self.accuracy)
			nextCheck = clockTime + cooldown
			----

			-- We initially perform a singular point check as this is vastly more lightweight than a large part check
			-- If the former returns false, perform a whole part check in case the part is on the outer bounds.
			local withinZone = self:findPoint(part.CFrame)
			if not withinZone then
				withinZone = self:findPart(part)
			end
			if not verifiedEntrance then
				if withinZone then
					verifiedEntrance = true
					self.partEntered:Fire(part)
				elseif (part.Position - enterPosition).Magnitude > 1.5 and clockTime - enterTime >= cooldown then
					-- Even after the part has exited the zone, we track it for a brief period of time based upon the criteria
					-- in the line above to ensure the .touched behaviours are not abused
					partJanitor:cleanup()
				end
			elseif not withinZone then
				verifiedEntrance = false
				enterPosition = part.Position
				enterTime = os.clock()
				self.partExited:Fire(part)
			end
		end
	end), "Disconnect")
	partJanitor:add(function()
		trackingDict[part] = nil
		part.CanTouch = true
		self.totalPartVolume = round((self.totalPartVolume - partVolume), 5)
	end, true)
end

local partShapeActions = {
	["Ball"] = function(part)
		return "GetPartBoundsInRadius", {part.Position, part.Size.X}
	end,
	["Block"] = function(part)
		return "GetPartBoundsInBox", {part.CFrame, part.Size}
	end,
	["Other"] = function(part)
		return "GetPartsInPart", {part}
	end,
}
function Zone:_getRegionConstructor(part, overlapParams)
	local success, shapeName = pcall(function() return part.Shape.Name end)
	local methodName, args
	if success and self.allZonePartsAreBlocks then
		local action = partShapeActions[shapeName]
		if action then
			methodName, args = action(part)
		end
	end
	if not methodName then
		methodName, args = partShapeActions.Other(part)
	end
	if overlapParams then
		table.insert(args, overlapParams)
	end
	return methodName, args
end



-- PUBLIC METHODS
function Zone:findLocalPlayer()
	if not localPlayer then
		error("Can only call 'findLocalPlayer' on the client!")
	end
	return self:findPlayer(localPlayer)
end

function Zone:_find(trackerName, item)
	ZoneController.updateDetection(self)
	local tracker = ZoneController.trackers[trackerName]
	local touchingZones = ZoneController.getTouchingZones(item, false, self._currentEnterDetection, tracker)
	for _, zone in pairs(touchingZones) do
		if zone == self then
			return true
		end
	end
	return false
end

function Zone:findPlayer(player)
	local character = player.Character
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	return self:_find("player", player.Character)
end

function Zone:findItem(item)
	return self:_find("item", item)
end

function Zone:findPart(part)
	local methodName, args = self:_getRegionConstructor(part, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(part, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:getCheckerPart()
	local checkerPart = self.checkerPart
	if not checkerPart then
		checkerPart = self.janitor:add(Instance.new("Part"), "Destroy")
		checkerPart.Size = Vector3.new(0.1, 0.1, 0.1)
		checkerPart.Name = "ZonePlusCheckerPart"
		checkerPart.Anchored = true
		checkerPart.Transparency = 1
		checkerPart.CanCollide = false
		self.checkerPart = checkerPart
	end
	local checkerParent = self.worldModel
	if checkerParent == workspace then
		checkerParent = ZoneController.getWorkspaceContainer()
	end
	if checkerPart.Parent ~= checkerParent then
		checkerPart.Parent = checkerParent
	end
	return checkerPart
end

function Zone:findPoint(positionOrCFrame)
	local cframe = positionOrCFrame
	if typeof(positionOrCFrame) == "Vector3" then
		cframe = CFrame.new(positionOrCFrame)
	end
	local checkerPart = self:getCheckerPart()
	checkerPart.CFrame = cframe
	--checkerPart.Parent = self.worldModel
	local methodName, args = self:_getRegionConstructor(checkerPart, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(self.checkerPart, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:_getAll(trackerName)
	ZoneController.updateDetection(self)
	local itemsArray = {}
	local zonesAndOccupants = ZoneController._getZonesAndItems(trackerName, {self = true}, self.volume, false, self._currentEnterDetection)
	local occupantsDict = zonesAndOccupants[self]
	if occupantsDict then
		for item, _ in pairs(occupantsDict) do
			table.insert(itemsArray, item)
		end
	end
	return itemsArray
end

function Zone:getPlayers()
	return self:_getAll("player")
end

function Zone:getItems()
	return self:_getAll("item")
end

function Zone:getParts()
	-- This is designed for infrequent 'one off' use
	-- If you plan on checking for parts within a zone frequently, it's recommended you
	-- use the .partEntered and .partExited events instead.
	local partsArray = {}
	if self.activeTriggers["part"] then
		local trackingDict = self.trackingTouchedTriggers["part"]
		for part, _ in pairs(trackingDict) do
			table.insert(partsArray, part)
		end
		return partsArray
	end
	local partsInRegion = self.worldModel:GetPartBoundsInBox(self.region.CFrame, self.region.Size, self.overlapParams.zonePartsIgnorelist)
	for _, part in pairs(partsInRegion) do
		if self:findPart(part) then
			table.insert(partsArray, part)
		end
	end
	return partsArray
end

function Zone:getRandomPoint()
	local region = self.exactRegion
	local size = region.Size
	local cframe = region.CFrame
	local random = Random.new()
	local randomCFrame
	local success, touchingZoneParts
	local pointIsWithinZone
	repeat
		randomCFrame = cframe * CFrame.new(random:NextNumber(-size.X/2,size.X/2), random:NextNumber(-size.Y/2,size.Y/2), random:NextNumber(-size.Z/2,size.Z/2))
		success, touchingZoneParts = self:findPoint(randomCFrame)
		if success then
			pointIsWithinZone = true
		end
	until pointIsWithinZone
	local randomVector = randomCFrame.Position
	return randomVector, touchingZoneParts
end

function Zone:setAccuracy(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Accuracy[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Accuracy.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.accuracy = enumId
end

function Zone:setDetection(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Detection[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Detection.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.enterDetection = enumId
	self.exitDetection = enumId
end

function Zone:trackItem(instance)
	local isBasePart = instance:IsA("BasePart")
	local isCharacter = false
	if not isBasePart then
		isCharacter = instance:FindFirstChildOfClass("Humanoid") and instance:FindFirstChild("HumanoidRootPart")
	end

	assert(isBasePart or isCharacter, "Only BaseParts or Characters/NPCs can be tracked!")

	if self.trackedItems[instance] then
		return
	end
	if self.itemsToUntrack[instance] then
		self.itemsToUntrack[instance] = nil
	end

	local itemJanitor = self.janitor:add(Janitor.new(), "destroy")
	local itemDetail = {
		janitor = itemJanitor,
		item = instance,
		isBasePart = isBasePart,
		isCharacter = isCharacter,
	}
	self.trackedItems[instance] = itemDetail

	itemJanitor:add(instance.AncestryChanged:Connect(function()
		if not instance:IsDescendantOf(game) then
			self:untrackItem(instance)
		end
	end), "Disconnect")

	local Tracker = require(trackerModule)
	Tracker.itemAdded:Fire(itemDetail)
end

function Zone:untrackItem(instance)
	local itemDetail = self.trackedItems[instance]
	if itemDetail then
		itemDetail.janitor:destroy()
	end
	self.trackedItems[instance] = nil

	local Tracker = require(trackerModule)
	Tracker.itemRemoved:Fire(itemDetail)
end

function Zone:bindToGroup(settingsGroupName)
	self:unbindFromGroup()
	local group = ZoneController.getGroup(settingsGroupName) or ZoneController.setGroup(settingsGroupName)
	group._memberZones[self.zoneId] = self
	self.settingsGroupName = settingsGroupName
end

function Zone:unbindFromGroup()
	if self.settingsGroupName then
		local group = ZoneController.getGroup(self.settingsGroupName)
		if group then
			group._memberZones[self.zoneId] = nil
		end
		self.settingsGroupName = nil
	end
end

function Zone:relocate()
	if self.hasRelocated then
		return
	end

	local CollectiveWorldModel = require(collectiveWorldModelModule)
	local worldModel = CollectiveWorldModel.setupWorldModel(self)
	self.worldModel = worldModel
	self.hasRelocated = true
	
	local relocationContainer = self.container
	if typeof(relocationContainer) == "table" then
		relocationContainer = Instance.new("Folder")
		for _, zonePart in pairs(self.zoneParts) do
			zonePart.Parent = relocationContainer
		end
	end
	self.relocationContainer = self.janitor:add(relocationContainer, "Destroy", "RelocationContainer")
	relocationContainer.Parent = worldModel
end

function Zone:_onItemCallback(eventName, desiredValue, instance, callbackFunction)
	local detail = self.onItemDetails[instance]
	if not detail then
		detail = {}
		self.onItemDetails[instance] = detail
	end
	if #detail == 0 then
		self.itemsToUntrack[instance] = true
	end
	table.insert(detail, instance)
	self:trackItem(instance)

	local function triggerCallback()
		callbackFunction()
		if self.itemsToUntrack[instance] then
			self.itemsToUntrack[instance] = nil
			self:untrackItem(instance)
		end
	end

	local inZoneAlready = self:findItem(instance)
	if inZoneAlready == desiredValue then
		triggerCallback()
	else
		local connection
		connection = self[eventName]:Connect(function(item)
			if connection and item == instance then
				connection:Disconnect()
				connection = nil
				triggerCallback()
			end
		end)
		--[[
		if typeof(expireAfterSeconds) == "number" then
			task.delay(expireAfterSeconds, function()
				if connection ~= nil then
					print("EXPIRE!")
					connection:Disconnect()
					connection = nil
					triggerCallback()
				end
			end)
		end
		--]]
	end
end

function Zone:onItemEnter(...)
	self:_onItemCallback("itemEntered", true, ...)
end

function Zone:onItemExit(...)
	self:_onItemCallback("itemExited", false, ...)
end

function Zone:destroy()
	self:unbindFromGroup()
	self.janitor:destroy()
end
Zone.Destroy = Zone.destroy



return Zone]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000493</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="257">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Enum</string>
								<string name="ScriptGuid">{5F9FF80E-C6B4-41D8-A1AA-709D9FF4C8F1}</string>
								<ProtectedString name="Source"><![CDATA[-- Custom enum implementation that provides an effective way to compare, send
-- and store values. Instead of returning a userdata value, enum items return
-- their corresponding itemValue (an integer) when indexed. Enum items can
-- also associate a 'property', specified as the third element, which can be
-- retrieved by doing ``enum.getProperty(ITEM_NAME_OR_VALUE)``
-- This ultimately means groups of data can be easily categorised, efficiently
-- transmitted over networks and saved without throwing errors.
-- Ben Horton (ForeverHD)



-- LOCAL
local Enum = {}
local enums = {}
Enum.enums = enums



-- METHODS
function Enum.createEnum(enumName, details)
	assert(typeof(enumName) == "string", "bad argument #1 - enums must be created using a string name!")
	assert(typeof(details) == "table", "bad argument #2 - enums must be created using a table!")
	assert(not enums[enumName], ("enum '%s' already exists!"):format(enumName))
	
	local enum = {}
	local usedNames = {}
	local usedValues = {}
	local usedProperties = {}
	local enumMetaFunctions = {
		getName = function(valueOrProperty)
			valueOrProperty = tostring(valueOrProperty)
			local index = usedValues[valueOrProperty]
			if not index then
				index = usedProperties[valueOrProperty]
			end
			if index then
				return details[index][1]
			end
		end,
		getValue = function(nameOrProperty)
			nameOrProperty = tostring(nameOrProperty)
			local index = usedNames[nameOrProperty]
			if not index then
				index = usedProperties[nameOrProperty]
			end
			if index then
				return details[index][2]
			end
		end,
		getProperty = function(nameOrValue)
			nameOrValue = tostring(nameOrValue)
			local index = usedNames[nameOrValue]
			if not index then
				index = usedValues[nameOrValue]
			end
			if index then
				return details[index][3]
			end
		end
	}
	for i, detail in pairs(details) do
		assert(typeof(detail) == "table", ("bad argument #2.%s - details must only be comprised of tables!"):format(i))
		local name = detail[1]
		assert(typeof(name) == "string", ("bad argument #2.%s.1 - detail name must be a string!"):format(i))
		assert(typeof(not usedNames[name]), ("bad argument #2.%s.1 - the detail name '%s' already exists!"):format(i, name))
		assert(typeof(not enumMetaFunctions[name]), ("bad argument #2.%s.1 - that name is reserved."):format(i, name))
		usedNames[tostring(name)] = i
		local value = detail[2]
		local valueString = tostring(value)
		--assert(typeof(value) == "number" and math.ceil(value)/value == 1, ("bad argument #2.%s.2 - detail value must be an integer!"):format(i))
		assert(typeof(not usedValues[valueString]), ("bad argument #2.%s.2 - the detail value '%s' already exists!"):format(i, valueString))
		usedValues[valueString] = i
		local property = detail[3]
		if property then
			assert(typeof(not usedProperties[property]), ("bad argument #2.%s.3 - the detail property '%s' already exists!"):format(i, tostring(property)))
			usedProperties[tostring(property)] = i
		end
		enum[name] = value
		setmetatable(enum, {
			__index = function(_, index)
				return(enumMetaFunctions[index])
			end
		})
	end
	
	enums[enumName] = enum
	return enum
end

function Enum.getEnums()
	return enums
end



-- SETUP ENUMS
local createEnum = Enum.createEnum
for _, childModule in pairs(script:GetChildren()) do
	if childModule:IsA("ModuleScript") then
		local enumDetail = require(childModule)
		createEnum(childModule.Name, enumDetail)
	end
end

--[[
-- Example enum
createEnum("Color", {
	{"White", 1, Color3.fromRGB(255, 255, 255)},
	{"Black", 2, Color3.fromRGB(0, 0, 0)},
})
--]]



return Enum
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000494</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="258">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Accuracy</string>
									<string name="ScriptGuid">{B5E32518-272C-4EBC-8D56-0F222FE0E6CF}</string>
									<ProtectedString name="Source"><![CDATA[-- enumName, enumValue, additionalProperty
-- in this case, additionalProperty is the delay between each check
return {
	{"Low", 	1,	1.0},
	{"Medium",	2,	0.5},
	{"High",	3,	0.1},
	{"Precise",	4,	0.0},
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000495</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="259">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Detection</string>
									<string name="ScriptGuid">{9F685AB1-B4ED-426B-8EE0-87029179C06F}</string>
									<ProtectedString name="Source"><![CDATA[-- Important note: Precision checks currently only for 'players' and the 'localplayer', not 'parts'.

-- enumName, enumValue, additionalProperty
return {
	{"WholeBody", 1}, -- Multiple checks will be casted over an entire players character
	{"Centre", 2}, -- A singular check will be performed on the players HumanoidRootPart
	--{"Automatic", 3}, -- REMOVED DUE TO UNECESSARY COMPLEXITY. ZonePlus will dynamically switch between 'WholeBody' and 'Centre' depending upon the number of players in a server (this typically only occurs for servers with 100+ players when volume checks begin to exceed 0.5% in script performance).
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000496</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="260">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Janitor</string>
								<string name="ScriptGuid">{E439C479-B72B-4A99-8475-7FA012CEF911}</string>
								<ProtectedString name="Source"><![CDATA[-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
--local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index == nil then
		Index = newproxy(false)
	end

	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end
	--[[
	if Promise.is(Object) then
		local Id = newproxy(false)
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	end--]]

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName
	return Object, Index
end

Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
--[[
function Janitor.__index:AddPromise(PromiseObject)
	if not Promise.is(PromiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
	end

	if PromiseObject:getStatus() == Promise.Status.Started then
		local Id = newproxy(false)
		local NewPromise = self:Add(Promise.resolve(PromiseObject), "cancel", Id)
		NewPromise:finallyCall(self.Remove, self, Id)
		return NewPromise, Id
	else
		return PromiseObject
	end
end
--]]

--Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	--[[
	if Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end---]]
	return self:Add(Object, false, Id), Id
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, MethodName in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000497</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="261">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">OldSignal</string>
								<string name="ScriptGuid">{C0CC2A15-EDA6-4467-BB1A-C572179434C2}</string>
								<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local heartbeat = RunService.Heartbeat
local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"
Signal.totalConnections = 0



-- CONSTRUCTOR
function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({}, Signal)
	
	if createConnectionsChangedSignal then
		self.connectionsChanged = Signal.new()
	end

	self.connections = {}
	self.totalConnections = 0
	self.waiting = {}
	self.totalWaiting = 0

	return self
end



-- METHODS
function Signal:Fire(...)
	for _, connection in pairs(self.connections) do
		--connection.Handler(...)
		task.spawn(connection.Handler, ...)
	end
	if self.totalWaiting > 0 then
		local packedArgs = table.pack(...)
		for waitingId, _ in pairs(self.waiting) do
			self.waiting[waitingId] = packedArgs
		end
	end
end
Signal.fire = Signal.Fire

function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end
	
	local signal = self
	local connectionId = HttpService:GenerateGUID(false)
	local connection = {}
	connection.Connected = true
	connection.ConnectionId = connectionId
	connection.Handler = handler
	self.connections[connectionId] = connection

	function connection:Disconnect()
		signal.connections[connectionId] = nil
		connection.Connected = false
		signal.totalConnections -= 1
		if signal.connectionsChanged then
			signal.connectionsChanged:Fire(-1)
		end
	end
	connection.Destroy = connection.Disconnect
	connection.destroy = connection.Disconnect
	connection.disconnect = connection.Disconnect
	self.totalConnections += 1
	if self.connectionsChanged then
		self.connectionsChanged:Fire(1)
	end

	return connection
end
Signal.connect = Signal.Connect

function Signal:Wait()
	local waitingId = HttpService:GenerateGUID(false)
	self.waiting[waitingId] = true
	self.totalWaiting += 1
	repeat heartbeat:Wait() until self.waiting[waitingId] ~= true
	self.totalWaiting -= 1
	local args = self.waiting[waitingId]
	self.waiting[waitingId] = nil
	return unpack(args)
end
Signal.wait = Signal.Wait

function Signal:Destroy()
	if self.bindableEvent then
		self.bindableEvent:Destroy()
		self.bindableEvent = nil
	end
	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
	end
	self.totalConnections = 0
	for connectionId, connection in pairs(self.connections) do
		self.connections[connectionId] = nil
	end
end
Signal.destroy = Signal.Destroy
Signal.Disconnect = Signal.Destroy
Signal.disconnect = Signal.Destroy



return Signal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000498</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="262">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Signal</string>
								<string name="ScriptGuid">{514FE689-5FE8-4F64-84CB-4A9917A0BA49}</string>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	assert(self._connected, "Can't disconnect a connection twice.", 2)
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
    local signal = self._signal
	if signal._handlerListHead == self then
		signal._handlerListHead = self._next
	else
		local prev = signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end

    if signal.connectionsChanged then
		signal.totalConnections -= 1
        signal.connectionsChanged:Fire(-1)
    end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({
		_handlerListHead = false,	
	}, Signal)
    if createConnectionsChangedSignal then
        self.totalConnections = 0
		self.connectionsChanged = Signal.new()
	end
    return self
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	if self.connectionsChanged then
        self.totalConnections += 1
		self.connectionsChanged:Fire(1)
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false

    if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
		self.totalConnections = 0
	end
end
Signal.Destroy = Signal.DisconnectAll
Signal.destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end


return Signal]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000499</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="263">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VERSION</string>
								<string name="ScriptGuid">{7D6893D9-72E7-499B-A9F8-D5583599544A}</string>
								<ProtectedString name="Source">-- v3.2.0</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="264">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ZoneController</string>
								<string name="ScriptGuid">{C4D089B7-655F-4BFA-ABCB-8DCD9C16C13F}</string>
								<ProtectedString name="Source"><![CDATA[-- CONFIG
local WHOLE_BODY_DETECTION_LIMIT = 729000 -- This is roughly the volume where Region3 checks begin to exceed 0.5% in Script Performance



-- LOCAL
local Janitor = require(script.Parent.Janitor)
local Enum_ = require(script.Parent.Enum)
local Signal = require(script.Parent.Signal)
local Tracker = require(script.Tracker)
local CollectiveWorldModel = require(script.CollectiveWorldModel)
local enum = Enum_.enums
local players = game:GetService("Players")
local activeZones = {}
local activeZonesTotalVolume = 0
local activeTriggers = {}
local registeredZones = {}
local activeParts = {}
local activePartToZone = {}
local allParts = {}
local allPartToZone = {}
local activeConnections = 0
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local heartbeatConnections = {}
local localPlayer = runService:IsClient() and players.LocalPlayer



-- PUBLIC
local ZoneController = {}
local trackers = {}
trackers.player = Tracker.new("player")
trackers.item = Tracker.new("item")
ZoneController.trackers = trackers



-- LOCAL FUNCTIONS
local function dictLength(dictionary)
	local count = 0
	for _, _ in pairs(dictionary) do
		count += 1
	end
	return count
end

local function fillOccupants(zonesAndOccupantsTable, zone, occupant)
	local occupantsDict = zonesAndOccupantsTable[zone]
	if not occupantsDict then
		occupantsDict = {}
		zonesAndOccupantsTable[zone] = occupantsDict
	end
	local prevCharacter = occupant:IsA("Player") and occupant.Character
	occupantsDict[occupant] = (prevCharacter or true)
end

local heartbeatActions = {
	["player"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("player", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
	["localPlayer"] = function(recommendedDetection)
		local zonesAndOccupants = {}
		local character = localPlayer.Character
		if not character then
			return zonesAndOccupants
		end
		local touchingZones = ZoneController.getTouchingZones(character, true, recommendedDetection, trackers.player)
		for _, zone in pairs(touchingZones) do
			if zone.activeTriggers["localPlayer"] then
				fillOccupants(zonesAndOccupants, zone, localPlayer)
			end
		end
		return zonesAndOccupants
	end,
	["item"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("item", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
}



-- PRIVATE FUNCTIONS
function ZoneController._registerZone(zone)
   	registeredZones[zone] = true
	local registeredJanitor = zone.janitor:add(Janitor.new(), "destroy")
	zone._registeredJanitor = registeredJanitor
	registeredJanitor:add(zone.updated:Connect(function()
		ZoneController._updateZoneDetails()
	end), "Disconnect")
   ZoneController._updateZoneDetails()
end

function ZoneController._deregisterZone(zone)
	registeredZones[zone] = nil
	zone._registeredJanitor:destroy()
	zone._registeredJanitor = nil
	ZoneController._updateZoneDetails()
end

function ZoneController._registerConnection(registeredZone, registeredTriggerType)
	local originalItems = dictLength(registeredZone.activeTriggers)
	activeConnections += 1
	if originalItems == 0 then
		activeZones[registeredZone] = true
		ZoneController._updateZoneDetails()
	end
	local currentTriggerCount = activeTriggers[registeredTriggerType]
	activeTriggers[registeredTriggerType] = (currentTriggerCount and currentTriggerCount+1) or 1
	registeredZone.activeTriggers[registeredTriggerType] = true
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_formTouchedConnection(registeredTriggerType)
	end
	if heartbeatActions[registeredTriggerType] then
		ZoneController._formHeartbeat(registeredTriggerType)
	end
end

-- This decides what to do if detection is 'Automatic'
-- This is placed in ZoneController instead of the Zone object due to the ZoneControllers all-knowing group-minded logic
function ZoneController.updateDetection(zone)
	local detectionTypes = {
		["enterDetection"] = "_currentEnterDetection",
		["exitDetection"] = "_currentExitDetection",
	}
	for detectionType, currentDetectionName in pairs(detectionTypes) do
		local detection = zone[detectionType]
		local combinedTotalVolume = Tracker.getCombinedTotalVolumes()
		if detection == enum.Detection.Automatic then
			if combinedTotalVolume > WHOLE_BODY_DETECTION_LIMIT then
				detection = enum.Detection.Centre
			else
				detection = enum.Detection.WholeBody
			end
		end
		zone[currentDetectionName] = detection
	end
end

function ZoneController._formHeartbeat(registeredTriggerType)
	local heartbeatConnection = heartbeatConnections[registeredTriggerType]
	if heartbeatConnection then return end
	-- This will only ever connect once per triggerType per server
	-- This means instead of initiating a loop per-zone we can handle everything within
	-- a singular connection. This is particularly beneficial for player/item-orinetated
	-- checking, where a check only needs to be cast once per interval, as apposed
	-- to every zone per interval
	-- I utilise heartbeat with os.clock() to provide precision (where needed) and flexibility
	local nextCheck = 0
	heartbeatConnection = heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			local lowestAccuracy
			local lowestDetection
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					if lowestAccuracy == nil or zAccuracy < lowestAccuracy then
						lowestAccuracy = zAccuracy
					end
					ZoneController.updateDetection(zone)
					local zDetection = zone._currentEnterDetection
					if lowestDetection == nil or zDetection < lowestDetection then
						lowestDetection = zDetection
					end
				end
			end
			local highestAccuracy = lowestAccuracy
			local zonesAndOccupants = heartbeatActions[registeredTriggerType](lowestDetection)

			-- If a zone belongs to a settingsGroup with 'onlyEnterOnceExitedAll = true' , and the occupant already exists in a member group, then
			-- ignore all incoming occupants for the other zones (preventing the enteredSignal from being fired until the occupant has left
			-- all other zones within the same settingGroup)
			local occupantsToBlock = {}
			local zonesToPotentiallyIgnore = {}
			for zone, newOccupants in pairs(zonesAndOccupants) do
				local settingsGroup = (zone.settingsGroupName and ZoneController.getGroup(zone.settingsGroupName))
				if settingsGroup and settingsGroup.onlyEnterOnceExitedAll == true then
					--local currentOccupants = zone.occupants[registeredTriggerType]
					--if currentOccupants then
						for newOccupant, _ in pairs(newOccupants) do
							--if currentOccupants[newOccupant] then
								local groupDetail = occupantsToBlock[zone.settingsGroupName]
								if not groupDetail then
									groupDetail = {}
									occupantsToBlock[zone.settingsGroupName] = groupDetail
								end
								groupDetail[newOccupant] = zone
							--end
						end
						zonesToPotentiallyIgnore[zone] = newOccupants
					--end
				end
			end
			for zone, newOccupants in pairs(zonesToPotentiallyIgnore) do
				local groupDetail = occupantsToBlock[zone.settingsGroupName]
				if groupDetail then
					for newOccupant, _ in pairs(newOccupants) do
						local occupantToKeepZone = groupDetail[newOccupant]
						if occupantToKeepZone and occupantToKeepZone ~= zone then
							newOccupants[newOccupant] = nil
						end
					end
				end
			end

			-- This deduces what signals should be fired
			local collectiveSignalsToFire = {{}, {}}
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					local occupantsDict = zonesAndOccupants[zone] or {}
					local occupantsPresent = false
					for k,v in pairs(occupantsDict) do
						occupantsPresent = true
						break
					end
					if occupantsPresent and zAccuracy > highestAccuracy then
						highestAccuracy = zAccuracy
					end
					local signalsToFire = zone:_updateOccupants(registeredTriggerType, occupantsDict)
					collectiveSignalsToFire[1][zone] = signalsToFire.exited
					collectiveSignalsToFire[2][zone] = signalsToFire.entered
				end
			end

			-- This ensures all exited signals and called before entered signals
			local indexToSignalType = {"Exited", "Entered"}
			for index, zoneAndOccupants in pairs(collectiveSignalsToFire) do
				local signalType = indexToSignalType[index]
				local signalName = registeredTriggerType..signalType
				for zone, occupants in pairs(zoneAndOccupants) do
					local signal = zone[signalName]
					if signal then
						for _, occupant in pairs(occupants) do
							signal:Fire(occupant)
						end
					end
				end
			end

			local cooldown = enum.Accuracy.getProperty(highestAccuracy)
			nextCheck = clockTime + cooldown
		end
	end)
	heartbeatConnections[registeredTriggerType] = heartbeatConnection
end

function ZoneController._deregisterConnection(registeredZone, registeredTriggerType)
	activeConnections -= 1
	if activeTriggers[registeredTriggerType] == 1 then
		activeTriggers[registeredTriggerType] = nil
		local heartbeatConnection = heartbeatConnections[registeredTriggerType]
		if heartbeatConnection then
			heartbeatConnections[registeredTriggerType] = nil
			heartbeatConnection:Disconnect()
		end
	else
		activeTriggers[registeredTriggerType] -= 1
	end
	registeredZone.activeTriggers[registeredTriggerType] = nil
	if dictLength(registeredZone.activeTriggers) == 0 then
		activeZones[registeredZone] = nil
		ZoneController._updateZoneDetails()
	end
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_disconnectTouchedConnection(registeredTriggerType)
	end
end

function ZoneController._updateZoneDetails()
	activeParts = {}
	activePartToZone = {}
	allParts = {}
	allPartToZone = {}
	activeZonesTotalVolume = 0
	for zone, _ in pairs(registeredZones) do
		local isActive = activeZones[zone]
		if isActive then
			activeZonesTotalVolume += zone.volume
		end
		for _, zonePart in pairs(zone.zoneParts) do
			if isActive then
				table.insert(activeParts, zonePart)
				activePartToZone[zonePart] = zone
			end
			table.insert(allParts, zonePart)
			allPartToZone[zonePart] = zone
		end
	end
end

function ZoneController._getZonesAndItems(trackerName, zonesDictToCheck, zoneCustomVolume, onlyActiveZones, recommendedDetection)
	local totalZoneVolume = zoneCustomVolume
	if not totalZoneVolume then
		for zone, _ in pairs(zonesDictToCheck) do
			totalZoneVolume += zone.volume
		end
	end
	local zonesAndOccupants = {}
	local tracker = trackers[trackerName]
	if tracker.totalVolume < totalZoneVolume then
		-- If the volume of all *characters/items* within the server is *less than* the total
		-- volume of all active zones (i.e. zones which listen for .playerEntered)
		-- then it's more efficient cast checks within each character and
		-- then determine the zones they belong to
		for _, item in pairs(tracker.items) do
			local touchingZones = ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
			for _, zone in pairs(touchingZones) do
				if not onlyActiveZones or zone.activeTriggers[trackerName] then
					local finalItem = item
					if trackerName == "player" then
						finalItem = players:GetPlayerFromCharacter(item)
					end
					if finalItem then
						fillOccupants(zonesAndOccupants, zone, finalItem)
					end
				end
			end
		end
	else
		-- If the volume of all *active zones* within the server is *less than* the total
		-- volume of all characters/items, then it's more efficient to perform the
		-- checks directly within each zone to determine players inside
		for zone, _ in pairs(zonesDictToCheck) do
			if not onlyActiveZones or zone.activeTriggers[trackerName] then
				local result = CollectiveWorldModel:GetPartBoundsInBox(zone.region.CFrame, zone.region.Size, tracker.whitelistParams)
				local finalItemsDict = {}
				for _, itemOrChild in pairs(result) do
					local correspondingItem = tracker.partToItem[itemOrChild]
					if not finalItemsDict[correspondingItem] then
						finalItemsDict[correspondingItem] = true
					end
				end
				for item, _ in pairs(finalItemsDict) do
					if trackerName == "player" then
						local player = players:GetPlayerFromCharacter(item)
						if zone:findPlayer(player) then
							fillOccupants(zonesAndOccupants, zone, player)
						end
					elseif zone:findItem(item) then
						fillOccupants(zonesAndOccupants, zone, item)
					end
				end
			end
		end
	end
	return zonesAndOccupants
end



-- PUBLIC FUNCTIONS
function ZoneController.getZones()
	local registeredZonesArray = {}
	for zone, _ in pairs(registeredZones) do
		table.insert(registeredZonesArray, zone)
	end
	return registeredZonesArray
end

--[[
-- the player touched events which utilise active zones at the moment may change to the new CanTouch method for parts in the future
-- hence im disabling this as it may be depreciated quite soon
function ZoneController.getActiveZones()
	local zonesArray = {}
	for zone, _ in pairs(activeZones) do
		table.insert(zonesArray, zone)
	end
	return zonesArray
end
--]]

function ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
	local exitDetection, finalDetection
	if tracker then
		exitDetection = tracker.exitDetections[item]
		tracker.exitDetections[item] = nil
	end
	finalDetection = exitDetection or recommendedDetection

	local itemSize, itemCFrame
	local itemIsBasePart = item:IsA("BasePart")
	local itemIsCharacter = not itemIsBasePart
	local bodyPartsToCheck = {}
	if itemIsBasePart then
		itemSize, itemCFrame = item.Size, item.CFrame
		table.insert(bodyPartsToCheck, item)
	elseif finalDetection == enum.Detection.WholeBody then
		itemSize, itemCFrame = Tracker.getCharacterSize(item)
		bodyPartsToCheck = item:GetChildren()
	else
		local hrp = item:FindFirstChild("HumanoidRootPart")
		if hrp then
			itemSize, itemCFrame = hrp.Size, hrp.CFrame
			table.insert(bodyPartsToCheck, hrp)
		end
	end
	if not itemSize or not itemCFrame then return {} end

	--[[
	local part = Instance.new("Part")
	part.Size = itemSize
	part.CFrame = itemCFrame
	part.Anchored = true
	part.CanCollide = false
	part.Color = Color3.fromRGB(255, 0, 0)
	part.Transparency = 0.4
	part.Parent = workspace
	game:GetService("Debris"):AddItem(part, 2)
	--]]
	local partsTable = (onlyActiveZones and activeParts) or allParts
	local partToZoneDict = (onlyActiveZones and activePartToZone) or allPartToZone

	local boundParams = OverlapParams.new()
	boundParams.FilterType = Enum.RaycastFilterType.Whitelist
	boundParams.MaxParts = #partsTable
	boundParams.FilterDescendantsInstances = partsTable

	-- This retrieves the bounds (the rough shape) of all parts touching the item/character
	-- If the corresponding zone is made up of *entirely* blocks then the bound will
	-- be the actual shape of the part.
	local touchingPartsDictionary = {}
	local zonesDict = {}
	local boundParts = CollectiveWorldModel:GetPartBoundsInBox(itemCFrame, itemSize, boundParams)
	local boundPartsThatRequirePreciseChecks = {}
	for _, boundPart in pairs(boundParts) do
		local correspondingZone = partToZoneDict[boundPart]
		if correspondingZone and correspondingZone.allZonePartsAreBlocks then
			zonesDict[correspondingZone] = true
			touchingPartsDictionary[boundPart] = correspondingZone
		else
			table.insert(boundPartsThatRequirePreciseChecks, boundPart)
		end
	end

	-- If the bound parts belong to a zone that isn't entirely made up of blocks, then
	-- we peform additional checks using GetPartsInPart which enables shape
	-- geometries to be precisely determined for non-block baseparts.
	local totalRemainingBoundParts = #boundPartsThatRequirePreciseChecks
	local precisePartsCount = 0
	if totalRemainingBoundParts > 0 then
		
		local preciseParams = OverlapParams.new()
		preciseParams.FilterType = Enum.RaycastFilterType.Whitelist
		preciseParams.MaxParts = totalRemainingBoundParts
		preciseParams.FilterDescendantsInstances = boundPartsThatRequirePreciseChecks

		local character = item
		for _, bodyPart in pairs(bodyPartsToCheck) do
			local endCheck = false
			if not bodyPart:IsA("BasePart") or (itemIsCharacter and Tracker.bodyPartsToIgnore[bodyPart.Name]) then
				continue
			end
			local preciseParts = CollectiveWorldModel:GetPartsInPart(bodyPart, preciseParams)
			for _, precisePart in pairs(preciseParts) do
				if not touchingPartsDictionary[precisePart] then
					local correspondingZone = partToZoneDict[precisePart]
					if correspondingZone then
						zonesDict[correspondingZone] = true
						touchingPartsDictionary[precisePart] = correspondingZone
						precisePartsCount += 1
					end
					if precisePartsCount == totalRemainingBoundParts then
						endCheck = true
						break
					end
				end
			end
			if endCheck then
				break
			end
		end
	end
	
	local touchingZonesArray = {}
	local newExitDetection
	for zone, _ in pairs(zonesDict) do
		if newExitDetection == nil or zone._currentExitDetection < newExitDetection then
			newExitDetection = zone._currentExitDetection
		end
		table.insert(touchingZonesArray, zone)
	end
	if newExitDetection and tracker then
		tracker.exitDetections[item] = newExitDetection
	end
	return touchingZonesArray, touchingPartsDictionary
end

local settingsGroups = {}
function ZoneController.setGroup(settingsGroupName, properties)
	local group = settingsGroups[settingsGroupName]
	if not group then
		group = {}
		settingsGroups[settingsGroupName] = group
	end
	

	-- PUBLIC PROPERTIES --
	group.onlyEnterOnceExitedAll = true
	
	-- PRIVATE PROPERTIES --
	group._name = settingsGroupName
	group._memberZones = {}


	if typeof(properties) == "table" then
		for k, v in pairs(properties) do
			group[k] = v
		end
	end
	return group
end

function ZoneController.getGroup(settingsGroupName)
	return settingsGroups[settingsGroupName]
end

local workspaceContainer
local workspaceContainerName = string.format("ZonePlus%sContainer", (runService:IsClient() and "Client") or "Server")
function ZoneController.getWorkspaceContainer()
	local container = workspaceContainer or workspace:FindFirstChild(workspaceContainerName)
	if not container then
		container = Instance.new("Folder")
		container.Name = workspaceContainerName
		container.Parent = workspace
		workspaceContainer = container
	end
	return container
end



return ZoneController]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="265">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CollectiveWorldModel</string>
									<string name="ScriptGuid">{D1756769-5DE7-4D04-BB5E-861DCFAEEF23}</string>
									<ProtectedString name="Source"><![CDATA[local CollectiveWorldModel = {}
local worldModel
local runService = game:GetService("RunService")



-- FUNCTIONS
function CollectiveWorldModel.setupWorldModel(zone)
	if worldModel then
		return worldModel
	end
	local location = (runService:IsClient() and "ReplicatedStorage") or "ServerStorage"
	worldModel = Instance.new("WorldModel")
	worldModel.Name = "ZonePlusWorldModel"
	worldModel.Parent = game:GetService(location)
	return worldModel
end



-- METHODS
function CollectiveWorldModel:_getCombinedResults(methodName, ...)
	local results = workspace[methodName](workspace, ...)
	if worldModel then
		local additionalResults = worldModel[methodName](worldModel, ...)
		for _, result in pairs(additionalResults) do
			table.insert(results, result)
		end
	end
	return results
end

function CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInBox", cframe, size, overlapParams)
end

function CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInRadius", position, radius, overlapParams)
end

function CollectiveWorldModel:GetPartsInPart(part, overlapParams)
	return self:_getCombinedResults("GetPartsInPart", part, overlapParams)
end



return CollectiveWorldModel]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="266">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tracker</string>
									<string name="ScriptGuid">{84B1497E-1337-434A-BB92-FBEEF3543735}</string>
									<ProtectedString name="Source"><![CDATA[-- This enables data on volumes, HumanoidRootParts, etc to be handled on an event-basis, instead of being retrieved every interval

-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local Signal = require(script.Parent.Parent.Signal)
local Janitor = require(script.Parent.Parent.Janitor)



-- PUBLIC
local Tracker = {}
Tracker.__index = Tracker
local trackers = {}
Tracker.trackers = trackers
Tracker.itemAdded = Signal.new()
Tracker.itemRemoved = Signal.new()
Tracker.bodyPartsToIgnore = {
	-- We ignore these due to their insignificance (e.g. we ignore the lower and
	-- upper torso because the HumanoidRootPart also covers these areas)
	-- This ultimately reduces the burden on the player region checks
	UpperTorso = true,
	LowerTorso = true,
	Torso = true,
	LeftHand = true,
	RightHand = true,
	LeftFoot = true,
	RightFoot = true,
}



-- FUNCTIONS
function Tracker.getCombinedTotalVolumes()
	local combinedVolume = 0
	for tracker, _ in pairs(trackers) do
		combinedVolume += tracker.totalVolume
	end
	return combinedVolume
end

function Tracker.getCharacterSize(character)
	local head = character and character:FindFirstChild("Head")
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not(hrp and head) then return nil end
	if not head:IsA("BasePart") then
		head = hrp
	end
	local headY = head.Size.Y
	local hrpSize = hrp.Size
	local charSize = (hrpSize * Vector3.new(2, 2, 1)) + Vector3.new(0, headY, 0)
	local charCFrame = hrp.CFrame * CFrame.new(0, headY/2 - hrpSize.Y/2, 0)
	return charSize, charCFrame
end



-- CONSTRUCTOR
function Tracker.new(name)
	local self = {}
	setmetatable(self, Tracker)
	
	self.name = name
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	self.whitelistParams = nil
	self.characters = {}
	self.baseParts = {}
	self.exitDetections = {}
	self.janitor = Janitor.new()

	if name == "player" then
		local function updatePlayerCharacters()
			local characters = {}
			for _, player in pairs(players:GetPlayers()) do
				local character = player.Character
				if character then
					characters[character] = true
				end
			end
			self.characters = characters
		end
		
		local function playerAdded(player)
			local function charAdded(character)
				local humanoid = character:WaitForChild("Humanoid", 3)
				if humanoid then
					updatePlayerCharacters()
					self:update()
					for _, valueInstance in pairs(humanoid:GetChildren()) do
						if valueInstance:IsA("NumberValue") then
							valueInstance.Changed:Connect(function()
								self:update()
							end)
						end
					end
				end
			end
			if player.Character then
				charAdded(player.Character)
			end
			player.CharacterAdded:Connect(charAdded)
			player.CharacterRemoving:Connect(function(removingCharacter)
				self.exitDetections[removingCharacter] = nil
			end)
		end
		
		players.PlayerAdded:Connect(playerAdded)
		for _, player in pairs(players:GetPlayers()) do
			playerAdded(player)
		end
		
		players.PlayerRemoving:Connect(function(player)
			updatePlayerCharacters()
			self:update()
		end)


	elseif name == "item" then
		local function updateItem(itemDetail, newValue)
			if itemDetail.isCharacter then
				self.characters[itemDetail.item] = newValue
			elseif itemDetail.isBasePart then
				self.baseParts[itemDetail.item] = newValue
			end
			self:update()
		end
		Tracker.itemAdded:Connect(function(itemDetail)
			updateItem(itemDetail, true)
		end)
		Tracker.itemRemoved:Connect(function(itemDetail)
			self.exitDetections[itemDetail.item] = nil
			updateItem(itemDetail, nil)
		end)
	end

	trackers[self] = true
	task.defer(self.update, self)
	return self
end



-- METHODS
function Tracker:_preventMultiFrameUpdates(methodName, ...)
	-- This prevents the funtion being called twice within a single frame
	-- If called more than once, the function will initally be delayed again until the next frame, then all others cancelled
	self._preventMultiDetails = self._preventMultiDetails or {}
	local detail = self._preventMultiDetails[methodName]
	if not detail then
		detail = {
			calling = false,
			callsThisFrame = 0,
			updatedThisFrame = false,
		}
		self._preventMultiDetails[methodName] = detail
	end

	detail.callsThisFrame += 1
	if detail.callsThisFrame == 1 then
		local args = table.pack(...)
		task.defer(function()
			local newCallsThisFrame = detail.callsThisFrame
			detail.callsThisFrame = 0
			if newCallsThisFrame > 1 then
				self[methodName](self, unpack(args))
			end
		end)
		return false
	end
	return true
end

function Tracker:update()
	if self:_preventMultiFrameUpdates("update") then
		return
	end
	
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	
	-- This tracks the bodyparts of a character
	for character, _ in pairs(self.characters) do
		local charSize = Tracker.getCharacterSize(character)
		if not charSize then
			continue
		end
		local rSize = charSize
		local charVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += charVolume
		
		local characterJanitor = self.janitor:add(Janitor.new(), "destroy", "trackCharacterParts-"..self.name)
		local function updateTrackerOnParentChanged(instance)
			characterJanitor:add(instance.AncestryChanged:Connect(function()
				if not instance:IsDescendantOf(game) then
					if instance.Parent == nil and characterJanitor ~= nil then
						characterJanitor:destroy()
						characterJanitor = nil
						self:update()
					end
				end
			end), "Disconnect")
		end

		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and not Tracker.bodyPartsToIgnore[part.Name] then
				self.partToItem[part] = character
				table.insert(self.parts, part)
				updateTrackerOnParentChanged(part)
			end
		end
		updateTrackerOnParentChanged(character)
		table.insert(self.items, character)
	end

	-- This tracks any additional baseParts
	for additionalPart, _ in pairs(self.baseParts) do
		local rSize = additionalPart.Size
		local partVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += partVolume
		self.partToItem[additionalPart] = additionalPart
		table.insert(self.parts, additionalPart)
		table.insert(self.items, additionalPart)
	end
	
	-- This creates the whitelist so that
	self.whitelistParams = OverlapParams.new()
	self.whitelistParams.FilterType = Enum.RaycastFilterType.Whitelist
	self.whitelistParams.MaxParts = #self.parts
	self.whitelistParams.FilterDescendantsInstances = self.parts
end



return Tracker]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="267">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ZonePlusReference</string>
								<string name="ScriptGuid">{166222A1-4B01-4930-B3A6-E309C009B763}</string>
								<ProtectedString name="Source"><![CDATA[-- This module enables you to place Zone wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two ZonePlus applications initiating at runtime which would
-- diminish it's overall efficiency

local replicatedStorage = game:GetService("ReplicatedStorage")
local ZonePlusReference = {}

function ZonePlusReference.addToReplicatedStorage()
    local existingItem = replicatedStorage:FindFirstChild(script.Name)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
    objectValue.Name = script.Name
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    local locationValue = Instance.new("BoolValue")
    locationValue.Name = (game:GetService("RunService"):IsClient() and "Client") or "Server"
    locationValue.Value = true
    locationValue.Parent = objectValue
    return objectValue
end

function ZonePlusReference.getObject()
    local objectValue = replicatedStorage:FindFirstChild(script.Name)
    if objectValue then
        return objectValue
    end
    return false
end

return ZonePlusReference]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="268">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{3B12462C-0B81-4F2C-A913-D0EADAB178BB}</string>
								<ProtectedString name="Source"><![CDATA[return {
	dependencies = {
	},
	package = {
		description = "ZonePlus by 1ForeverHD",
		name = "mattschrubb/zoneplus",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "3.2.0",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000049f</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="269">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">osyrisrblx_t@3.1.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a0</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="270">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">t</string>
							<string name="ScriptGuid">{F9D13348-CAD3-40A4-AD84-0A6609EFB002}</string>
							<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false, string.format("%s expected, got %s", typeName, valueType)
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false, "any expected, got nil"
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false, "unexpected NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false, "unexpected non-NaN value"
		end
	else
		return false, string.format("number expected, got %s", valueType)
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false, string.format("expected %s, got %s", tostring(literal), tostring(value))
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success, errMsg = t.number(value)
	if not success then
		return false, errMsg or ""
	end

	if value % 1 == 0 then
		return true
	else
		return false, string.format("integer expected, got %s", value)
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value >= min then
			return true
		else
			return false, string.format("number >= %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg
		end

		if value <= max then
			return true
		else
			return false, string.format("number <= %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if min < value then
			return true
		else
			return false, string.format("number > %s expected, got %s", min, value)
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success, errMsg = t.number(value)
		if not success then
			return false, errMsg or ""
		end

		if value < max then
			return true
		else
			return false, string.format("number < %s expected, got %s", max, value)
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess, minErrMsg = minCheck(value)
		if not minSuccess then
			return false, minErrMsg or ""
		end

		local maxSuccess, maxErrMsg = maxCheck(value)
		if not maxSuccess then
			return false, maxErrMsg or ""
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess, stringErrMsg = t.string(value)
		if not stringSuccess then
			return false, stringErrMsg
		end

		if string.match(value, pattern) == nil then
			return false, string.format("%q failed to match pattern %q", value, pattern)
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success, errMsg = check(value)
		if success then
			return true
		else
			return false, string.format("(optional) %s", errMsg or "")
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success, errMsg = check(args[i])
			if success == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", i, errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key in pairs(value) do
			local success, errMsg = check(key)
			if success == false then
				return false, string.format("bad key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess, tableErrMsg = t.table(value)
		if tableSuccess == false then
			return false, tableErrMsg or ""
		end

		for key, val in pairs(value) do
			local success, errMsg = check(val)
			if success == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(key), errMsg or "")
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess, keyErr = keyChecker(value)
		if not keySuccess then
			return false, keyErr or ""
		end

		local valueSuccess, valueErr = valueChecker(value)
		if not valueSuccess then
			return false, valueErr or ""
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[array] %s", keyErrMsg or "")
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false, string.format("[array] key %s must be sequential", tostring(key))
				end
			end

			local valueSuccess, valueErrMsg = valuesCheck(value)
			if not valueSuccess then
				return false, string.format("[array] %s", valueErrMsg or "")
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess, keyErrMsg = arrayKeysCheck(value)
			if keySuccess == false then
				return false, string.format("[strictArray] %s", keyErrMsg or "")
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false, string.format("[strictArray] Array size exceeds limit of %d", #valueTypes)
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess, typeErrMsg = typeFn(value[idx])
				if not typeSuccess then
					return false, string.format("[strictArray] Array index #%d - %s", idx, typeErrMsg)
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false, "bad type for union"
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success, errMsg = check(value)
				if not success then
					return false, errMsg or ""
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess, tableErrMsg = t.table(value)
			if tableSuccess == false then
				return false, tableErrMsg or ""
			end

			for key, check in pairs(checkTable) do
				local success, errMsg = check(value[key])
				if success == false then
					return false, string.format("[interface] bad value for %s:\n\t%s", tostring(key), errMsg or "")
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false, string.format("[interface] unexpected field %q", tostring(key))
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if value.ClassName ~= className then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess, instanceErrMsg = t.Instance(value)
		if not instanceSuccess then
			return false, instanceErrMsg or ""
		end

		if not value:IsA(className) then
			return false, string.format("%s expected, got %s", className, value.ClassName)
		end

		if childrenCheck then
			local childrenSuccess, childrenErrMsg = childrenCheck(value)
			if not childrenSuccess then
				return false, childrenErrMsg
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess, enumItemErrMsg = t.EnumItem(value)
		if not enumItemSuccess then
			return false, enumItemErrMsg
		end

		if value.EnumType == enum then
			return true
		else
			return false, string.format("enum of %s expected, got enum of %s", tostring(enum), tostring(value.EnumType))
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess, instanceErrMsg = t.Instance(value)
			if not instanceSuccess then
				return false, instanceErrMsg or ""
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false, string.format("Cannot process multiple children with the same name %q", name)
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success, errMsg = check(childrenByName[name])
				if not success then
					return false, string.format("[%s.%s] %s", value:GetFullName(), name, errMsg or "")
				end
			end

			return true
		end
	end
end

return t
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a1</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="271">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">paradoxum-games_lyra@0.6.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a2</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="272">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Promise</string>
							<string name="ScriptGuid">{E523D5C3-CB2A-4726-9383-CF103B2F36A5}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["evaera_promise@4.0.0"]["promise"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a3</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="273">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">lyra</string>
							<string name="ScriptGuid">{C796ECA3-6835-4174-8F0A-AAF43372E9A2}</string>
							<ProtectedString name="Source"><![CDATA[--[=[
	@class Lyra

	The main entry point and public facade for the Lyra library.

	This module re-exports the primary functions and constructors needed to interact
	with Lyra, simplifying the public API and hiding internal module structure.
	Users of the library should typically only need to require this top-level module.
]=]

local Log = require(script.Log)
local Migrations = require(script.Migrations)
local PlayerStore = require(script.PlayerStore)

--[=[
	Provides helper functions for creating common migration steps.
	
	@interface MigrationStep
	.field addFields (name: string, fields: { [string]: any }) -> MigrationStep -- Creates a step to add new fields with default values.
	.field transform (name: string, transformFunc: (currentValue: { [string]: any }) -> { [string]: any }) -> MigrationStep -- Creates a step with a custom data transformation function.

	@within Lyra
]=]
local MigrationStep = {
	addFields = Migrations.makeAddFieldsStep,
	transform = Migrations.makeTransformStep,
}

--[=[
	Factory function to create a new PlayerStore instance.
	
	@function createPlayerStore<T>
	@param context PlayerStoreConfig<T> -- The configuration for the PlayerStore.
	@return PlayerStore<T> -- A new PlayerStore instance.
	@within Lyra
]=]
local createPlayerStore = PlayerStore.createPlayerStore

--[=[
	Sets the global minimum log level for all Lyra loggers.

	@function setLogLevel
	@param level LogLevel -- The minimum log level ("fatal", "error", "warn", "info", "debug", "trace").
	@within Lyra
]=]
local setLogLevel = Log.setLevel

-- The public interface of the Lyra library.
return {
	MigrationStep = MigrationStep,
	createPlayerStore = createPlayerStore,
	setLogLevel = setLogLevel,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a4</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="274">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Constants</string>
								<string name="ScriptGuid">{1E5C2127-3747-4DF6-AFC8-E92EDEF06C08}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Constants
	@private

	Module containing constant values used throughout the Lyra library.
]=]

-- Estimated bytes reserved within the DataStore value for Lyra's internal metadata
-- (like appliedMigrations, orphanedFiles list, and File object overhead when sharded).
-- This ensures that the actual user data shards stay safely within the DataStore limits.
local INTERNAL_SPACE_RESERVE_BYTES = 10_000

--[=[
	@interface Constants
	@within Constants

	.RECORD_SCOPE "lyra/records" -- Scope prefix used for keys storing the main DataStoreRecord objects.

	.TX_SCOPE "lyra/tx" -- Scope prefix used for keys storing transaction status markers in a DataStore.

	.SHARD_SCOPE "lyra/shards" -- Scope prefix used for keys storing data shards in a DataStore.

	.LOCK_SCOPE "lyra/locks" -- Scope prefix used for keys storing lock information in a MemoryStore HashMap.

	.MAX_CHUNK_SIZE number -- Maximum size (in bytes) for a single data shard stored in DataStore. Derived from the Roblox DataStore value limit (4MB) minus a reserved amount (INTERNAL_SPACE_RESERVE_BYTES) for Lyra's internal metadata within the main record.

	.LOCK_REFRESH_INTERVAL_SECONDS number -- How often (in seconds) a held lock should be refreshed in MemoryStore to prevent it from expiring while still actively being used. Should be significantly shorter than LOCK_DURATION_SECONDS.

	.LOCK_DURATION_SECONDS number -- The initial time-to-live (TTL) duration (in seconds) for a lock acquired in MemoryStore. If the lock isn't refreshed within this time, it will automatically expire. Must be longer than LOCK_REFRESH_INTERVAL_SECONDS to allow time for refreshes.

	.AUTOSAVE_INTERVAL_SECONDS number -- How often (in seconds) the automatic saving mechanism should attempt to save dirty session data.
]=]
local Constants = {
	RECORD_SCOPE = "lyra/records",
	TX_SCOPE = "lyra/tx",
	SHARD_SCOPE = "lyra/shards",
	LOCK_SCOPE = "lyra/locks",

	MAX_CHUNK_SIZE = 4_000_000 - INTERNAL_SPACE_RESERVE_BYTES,

	LOCK_REFRESH_INTERVAL_SECONDS = 60,

	LOCK_DURATION_SECONDS = 90,

	AUTOSAVE_INTERVAL_SECONDS = 5 * 60, -- 5 minutes
}

return Constants
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a5</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="275">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Files</string>
								<string name="ScriptGuid">{66B402C6-9ECD-47AD-B4A2-D7FF461A55AC}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Files
	@private

	Handles the storage and retrieval of potentially large data blobs within Roblox DataStores,
	working around the size limitations imposed by DataStore `SetAsync`/`GetAsync` calls.

	**Core Problem:** Roblox DataStores have a maximum size limit per key (currently 4MB).
	Data that exceeds this limit cannot be stored directly.

	**Solution: Sharding & Compression**
	1.  **Sharding:** If the JSON-encoded data exceeds the configured `maxShardSize`, it is
	    split into multiple smaller chunks (shards). Metadata about these shards (a unique
	    shard ID and the total shard count) is stored in the primary DataStore entry for the
	    original key, while the actual shard data is stored under separate keys derived from
	    the shard ID.
	2.  **Compression:** Before sharding, the JSON-encoded data is converted to binary using
	    `buffer.fromstring`. This binary representation is then JSON-encoded *again* before
	    being split into shards. Roblox automatically compresses buffers when encoding them
		using `JSONEncode`. This helps reduce the number of shards required, minimizing
		DataStore requests.

	**Shard Key Naming:** Shard data is stored using keys formatted as `{shardId}-{shardIndex}`,
	where `shardId` is a unique GUID generated for the file and `shardIndex` is the 1-based
	index of the shard.
]=]

local HttpService = game:GetService("HttpService")

local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local dataStoreRetry = require(script.Parent.dataStoreRetry)

--[=[
	Splits a string into chunks of a specified size.
	Used for sharding large data blobs into smaller pieces.

	@within Files
	@param str string -- The string to be split.
	@param chunkSize number -- The size of each chunk.
	@return { string } -- A table containing the split chunks.
]=]
local function splitString(str: string, chunkSize: number): { string }
	local numChunks = math.ceil(#str / chunkSize)
	local chunks = {}
	for i = 1, numChunks do
		local start = (i - 1) * chunkSize + 1
		local chunk = string.sub(str, start, start + chunkSize - 1)
		table.insert(chunks, chunk)
	end
	return chunks
end

--[=[
	Checks if a file object represents a sharded file (i.e., data stored across multiple keys).

	@within Files
	@param file File -- The file object to check.
	@return boolean -- True if the file is sharded, false otherwise.
]=]
local function isLargeFile(file: Types.File): boolean
	return file.shard ~= nil
end

--[=[
	@within Files
	Parameters required for the `write` function.

	@interface WriteParams
	.store DataStore -- The DataStore instance to write to.
	.data any -- The Luau data to be stored. Must be JSON-encodable.
	.maxShardSize number -- The maximum size (in bytes) allowed for a single shard. Data exceeding this size after initial JSON encoding will trigger the sharding process.
	.key string -- The primary key under which the file metadata (or the full data if not sharded) will be conceptually associated. This key is *not* directly used for storing shards.
	.userIds { number }? -- An optional array of UserIDs for DataStore tagging.
]=]
export type WriteParams = {
	store: DataStore,
	data: any,
	maxShardSize: number,
	key: string, -- Primarily for context/logging, not direct shard storage key
	userIds: { number }?,
}

--[=[
	@interface WriteError
	@within Files
	Structure representing an error encountered during the `write` operation.

	.error string -- A string describing the error.
	.file File -- The file metadata that was being processed when the error occurred. This is used for cleanup operations if shards were partially written.
]=]
export type WriteError = {
	error: string,
	file: Types.File,
}

--[=[
	Writes data to the DataStore, automatically handling sharding and compression if necessary.

	If the JSON-encoded data is smaller than `maxShardSize`, it's stored directly within the
	returned [File] object (in the `data` field).

	If the data is larger, it's compressed, sharded, and stored across multiple DataStore keys.
	The returned [File] object will contain `shard` (the unique ID for the shards) and
	`count` (the number of shards) instead of the `data` field.

	@within Files
	@param params WriteParams -- The parameters for the write operation.
	@return Promise<File> -- A Promise that resolves with a [File] object representing the stored data (either directly containing the data or shard metadata).
	@error WriteError -- Rejects with a `WriteError` if any shard fails to write.
	@error string -- Propagates errors from `DataStore:SetAsync` via `dataStoreRetry`.
]=]
local function write(params: WriteParams): Promise.TPromise<Types.File>
	-- Step 1: Initial JSON encode to check size against the limit.
	local dataEncoded = HttpService:JSONEncode(params.data)
	if #dataEncoded <= params.maxShardSize then
		-- Data fits within a single shard, no sharding needed. Return directly.
		return Promise.resolve({ data = params.data } :: Types.File)
	end

	-- Step 2: Convert the JSON-encoded data to a binary buffer.
	-- This binary buffer is then JSON encoded *again*, which Roblox automatically compresses.
	-- This helps reduce the size of the data before sharding.
	local dataCompressed = HttpService:JSONEncode(buffer.fromstring(dataEncoded))

	-- Step 3: Split the compressed, double-encoded string into shards.
	local shards = splitString(dataCompressed, params.maxShardSize)

	-- Step 4: Generate metadata for the sharded file.
	local shardId = HttpService:GenerateGUID(false) -- Unique ID for this set of shards.
	local file = { shard = shardId, count = #shards } -- File object containing shard info.

	-- Step 5: Write each shard to the DataStore using derived keys.
	local shardPromises = Tables.map(shards, function(shard, index)
		-- Key format: {shardId}-{shardIndex} (1-based index)
		local shardKey = `{shardId}-{index}`
		return dataStoreRetry(function()
			-- Attempt to write the individual shard with retry logic.
			return params.store:SetAsync(shardKey, shard, params.userIds)
		end)
	end)

	-- Step 6: Wait for all shard writes to complete.
	return Promise
		.all(shardPromises)
		:andThenReturn(file) -- If all succeed, return the file metadata.
		:catch(function(err)
			-- If any shard write fails, reject the promise with detailed error info.
			return Promise.reject({
				error = `Failed to write file: {err}`,
				file = file, -- Include file metadata for cleanup.
			} :: WriteError)
		end)
end

--[=[
	@interface ReadParams
	@within Files
	Parameters required for the `read` function.

	.store DataStore -- The DataStore instance to read from.
	.file File -- The [File] object obtained from a previous `write` operation or retrieved from the primary DataStore key. This object determines whether to read directly or reconstruct from shards.
]=]
export type ReadParams = {
	store: DataStore,
	file: Types.File,
}

--[=[
	Reads data from the DataStore, automatically handling reconstruction from shards if necessary.

	If the provided `file` object contains the `data` field directly, it returns that data.
	If the `file` object contains `shard` and `count` fields, it reads all corresponding shards
	from the DataStore, concatenates them, decompresses the result, and returns the original data.

	@within Files
	@param params ReadParams -- The parameters for the read operation.
	@return Promise<any> -- A Promise that resolves with the original data.
	@error string -- Rejects with an error message string if any shard is missing or if decoding/decompression fails. Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`.
]=]
local function read(params: ReadParams): Promise.TPromise<any>
	-- Step 1: Check if the file is sharded.
	if not isLargeFile(params.file) then
		-- Not sharded, data is stored directly in the file object.
		return Promise.resolve(params.file.data)
	end

	-- Step 2: Prepare to read shards.
	local shardId = params.file.shard
	assert(shardId, "Shard ID missing from large file object") -- Should be guaranteed by isLargeFile
	local shardCount = params.file.count
	assert(shardCount, "Shard count missing from large file object")

	local promises = {}

	-- Step 3: Create promises to fetch each shard.
	for i = 1, shardCount do
		local shardKey = `{shardId}-{i}`
		table.insert(
			promises,
			dataStoreRetry(function()
				-- Attempt to read the individual shard with retry logic.
				return params.store:GetAsync(shardKey)
			end)
		)
	end

	-- Step 4: Wait for all shard reads to complete.
	return Promise.all(promises):andThen(function(shards)
		-- Step 5: Validate that all shards were retrieved.
		for i = 1, shardCount do
			if shards[i] == nil then
				-- A shard is missing, cannot reconstruct the file.
				return Promise.reject(`Missing shard {i} for file (shardId: {shardId})`)
			end
		end

		-- Step 6: Concatenate and decode the compressed data (first JSON decode, decompresses).
		-- This reverses the double JSON encoding done during the write process.
		local ok, compressedData = pcall(function()
			return HttpService:JSONDecode(table.concat(shards))
		end)
		if not ok then
			return Promise.reject(`Error decoding compressed file data (shardId: {shardId}): {compressedData}`) -- compressedData contains error msg here
		end
		if typeof(compressedData) ~= "buffer" then
			return Promise.reject(
				`Expected buffer after first decode, got {typeof(compressedData)} (shardId: {shardId})`
			)
		end

		-- Step 7: Convert the buffer back to a string and decode the original JSON data.
		local ok2, originalData = pcall(function()
			return HttpService:JSONDecode(buffer.tostring(compressedData))
		end)
		if not ok2 then
			return Promise.reject(`Error decoding original file data (shardId: {shardId}): {originalData}`) -- originalData contains error msg here
		end

		return originalData -- Successfully reconstructed original data.
	end)
	-- No explicit :catch here, errors from GetAsync (via retry) or rejections above will propagate.
end

return {
	isLargeFile = isLargeFile,
	write = write,
	read = read,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a6</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="276">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">JsonPatch</string>
								<string name="ScriptGuid">{7CC6BC73-46AA-4922-9C00-0787E04AB66A}</string>
								<ProtectedString name="Source"><![CDATA[local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)

--[[
  RFC 6902 implementation in Luau (Roblox) with two public functions:
    1) JSONPatch.applyPatch(doc, patch) -> applies the patch in-place (mutates & returns doc).
    2) JSONPatch.createPatch(original, modified) -> returns a minimal set of patch operations.
]]

--[[
	Based on https://github.com/Starcounter-Jack/JSON-Patch

	(The MIT License)

	Copyright (c) 2013, 2014, 2020 Joachim Wester

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	'Software'), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- JSON Pointer Utilities

local function isArray(value: any): boolean
	if typeof(value) ~= "table" then
		return false
	end

	if next(value) == nil then
		return true
	end

	local length = #value

	if length == 0 then
		return false
	end

	local count = 0
	local sum = 0
	for key in value do
		if typeof(key) ~= "number" then
			return false
		end
		if key % 1 ~= 0 or key < 1 then
			return false
		end
		count += 1
		sum += key
	end

	return sum == (count * (count + 1) / 2)
end

local function unescapeSegment(segment: string): string
	-- ~1 -> '/'
	-- ~0 -> '~'
	local res = string.gsub(segment, "~1", "/")
	res = string.gsub(res, "~0", "~")
	return res
end

local function escapeSegment(segment: string): string
	-- / -> '~1'
	-- ~ -> '~0'
	local res = string.gsub(segment, "~", "~0")
	res = string.gsub(res, "/", "~1")
	return res
end

local function parsePointer(pointer: string): { string }
	-- An empty string "" means "root"
	if pointer == "" then
		return {}
	end
	if string.sub(pointer, 1, 1) ~= "/" then
		error("Invalid JSON pointer (must start with / or be empty)")
	end
	local raw = string.sub(pointer, 2) -- skip leading '/'
	local segments = string.split(raw, "/")
	for i, seg in segments do
		segments[i] = unescapeSegment(seg)
	end
	return segments
end

-- Patch Application

local function getArrayIndexOrError(key: string, length: number, op: string): number
	local idx = tonumber(key)
	if idx == nil then
		error(`'{op}' path must be a valid numeric index; got '{key}'`)
	end
	idx += 1 -- 0-based to 1-based
	if idx < 1 or idx > length then
		error(`Array {op} index {idx - 1} out of bounds for length {length}`)
	end
	return idx
end

local function isStringifiedNumberOk(key: string): boolean
	if key == "0" then
		return true
	end

	local num = tonumber(key)
	if num == nil then
		return false
	end

	local str = tostring(num)
	return str == key
end

local function applyOperation(doc: any, opObj: Types.PatchOperation): any
	local op = opObj.op
	if typeof(op) ~= "string" then
		error("'op' must be a string")
	end

	local path = opObj.path
	if typeof(path) ~= "string" then
		error("missing valid 'path' string")
	end
	local segments = parsePointer(path)

	local parent = doc
	for i = 1, (#segments - 1) do
		local seg = segments[i]

		if isArray(parent) then
			if not isStringifiedNumberOk(seg) then
				error(`Path segment '{seg}' is not a valid array index`)
			end
			seg = getArrayIndexOrError(seg, #parent, op) :: any
		end

		if parent[seg] == nil then
			error("add to a non-existent target")
		end

		if typeof(parent[seg]) ~= "table" then
			error("cannot 'add' into non-table parent")
		end

		parent = parent[seg]
	end

	if opObj.op == "add" then
		local value = opObj.value
		if value == nil then
			error("missing 'value' parameter")
		end

		-- If path is empty, replace entire doc
		if #segments == 0 then
			return Tables.copyDeep(value)
		end

		local key = segments[#segments]

		local parentIsArray = isArray(parent)

		-- There's complex behavior with adding to arrays/objects based on the
		-- key and what kind of table the parent is. We treat parent as an array
		-- IF:
		-- 1. It's an empty table AND the key is "-" (append is the only valid
		--      operation)
		-- 2. It's a non-empty array AND the key is a number or "-" (append or
		--    insert)
		--
		-- Otherwise, we treat it as an object.

		local isAddingIntoEmptyArray = parentIsArray and #parent == 0 and key == "-"
		local isAddingIntoPopulatedArray = parentIsArray and #parent > 0 and (tonumber(key) ~= nil or key == "-")

		if isAddingIntoEmptyArray or isAddingIntoPopulatedArray then
			if key == "-" then
				-- append
				table.insert(parent, Tables.copyDeep(value))
			else
				if not isStringifiedNumberOk(key) then
					error("add op shouldn't add to array with bad number")
				end

				local index = getArrayIndexOrError(key, #parent, op)
				table.insert(parent, index, Tables.copyDeep(value))
			end
		else
			if parentIsArray and #parent > 0 then
				error("Object operation on array target")
			end

			parent[key] = Tables.copyDeep(value)
		end

		return doc
	elseif opObj.op == "remove" then
		-- If path is empty, remove entire doc => doc becomes nil
		if #segments == 0 then
			return nil
		end

		local key = segments[#segments]
		if isArray(parent) and tonumber(key) ~= nil then
			if not isStringifiedNumberOk(key) then
				error("remove op shouldn't remove from array with bad number")
			end

			local index = getArrayIndexOrError(key, #parent, op)
			table.remove(parent, index)
		else
			if parent[key] == nil then
				error(`Cannot remove non-existent key '{key}'`)
			end

			parent[key] = nil
		end

		return doc
	elseif opObj.op == "replace" then
		local value = opObj.value
		if value == nil then
			error("missing 'value' parameter")
		end

		-- If path is empty, replace entire doc
		if #segments == 0 then
			return Tables.copyDeep(value)
		end

		local key = segments[#segments]
		if isArray(parent) and tonumber(key) ~= nil then
			if not isStringifiedNumberOk(key) then
				error("replace op shouldn't replace in array with bad number")
			end

			local index = getArrayIndexOrError(key, #parent, op)
			parent[index] = Tables.copyDeep(value)
		else
			if parent[key] == nil then
				error(("Cannot replace non-existent path '%s'"):format(key))
			end
			parent[key] = Tables.copyDeep(value)
		end

		return doc
	else
		error(`Unrecognized op '{op}'`)
	end
end

-- Patch Generation

local function keys(obj: { [any]: any }): { any }
	local result = {}
	for k in obj do
		table.insert(result, k)
	end
	return result
end

local function getZeroBasedKey(key: any, parentIsArray: boolean): string
	if not parentIsArray then
		return escapeSegment(key)
	end
	local numericKey = tonumber(key)
	if numericKey == nil then
		return escapeSegment(key)
	end
	return tostring(numericKey - 1)
end

local function generate(obj1: any, obj2: any, patches: { Types.PatchOperation }, path: string): ()
	if obj1 == obj2 then
		return
	end

	local newKeys = keys(obj2)
	local oldKeys = keys(obj1)
	local deleted = false

	local obj1IsArray = isArray(obj1)
	local obj2IsArray = isArray(obj2)

	local obj1VirtualLength = obj1IsArray and #obj1 or 0

	for i = #oldKeys, 1, -1 do
		local key = oldKeys[i]
		local oldVal = obj1[key]

		local isKeyInObj = obj2[key] ~= nil
		local isUndefinedInNonArray = obj2[key] == nil and oldVal ~= nil and not obj2IsArray

		if isKeyInObj and not isUndefinedInNonArray then
			local newVal = obj2[key]

			local bothAreTables = typeof(oldVal) == "table" and typeof(newVal) == "table"
			local sameArrayType = isArray(oldVal) == isArray(newVal)
			local bothAreSameKindOfTable = bothAreTables and sameArrayType

			if bothAreSameKindOfTable then
				generate(oldVal, newVal, patches, path .. "/" .. getZeroBasedKey(key, obj1IsArray))
			else
				if oldVal ~= newVal then
					table.insert(patches, {
						op = "replace",
						path = path .. "/" .. getZeroBasedKey(key, obj1IsArray),
						value = Tables.copyDeep(newVal),
					})
				end
			end
		elseif obj1IsArray == obj2IsArray then
			table.insert(patches, {
				op = "remove",
				path = path .. "/" .. getZeroBasedKey(key, obj1IsArray),
			})
			deleted = true
		else
			table.insert(patches, {
				op = "replace",
				path = path,
				value = obj2,
			})
		end
	end

	if not deleted and #newKeys == #oldKeys then
		return
	end

	for _, key in newKeys do
		if obj1[key] == nil and obj2[key] ~= nil then
			if obj1IsArray then
				obj1VirtualLength += 1

				local numericKey = tonumber(key)
				if numericKey ~= nil and numericKey == obj1VirtualLength then
					table.insert(patches, {
						op = "add",
						path = path .. "/-",
						value = Tables.copyDeep(obj2[key]),
					})

					continue
				end
			end

			table.insert(patches, {
				op = "add",
				path = path .. "/" .. getZeroBasedKey(key, obj2IsArray),
				value = Tables.copyDeep(obj2[key]),
			})
		end
	end
end

local JSONPatch = {}

function JSONPatch.applyPatch(doc: any, patch: { Types.PatchOperation }): any
	for _, operation in patch do
		doc = applyOperation(doc, operation)
	end
	return doc
end

function JSONPatch.createPatch(original: any, modified: any): { Types.PatchOperation }
	local patches = {}
	generate(original, modified, patches, "")
	return patches
end

return JSONPatch
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a7</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="277">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Locks</string>
								<string name="ScriptGuid">{056D2AC1-E1D3-4AEA-B644-F2DD2356F830}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	Implements a distributed locking mechanism using Roblox's MemoryStoreService.
	This allows coordinating access to shared resources (like DataStore keys)
	across different game servers or instances.

	The locking strategy involves:
	- Attempting to atomically acquire a lock using `MemoryStoreService:UpdateAsync`.
	- Setting a Time-To-Live (TTL) on the lock key in MemoryStore.
	- Periodically refreshing the lock's TTL in a background task to maintain ownership.
	- Providing a mechanism (`onLockLost`) to notify the holder if the lock refresh fails
	  or the lock expires unexpectedly.

	This ensures that typically only one process holds the lock for a given key at a time.

	@class Locks
	@private
]=]

local HttpService = game:GetService("HttpService")

-- Small buffer subtracted from the TTL when calculating the local expiry time.
-- This helps account for potential clock skew or network latency, reducing the
-- chance of the local check (`isLocked`) returning true after the lock has
-- actually expired in MemoryStore.
local LOCK_TTL_ERROR_MARGIN_SECS = 0.2

local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local hashMapRetry = require(script.Parent.hashMapRetry)

--[=[
	Possible states of the lock acquisition and holding process.
	@type LockStatus "acquiring" | "held" | "released"
	@within Locks
	@tag enum
	@private
]=]
type LockStatus = "acquiring" | "held" | "released"

--[=[
	Represents an acquired lock handle, providing methods to interact with the lock.

	@interface LockHandle
	@within Locks
	.release () -> Promise -- Releases the lock immediately. Stops the refresh loop and attempts to clear the lock key in MemoryStore (by setting TTL to 0). Resolves when the release attempt is complete.
	.isLocked () -> boolean -- Checks if the lock is currently considered held locally. This checks both the internal status and compares the last confirmed expiry time (from MemoryStore) against the current local time. True if the lock is believed to be held.
	.onLockLost (() -> ()) -> (() -> ()) -- Registers a callback function to be invoked if the lock is lost unexpectedly (e.g., refresh fails, TTL expires). Returns a function to disconnect/unregister the callback.
]=]
export type LockHandle = {
	release: () -> Promise.Promise,
	isLocked: () -> boolean,
	onLockLost: (callback: () -> ()) -> () -> (),
}

--[=[
	Parameters for acquiring a lock.

	@interface AcquireLockParams
	@within Locks
	.storeContext Types.StoreContext<any> -- Shared store context containing logger and MemoryStoreHashMap instance.
	.key string -- The unique key identifying the resource to be locked.
	.duration number -- The duration (TTL) in seconds for which the lock should be held/refreshed.
	.refreshInterval number -- The interval in seconds at which the lock refresh should be attempted.
]=]
export type AcquireLockParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
	duration: number,
	refreshInterval: number,
}

--[=[
	Attempts to acquire a distributed lock for the specified key.

	Manages the lock acquisition process, including retries with exponential
	backoff, setting up the background refresh loop, and providing a LockHandle
	on success.

	@param params -- Configuration for the lock acquisition.
	@return Promise<LockHandle> -- Resolves with a LockHandle if the lock is acquired successfully.
	@error Rejects if the lock cannot be acquired within the specified duration/attempts, or if other MemoryStore errors occur.
	@within Locks
]=]
local function acquireLock(params: AcquireLockParams): Promise.TPromise<LockHandle>
	-- Unique identifier for this specific lock attempt/instance.
	local lockId = HttpService:GenerateGUID(false)
	-- List of callbacks to invoke if the lock is lost.
	local expiredCallbacks: { () -> () } = {}
	-- Handle for the `task.delay` used to trigger expiry callbacks locally.
	local expiryThread: thread? = nil
	-- Promise representing the background refresh loop.
	local refreshPromise: Promise.Promise? = nil

	-- Current state of the lock.
	local status: LockStatus
	-- The local time (`os.clock()`) when the lock is expected to expire based on the
	-- last successful `UpdateAsync` call, minus the error margin.
	local lastConfirmedExpiry: number? = nil

	local ctx = params.storeContext
	local key = params.key
	local logger = ctx.logger:extend({ method = "acquireLock", key = key, lockId = lockId })

	--[=[
		Helper function to update the internal lock status and log the transition.
		@param newStatus -- The new status to set.
		@within Locks
		@private
	]=]
	local function transitionTo(newStatus: LockStatus)
		logger:log("trace", `lock transition: {status or "nil"} -> {newStatus}`)
		status = newStatus
	end

	--[=[
		Invokes all registered `onLockLost` callbacks.
		Called when the local expiry timer (`expiryThread`) fires or when refresh fails.
		@within Locks
		@private
	]=]
	local function spawnExpiryCallbacks()
		-- Only spawn if still considered 'held' locally to avoid duplicate calls after release.
		if status == "held" then
			logger:log("warn", "lock expiry timer fired or refresh failed, invoking onLockLost callbacks")
			transitionTo("released")
			for _, callback in expiredCallbacks do
				task.spawn(callback)
			end
		end
	end

	--[=[
		Attempts to update the lock key in MemoryStore using UpdateAsync.
		This is used for initial acquisition, refresh, and release (with ttl=0).

		The transform function ensures atomicity:
		- If the key doesn't exist (`otherLockId == nil`), set it to our `lockId`.
		- If the key exists and holds our `lockId`, update the TTL (refresh).
		- If the key exists and holds a different `lockId`, do nothing (fail acquisition/refresh).

		Also manages the local expiry timer (`expiryThread`) based on successful updates.

		@param ttl -- The Time-To-Live in seconds for the UpdateAsync call.
		@return Types.RetryHandle<Promise<any>> -- Handle containing the promise and cancel function from `hashMapRetry`.
		@within Locks
		@private
	]=]
	local function tryUpdate(ttl: number): Types.RetryHandle<Promise.TPromise<any>>
		logger:log("trace", `attempting UpdateAsync on key '{key}' with ttl {ttl}`)

		-- Transform function for atomic update
		local function transformFunction(otherLockId: string?): string?
			if otherLockId == nil or otherLockId == lockId then
				-- Key is empty or already held by us, allow update/acquisition.
				return lockId
			end
			-- Key is held by someone else, prevent update. UpdateAsync returns nil.
			return nil
		end

		-- Wrap the MemoryStore call in retry logic
		local retryHandle = hashMapRetry(function()
			return ctx.lockHashMap:UpdateAsync(key, transformFunction, ttl)
		end)

		-- Side effects on successful update
		retryHandle.promise:tap(function(value)
			-- `value` will be `lockId` if UpdateAsync succeeded, `nil` otherwise.
			if value ~= nil then
				-- Update local expiry time based on successful MemoryStore update.
				lastConfirmedExpiry = os.clock() + ttl - LOCK_TTL_ERROR_MARGIN_SECS
				logger:log("trace", `UpdateAsync succeeded, lastConfirmedExpiry updated to {lastConfirmedExpiry}`)

				-- Cancel any existing expiry timer thread.
				if expiryThread then
					task.cancel(expiryThread)
				end

				-- If TTL > 0 (acquisition/refresh), start a new local timer.
				-- If TTL is 0 (release), don't start a timer.
				if ttl > 0 then
					logger:log("trace", `starting local expiry timer for {ttl} seconds`)
					expiryThread = task.delay(ttl, spawnExpiryCallbacks)
				end
			else
				logger:log("trace", `UpdateAsync failed or returned nil (lock held by another?)`)
			end
		end)

		return retryHandle
	end

	--[=[
		Releases the lock. Stops refresh/expiry timers and attempts to clear the
		lock in MemoryStore by setting TTL to 0.

		@return Promise -- Resolves when the release process is complete.
		@within Locks
		@private
	]=]
	local function release(): Promise.Promise
		logger:log("trace", "release function called")

		-- Idempotency check: only proceed if currently 'held'.
		if status ~= "held" then
			logger:log("trace", `lock not 'held' (status: {status}), skipping release logic`)
			return Promise.resolve()
		end
		transitionTo("released")

		-- Cancel local expiry timer.
		if expiryThread then
			task.cancel(expiryThread)
			expiryThread = nil
			logger:log("trace", "cancelled expiryThread")
		end

		-- Cancel background refresh loop.
		if refreshPromise then
			refreshPromise:cancel()
			refreshPromise = nil
			logger:log("trace", "cancelled refreshPromise")
		end

		-- Check if the lock is likely still valid in MemoryStore before trying to clear it.
		local isLikelyAcquiredRemotely = lastConfirmedExpiry and lastConfirmedExpiry > os.clock()
		if isLikelyAcquiredRemotely then
			logger:log("trace", "attempting to clear lock in MemoryStore (UpdateAsync with TTL 0)")
			-- Attempt to set TTL to 0. We don't need to wait for this promise to resolve fully,
			-- but we return it so the caller can wait if needed.
			return tryUpdate(0).promise:catch(function(err)
				logger:log("warn", "failed during final UpdateAsync(ttl=0) on release", { error = err })
				return Promise.reject(err) -- Pass through the error if needed
			end)
		else
			logger:log("trace", "lock likely already expired remotely, skipping final UpdateAsync")
			return Promise.resolve()
		end
	end

	--[=[
		Main loop for attempting to acquire the lock initially.
		Uses `tryUpdate` with exponential backoff.

		@return Promise -- Resolves when the lock is acquired, rejects if timeout occurs.
		@within Locks
		@private
	]=]
	local function waitForLock(): Promise.Promise
		logger:log("trace", "entering waitForLock loop")
		transitionTo("acquiring")

		local acquisitionStartTime = os.clock()
		local currentRetryHandle: Types.RetryHandle<Promise.TPromise<any>>? = nil
		local attemptCount = 0
		local maxAcquisitionTime = params.duration -- Use lock duration as acquisition timeout

		return Promise.new(function(resolve, reject, onCancel)
			-- Setup cancellation handler: clean up any pending retry and release the lock.
			onCancel(function()
				logger:log("trace", "waitForLock cancelled")
				local cleanupPromise = Promise.resolve()
				if currentRetryHandle then
					currentRetryHandle.cancel()
					-- The retry may have an in-flight request. To prevent race
					-- conditions, we only release after it settles.
					cleanupPromise = (currentRetryHandle :: any).promise
				end

				-- After potential retry settles, attempt release.
				cleanupPromise:finally(function()
					release():catch(function(err)
						-- Log release errors during cancellation but don't reject for them.
						logger:log("error", "failed to release lock during cancellation", { error = err })
					end)
				end)
			end)

			-- Run the acquisition loop in a separate thread to allow
			-- cancellation without abruptly stopping via coroutine.close.
			task.spawn(function()
				while (os.clock() - acquisitionStartTime) < maxAcquisitionTime do
					-- Check for cancellation at the start of each attempt.
					if onCancel() then
						logger:log("trace", "detected cancellation within loop")
						return -- Exit loop if cancelled
					end

					attemptCount += 1
					logger:log("trace", `acquisition attempt {attemptCount}`)
					currentRetryHandle = tryUpdate(params.duration)
					-- Await the result of the UpdateAsync attempt (wrapped in retry logic)
					local resolved, value = (currentRetryHandle :: any).promise:await()
					currentRetryHandle = nil -- Clear handle once settled

					if resolved and value ~= nil then
						-- Success! Lock acquired.
						logger:log("info", "lock acquired successfully")
						transitionTo("held")
						return resolve() -- Resolve the main acquireLock promise
					elseif not resolved then
						-- UpdateAsync (or retry logic) failed. Log warning.
						logger:log("warn", "attempt to acquire lock failed", {
							attemptCount = attemptCount,
							error = value, -- Error message from rejection
						})
						-- Continue loop if error is deemed retryable by hashMapRetry
					else
						-- UpdateAsync succeeded but returned nil (lock held by someone else).
						logger:log("trace", "lock currently held by another instance")
						-- Continue loop to retry.
					end

					-- Check for cancellation again after the attempt.
					if onCancel() then
						logger:log("trace", "detected cancellation after attempt")
						return -- Exit loop if cancelled
					end

					-- Exponential backoff before next attempt, capped at 30s.
					local retryAfter = math.min(2 ^ (attemptCount - 1), 30)
					logger:log("trace", `waiting {retryAfter}s before next attempt`)
					task.wait(retryAfter)
				end

				-- Loop finished without acquiring the lock within the time limit.
				logger:log("error", "failed to acquire lock within time limit", { duration = maxAcquisitionTime })
				return reject(`Failed to acquire lock for key '{key}' within {maxAcquisitionTime} seconds`)
			end)
		end)
	end

	--[=[
		Starts the background loop responsible for periodically refreshing the lock TTL.
		@within Locks
		@private
	]=]
	local function setupLockRefresh(): ()
		logger:log("trace", "setting up background lock refresh loop")

		local currentRefreshHandle: Types.RetryHandle<Promise.TPromise<any>>? = nil

		-- Create a promise representing the refresh loop's lifetime.
		refreshPromise = Promise.new(function(resolveLoop, _, onCancelLoop)
			-- Setup cancellation for the refresh loop promise itself.
			onCancelLoop(function()
				logger:log("trace", "refreshPromise cancelled")
				-- If a refresh attempt is in progress, cancel its retry handle.
				if currentRefreshHandle then
					currentRefreshHandle.cancel()
				end
			end)

			-- Run the refresh loop in a separate thread to allow
			-- cancellation without abruptly stopping via coroutine.close.
			task.spawn(function()
				-- Continue looping as long as the lock is considered 'held'.
				while status == "held" do
					-- Wait for the specified refresh interval.
					task.wait(params.refreshInterval)

					-- Check for cancellation or status change during the wait.
					if onCancelLoop() or status ~= "held" then
						logger:log("trace", "exiting refresh loop due to cancellation or status change")
						break
					end

					logger:log("trace", "attempting lock refresh")
					-- Attempt to update the lock TTL using tryUpdate.
					currentRefreshHandle = tryUpdate(params.duration)
					-- Await the result of the refresh attempt
					local resolved, value = (currentRefreshHandle :: any).promise:await()
					currentRefreshHandle = nil -- Clear handle once settled

					-- Check status again after the refresh attempt.
					if status ~= "held" then
						logger:log("trace", "exiting refresh loop, status changed during refresh attempt")
						break
					end

					-- If refresh failed (rejected or returned nil), the lock is lost.
					if not resolved or value == nil then
						logger:log("warn", "failed to refresh lock, lock considered lost", { error = value })
						-- Trigger expiry callbacks and exit the loop.
						spawnExpiryCallbacks()
						break
					else
						logger:log("trace", "lock refreshed successfully")
					end
				end

				-- Loop exited (either normally due to status change/cancellation, or due to refresh failure).
				logger:log("trace", "background refresh loop finished")
				resolveLoop() -- Resolve the main refreshPromise.
			end)
		end)
	end

	-- Construct the LockHandle object to be returned.
	local lockHandle: LockHandle = {
		release = release,
		isLocked = function(): boolean
			-- Check both internal status and local expiry time.
			return status == "held" and (lastConfirmedExpiry or 0) > os.clock()
		end,
		onLockLost = function(callback: () -> ()): () -> ()
			-- Add callback to the list.
			table.insert(expiredCallbacks, callback)
			-- Return a function to remove the callback from the list.
			return function()
				local idx = table.find(expiredCallbacks, callback)
				if idx then
					table.remove(expiredCallbacks, idx)
				end
			end
		end,
	}

	-- Chain the acquisition and refresh setup.
	return waitForLock() -- Attempt initial acquisition.
		:andThen(function()
			-- If acquisition succeeded, set up the refresh loop and return the handle.
			setupLockRefresh()
			return lockHandle
		end)
		:catch(function(err)
			-- If acquisition failed, attempt to release any partially acquired state
			-- and then re-reject with the original error.
			logger:log("error", "failed to acquire lock", { error = err })
			return release():andThen(function()
				-- Ensure the original error propagates.
				return Promise.reject(err)
			end)
		end)
end

--[=[
	Parameters for probing if a lock is active.

	@interface ProbeLockActiveParams
	@within Locks
	.storeContext Types.StoreContext<any> -- Shared store context containing logger and MemoryStoreHashMap instance.
	.key string -- The unique key identifying the resource to be locked.
]=]
export type ProbeLockActiveParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
}

--[=[
	Checks if a lock key currently exists in MemoryStore without attempting to acquire it.
	Useful for determining if another process likely holds the lock.

	Note: This is a point-in-time check and doesn't guarantee the lock state won't
	change immediately after the check completes.

	@param params -- Parameters for probing the lock.
	@return Promise<boolean> -- Resolves with true if the lock key exists, false otherwise.
	@within Locks
]=]
local function probeLockActive(params: ProbeLockActiveParams): Promise.TPromise<boolean>
	local ctx = params.storeContext
	local key = params.key
	local logger = ctx.logger:extend({ method = "probeLockActive", key = key })

	logger:log("trace", "probing if lock is active via GetAsync")

	-- Use GetAsync wrapped in retry logic.
	local retryHandle = hashMapRetry(function()
		return ctx.lockHashMap:GetAsync(key)
	end)

	-- Check if the GetAsync call returned a value (meaning the key exists).
	return retryHandle.promise:andThen(function(value)
		local isActive = value ~= nil
		logger:log("trace", `probe result: {isActive}`)
		return isActive
	end)
end

return {
	acquireLock = acquireLock,
	probeLockActive = probeLockActive,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a8</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="278">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Log</string>
								<string name="ScriptGuid">{261823F7-304A-4829-8652-846DD3D490D1}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Log
	@private

	Provides a structured logging implementation for the Lyra library.

	**Design:**
	- **Callback-based:** Instead of directly printing or sending logs, this module
	  uses a callback function (`logCallback`) provided during logger creation. This
	  allows the consuming application to decide how and where log messages are routed
	  (e.g., print to console, send to an external service, store in memory).
	- **Structured Context:** Log messages include a `context` table. Loggers can be
	  `extend`ed with additional context fields, which are automatically merged into
	  every subsequent log message created by that logger instance or its descendants.
	  This helps provide detailed, structured information for debugging and monitoring.
	- **Log Levels:** Supports standard log levels (`fatal`, `error`, `warn`, `info`,
	  `debug`, `trace`). A global log level can be set using `Log.setLevel` to filter
	  out messages below the desired severity.

	**Usage:**
	```lua
	local Log = require(script.Parent.Log)

	-- Set the global minimum log level (optional, defaults to "info")
	Log.setLevel("debug")

	-- Create a logger instance with a callback
	local myLogger = Log.createLogger(function(logMessage)
		print(`[{logMessage.level}] {logMessage.message}`, logMessage.context)
	end, { initialContext = "value" })

	-- Log messages
	myLogger:log("info", "User logged in", { userId = 123 })

	-- Create a logger with extended context
	local sessionLogger = myLogger:extend({ sessionId = "abc" })
	sessionLogger:log("debug", "Session data loaded")
	-- Output will include { initialContext = "value", sessionId = "abc", userId = 123 }
	-- if logged via myLogger, or { initialContext = "value", sessionId = "abc" }
	-- if logged via sessionLogger.
	```
]=]

--[=[
	Represents the different log levels available for logging messages.

	@type LogLevel "fatal" | "error" | "warn" | "info" | "debug" | "trace"
	@tag enum
	@within Log
]=]
export type LogLevel = "fatal" | "error" | "warn" | "info" | "debug" | "trace"

--[=[
	Represents a log message sent to the logger's callback function.

	@interface LogMessage
	@within Log
	.message string -- The main content of the log message.
	.level LogLevel -- The severity level of the message.
	.context { [string]: any }? -- Optional table containing additional structured context.
]=]
export type LogMessage = {
	message: string,
	level: LogLevel,
	context: { [string]: any }?,
}

export type LoggerImpl = {
	__index: LoggerImpl,

	log: (self: Logger, level: LogLevel, message: string, context: { [string]: any }?) -> (),
	extend: (self: Logger, context: { [string]: any }) -> Logger,
}

export type LoggerProps = {
	_logCallback: (logMessage: LogMessage) -> (),
	_context: { [string]: any },
}

export type Logger = typeof(setmetatable({} :: LoggerProps, {} :: LoggerImpl))

-- Ordered list of log levels from most severe to least severe.
local levels = {
	"fatal",
	"error",
	"warn",
	"info",
	"debug",
	"trace",
}

-- The main Log module table, holds global settings like the current log level.
local Log = {
	level = "info", -- Default global log level.
}

--[=[
	Sets the global minimum log level.
	Messages with a severity lower than this level will be ignored by all loggers.

	@within Log
	@param level LogLevel -- The minimum log level to allow.
	@error string -- Throws an error if the provided level is invalid.
]=]
function Log.setLevel(level: LogLevel)
	if table.find(levels, level) == nil then
		error(`Invalid log level: '{level}'`)
	end
	Log.level = level
end

-- Metatable implementing the Logger methods. (Internal)
local Logger: LoggerImpl = {} :: LoggerImpl
Logger.__index = Logger

--[=[
	Logs a message if its level is at or above the globally set log level.

	Merges the provided `context` table with the logger's persistent context
	before calling the configured `_logCallback`.

	@within Log
	@param level LogLevel -- The severity level of the message.
	@param message string -- The log message content.
	@param context { [string]: any }? -- Optional additional context specific to this log call.
]=]
function Logger:log(level: LogLevel, message: string, context: { [string]: any }?)
	-- Filter messages based on the global log level.
	if table.find(levels, level) > table.find(levels, Log.level) then
		return
	end

	-- Merge instance context with call-specific context.
	local finalContext = table.clone(self._context)
	if context then
		for key, value in context do
			finalContext[key] = value
		end
	end

	-- Call the configured log callback within a protected call to catch errors.
	local ok, result = pcall(function()
		self._logCallback({
			level = level,
			message = message,
			context = finalContext,
		})
	end)

	if not ok then
		-- If the logging callback itself errors, print a warning.
		warn(`Error in log callback: {result}`)
	end
end

--[=[
	Creates a new Logger instance that inherits the parent's callback
	but has an extended context.

	The new logger's context is a merged table containing the parent's context
	and the additional `context` provided here.

	@within Log
	@param context { [string]: any } -- The additional context fields to add.
	@return Logger -- A new Logger instance with the extended context.
]=]
function Logger:extend(context: { [string]: any }): Logger
	-- Merge existing context with the new context.
	local finalContext = table.clone(self._context)
	for key, value in context do
		finalContext[key] = value
	end

	-- Create and return a new logger instance sharing the callback but with the new context.
	return setmetatable({
		_logCallback = self._logCallback,
		_context = finalContext,
	}, Logger)
end

--[=[
	Factory function to create a new root Logger instance.

	@within Log
	@param logCallback (logMessage: LogMessage) -> () -- The function that will be called for each log message that passes the level filter. This function receives the complete `LogMessage` object including merged context.
	@param context { [string]: any }? -- Optional initial context for this logger.
	@return Logger -- A new Logger instance.
]=]
function Log.createLogger(logCallback: (logMessage: LogMessage) -> (), context: { [string]: any }?): Logger
	return setmetatable({
		_logCallback = logCallback,
		_context = context or {},
	}, Logger)
end

return Log
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004a9</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="279">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Migrations</string>
								<string name="ScriptGuid">{711FC921-9962-47AC-B093-F95EE892FA97}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Migrations
	@private

	Provides functionality for managing and applying data migrations.

	**Concept:** As data schemas evolve over time, older data stored
	in DataStores needs to be updated to match the new structure. This module
	allows defining a series of migration steps (`Types.MigrationStep`) that
	transform data from one version of the schema to the next.

	**Workflow:**
	1. Define migration steps using helpers like `makeAddFieldsStep` or `makeTransformStep`.
	   Each step must have a unique `name`.
	2. Provide the list of steps to the `Store` via `StoreContext`.
	3. When data is loaded (`Session:load`), the `apply` function in this module is called.
	4. `apply` compares the list of all defined steps against the `appliedMigrations`
	   list stored within the `DataStoreRecord`.
	5. It executes the `apply` function of any step that hasn't been applied yet, in the
	   order they are defined.
	6. The `apply` function of each step receives the current data and returns the transformed data.
	7. The names of successfully applied steps are added to the `appliedMigrations` list,
	   which is then saved back to the `DataStoreRecord`.

	**Idempotency:** The system ensures migrations are idempotent (applying them multiple
	times has the same effect as applying them once) by checking the `appliedMigrations` list
	before running a step.

	**Error Handling:** Each step's `apply` function is executed within a `pcall` to catch
	errors. If a step fails, the migration process stops, and the error is propagated.
]=]

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)

--[=[
	Alias for a generic data table type used in migrations.

	@type Data { [string]: any }
	@within Migrations
	@private
]=]
type Data = { [string]: any }

--[=[
	Validates that the provided migration steps adhere to the expected structure.

	@within Migrations
	@param steps {Types.MigrationStep} -- The list of migration steps to validate.
	@error string -- Throws an error if any step is malformed.
]=]
local function validate(steps: { Types.MigrationStep })
	assert(typeof(steps) == "table", "steps must be a table")
	for _, step in steps do
		assert(typeof(step) == "table", "step must be a table")
		assert(typeof(step.name) == "string", "step.name must be a string")
		assert(typeof(step.apply) == "function", "step.apply must be a function")
	end
end

--[=[
	Helper function to create a common type of migration step: adding new fields
	with default values to existing data. Uses a deep merge strategy.

	@within Migrations
	@param name string -- The unique name for this migration step.
	@param fields Data -- A table containing the new fields and their default values.
	@return Types.MigrationStep -- A migration step object.
]=]
local function makeAddFieldsStep(name: string, fields: Data): Types.MigrationStep
	return {
		name = name,
		apply = function(data)
			-- Merges the default `fields` into the existing `data`.
			-- Existing keys in `data` are preserved unless they are tables themselves,
			-- in which case they are recursively merged.
			return Tables.mergeDeep(fields, data)
		end,
	}
end

--[=[
	Helper function to create a migration step that applies a custom transformation
	function to the data.

	@within Migrations
	@param name string -- The unique name for this migration step.
	@param transformFunc (currentValue: Data) -> Data -- The function that takes the current data and returns the transformed data.
	@return Types.MigrationStep -- A migration step object.
]=]
local function makeTransformStep(name: string, transformFunc: (currentValue: Data) -> Data): Types.MigrationStep
	return {
		name = name,
		apply = transformFunc,
	}
end

--[=[
	Parameters for the `apply` function.

	@interface ApplyParams
	@within Migrations
	.logger Log.Logger -- Logger instance for logging migration progress and errors.
	.data Data -- The current data loaded from the DataStore record's File.
	.steps {Types.MigrationStep} -- The list of all defined migration steps for the store.
	.appliedMigrations {string} -- The list of names of migration steps already applied to this specific data record, loaded from the DataStoreRecord.
]=]
export type ApplyParams = {
	logger: Log.Logger,
	data: Data,
	steps: { Types.MigrationStep },
	appliedMigrations: { string },
}

--[=[
	Result returned by the `apply` function upon successful completion.

	@interface ApplyResult
	@within Migrations
	.data Data -- The potentially modified data after applying necessary migration steps.
	.appliedMigrations {string} -- The updated list of applied migration names, including any newly applied steps. This should be saved back to the DataStoreRecord.
]=]
export type ApplyResult = {
	data: Data,
	appliedMigrations: { string },
}

--[=[
	Applies pending migration steps to the data.

	Iterates through the defined `steps` and applies any step whose name is not
	present in the `appliedMigrations` list. Ensures idempotency and uses `pcall`
	for safe execution of each step's `apply` function.

	@within Migrations
	@param params ApplyParams -- The parameters for applying migrations.
	@return Promise<ApplyResult> -- A Promise that resolves with the updated data and the new list of applied migration names.
	@error string -- Rejects if any migration step fails during `pcall`.
]=]
local function apply(params: ApplyParams): Promise.TPromise<ApplyResult>
	local logger = params.logger
	local currentData = params.data
	-- Clone the list to avoid modifying the original list passed in params directly within this function scope.
	local appliedMigrations = table.clone(params.appliedMigrations)

	-- Create a set for quick lookup of already applied migrations.
	local appliedSet = {}
	for _, name in appliedMigrations do
		appliedSet[name] = true
	end

	return Promise.new(function(resolve, reject)
		for _, step in params.steps do
			-- Idempotency Check: Only apply if the step name is not in the applied set.
			if not appliedSet[step.name] then
				logger:log("trace", "applying migration step", { stepName = step.name })

				-- Deep copy the data before applying the step to avoid modifying the original
				-- `currentData` reference in case of an error within `step.apply`.
				-- TODO: Do we actually care about atomicity here? This might be a performance hit.
				local staged = Tables.copyDeep(currentData)
				-- Safely execute the migration step's apply function.
				local ok, result = pcall(step.apply, staged)

				if not ok then
					-- If pcall failed, log the error and reject the promise.
					logger:log("error", "failed to apply migration step", { stepName = step.name, error = result })
					return reject(`Failed migration step '{step.name}': {result}`)
				end

				-- If pcall succeeded, update currentData with the result.
				-- Deep copy again to ensure `currentData` holds a distinct copy for the next step.
				-- TODO: We should probably just warn about not modifying the data after returning - this is expensive.
				currentData = Tables.copyDeep(result)
				-- Add the step name to the list of applied migrations for this record.
				table.insert(appliedMigrations, step.name)
				-- Also update the lookup set for the next iteration.
				appliedSet[step.name] = true
			end
		end

		-- All applicable steps applied successfully. Resolve with the final data and updated list.
		return resolve({
			data = currentData,
			appliedMigrations = appliedMigrations,
		})
	end)
end

--[=[
	Utility function to extract just the names from a list of migration steps.

	@within Migrations
	@param migrations {Types.MigrationStep} -- The list of migration steps.
	@return {string} -- A list containing only the names of the migration steps.
]=]
local function getStepNames(migrations: { Types.MigrationStep }): { string }
	local names = {}
	for _, step in migrations do
		table.insert(names, step.name)
	end
	return names
end

return {
	makeAddFieldsStep = makeAddFieldsStep,
	makeTransformStep = makeTransformStep,
	validate = validate,
	apply = apply,
	getStepNames = getStepNames,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004aa</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="280">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MockDataStoreService</string>
								<string name="ScriptGuid">{3583992E-0B4E-43D2-984D-1A2FCD0D27B0}</string>
								<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Tables = require(script.Parent.Tables)

local MAX_QUEUE_SIZE = 30
local RATE_LIMITS = {
	GetAsync = { Base = 60, PlayerMultiplier = 10 },
	SetAsync = { Base = 60, PlayerMultiplier = 10 },
	UpdateAsync = { Base = 60, PlayerMultiplier = 10 },
	RemoveAsync = { Base = 60, PlayerMultiplier = 10 },
	GetVersion = { Base = 5, PlayerMultiplier = 2 },
}

local MAX_KEY_LENGTH = 50
local MAX_DATA_SIZE = 4_194_304
local MAX_METADATA_SIZE = 300
local CACHE_DURATION = 4

local function getLatencyForRequest(service: any, requestType: string): number
	if service._latencyByRequestType[requestType] then
		return service._latencyByRequestType[requestType]
	end

	if service._randomLatencyRange then
		local min = service._randomLatencyRange.min
		local max = service._randomLatencyRange.max
		return min + math.random() * (max - min)
	end

	return service._globalLatency or 0.1
end

local function shouldSimulateError(service: any, requestType: string): (boolean, string?)
	if #service.queuedErrors[requestType] > 0 then
		return true, table.remove(service.queuedErrors[requestType], 1)
	end

	if service._errorRates[requestType] and math.random() < service._errorRates[requestType] then
		return true, "DataStore request failed due to random error simulation"
	end

	if service._simulateThrottling then
		return true, "DataStore request was throttled, try again later"
	end

	if service._simulateTimeout then
		return true, "DataStore request timed out"
	end

	return false, nil
end

local function doLatency(service: any, requestType: string)
	local latency = getLatencyForRequest(service, requestType)
	if latency > 0 then
		task.wait(latency)
	end
end

local function getNow()
	return DateTime.now().UnixTimestampMillis
end

local function msToHours(ms: number)
	return math.floor(ms / (60 * 60 * 1000))
end

local function getUtcHour()
	return msToHours(getNow())
end

local function createVersion(value: any, userIds: any, metadata: any)
	return {
		Value = value,
		UserIds = userIds or {},
		Metadata = metadata or {},
		CreatedTime = getNow(),
		Version = tostring(getNow()),
	}
end

local function createMockKeyInfo(userIds: any, metadata: any)
	local info = {
		CreatedTime = getNow(),
		UpdatedTime = getNow(),
		Version = tostring(getNow()),
		userIds = userIds or {},
		metadata = metadata or {},
		GetUserIds = function(self)
			return self.userIds
		end,
		GetMetadata = function(self)
			return self.metadata
		end,
	}
	return info
end

local function validateMetadata(metadata: any)
	if metadata == nil then
		return
	end

	if typeof(metadata) ~= "table" then
		error("DataStoreService: Metadata must be a table", 0)
	end

	local serialized = game:GetService("HttpService"):JSONEncode(metadata)
	if #serialized > MAX_METADATA_SIZE then
		error(`DataStoreService: Metadata size exceeds {MAX_METADATA_SIZE} limit`, 0)
	end
end

local function getScopedData(self: any)
	local datastore = self._service.mockData[self.datastoreName]
	if not datastore then
		datastore = {}
		self._service.mockData[self.datastoreName] = datastore
	end

	local scopedData = datastore[self.scope]
	if not scopedData then
		scopedData = {}
		datastore[self.scope] = scopedData
	end

	return scopedData
end

local function getVersionsForKey(self: any, key: string)
	local versionKey = `{self.datastoreName}|{self.scope}|{key}`
	if not self._service.mockVersions[versionKey] then
		self._service.mockVersions[versionKey] = {}
	end
	return self._service.mockVersions[versionKey]
end

local function getCacheKey(self: any, key: string)
	return `{self.datastoreName}|{self.scope}|{key}`
end

local function getCachedValue(self: any, key: string)
	local cacheKey = getCacheKey(self, key)
	local cached = self._service.mockCache[cacheKey]
	if cached and (os.time() - cached.timestamp) < CACHE_DURATION then
		return cached.value, cached.keyInfo
	end
	return nil, nil :: any
end

local function setCachedValue(self: any, key: string, value: any, keyInfo: any)
	local cacheKey = getCacheKey(self, key)
	self._service.mockCache[cacheKey] = {
		value = value,
		keyInfo = keyInfo,
		timestamp = os.time(),
	}
end

local function enforceKeyLimits(key: any)
	if typeof(key) ~= "string" then
		error("DataStoreService: Key must be a string", 0)
	end

	if #key == 0 then
		error("DataStoreService: Key name can't be empty", 0)
	end

	if #key > MAX_KEY_LENGTH then
		error(`DataStoreService: Key name exceeds the {MAX_KEY_LENGTH} character limit`, 0)
	end
end

local function enforceDataLimits(value: any)
	if value == nil then
		return
	end

	local success, result = pcall(function()
		return game:GetService("HttpService"):JSONEncode(value)
	end)
	if not success then
		error(`DataStoreService: Cannot store {typeof(value)} in DataStore`, 0)
	end

	if #result > MAX_DATA_SIZE then
		error(`DataStoreService: Serialized value exceeds {MAX_DATA_SIZE} limit`, 0)
	end
end

local function doRateLimitAndQueue(self: any, requestType: string)
	local queue = self._service.requestQueues[requestType]
	local limitData = RATE_LIMITS[requestType]
	if not limitData then
		limitData = RATE_LIMITS.GetAsync
	end

	local budget = self._service._customBudgets[requestType]
	if not budget then
		local currentPlayers = 15
		budget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)
	end

	if #queue >= budget then
		return false
	end

	if #queue >= MAX_QUEUE_SIZE then
		error(
			`DataStoreService:{requestType}() request dropped. Request was throttled, but throttled request queue was full`,
			0
		)
	end

	if self._service._forcedThrottles[requestType] then
		local throttleInfo = self._service._forcedThrottles[requestType]
		if throttleInfo.endTime > os.time() then
			error("DataStoreService: Request is currently throttled", 0)
		else
			self._service._forcedThrottles[requestType] = nil
		end
	end

	table.insert(queue, true)
	doLatency(self._service, requestType)
	local fn = table.remove(queue, 1)

	local shouldError, errorMessage = shouldSimulateError(self._service, requestType)
	if shouldError then
		error(errorMessage, 0)
	end

	if typeof(fn) == "function" then
		fn()
	end

	return true
end

local function sanitize(value: any)
	return Tables.copyDeep(value)
end

local MockDataStore = {}

function MockDataStore:SetAsync(key, value, userIds, options)
	value = sanitize(value)
	enforceKeyLimits(key)
	enforceDataLimits(value)
	if options then
		validateMetadata(options:GetMetadata())
	end

	doRateLimitAndQueue(self, "SetAsync")

	local scopedData = getScopedData(self)
	local versions = getVersionsForKey(self, key)
	local currentHour = getUtcHour()

	if #versions == 0 or msToHours(versions[#versions].CreatedTime) ~= currentHour then
		table.insert(versions, createVersion(value, userIds, options and options:GetMetadata()))
	else
		local currentVersion = versions[#versions]
		currentVersion.Value = value
		if userIds then
			currentVersion.UserIds = userIds
		end
		if options then
			currentVersion.Metadata = options:GetMetadata() or {}
		end
	end

	local latestVersion = versions[#versions].Version
	scopedData[key] = value
	local keyInfo = createMockKeyInfo(userIds, options and options:GetMetadata())
	self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`] = keyInfo

	setCachedValue(self, key, value, keyInfo)

	return latestVersion
end

function MockDataStore:GetAsync(key, options)
	enforceKeyLimits(key)

	if options == nil or options.UseCache == true then
		local cachedValue, cachedKeyInfo = getCachedValue(self, key)
		if cachedValue ~= nil then
			return cachedValue, cachedKeyInfo
		end
	end

	doRateLimitAndQueue(self, "GetAsync")

	local scopedData = getScopedData(self)
	local data = scopedData[key]
	local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`]

	if data ~= nil then
		setCachedValue(self, key, data, keyInfo)
	end

	return data, keyInfo
end

function MockDataStore:UpdateAsync(key, transformFunction)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "UpdateAsync")

	while true do
		local scopedData = getScopedData(self)
		local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`] or createMockKeyInfo()
		local currentValue = scopedData[key]
		local valueForCallback = currentValue ~= nil and Tables.copyDeep(currentValue)

		local newValue, newUserIds, newMetadata = transformFunction(valueForCallback, keyInfo)
		if newValue == nil then
			return currentValue, keyInfo
		end
		newValue = sanitize(newValue)

		enforceDataLimits(newValue)
		validateMetadata(newMetadata)

		if not Tables.equalsDeep(currentValue, scopedData[key]) then
			continue
		end

		local versions = getVersionsForKey(self, key)
		local currentHour = getUtcHour()

		if #versions == 0 or versions[#versions].CreatedTime ~= currentHour then
			table.insert(
				versions,
				createVersion(newValue, newUserIds or keyInfo:GetUserIds(), newMetadata or keyInfo:GetMetadata())
			)
		else
			local currentVersion = versions[#versions]
			currentVersion.Value = newValue
			if newUserIds then
				currentVersion.UserIds = newUserIds
			end
			if newMetadata then
				currentVersion.Metadata = newMetadata
			end
		end

		scopedData[key] = newValue
		if newUserIds ~= nil then
			keyInfo.userIds = newUserIds
		end
		if newMetadata ~= nil then
			keyInfo.metadata = newMetadata
		end
		keyInfo.UpdatedTime = getNow()
		keyInfo.Version = tostring(getNow())

		setCachedValue(self, key, newValue, keyInfo)
		return newValue, keyInfo
	end
end

function MockDataStore:RemoveAsync(key)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "RemoveAsync")

	local scopedData = getScopedData(self)
	local data = scopedData[key]
	local keyInfo = self._service.mockKeyInfo[`{self.datastoreName}|{self.scope}|{key}`]

	if data ~= nil then
		local versions = getVersionsForKey(self, key)
		table.insert(versions, createVersion(nil, nil, nil))
	end

	scopedData[key] = nil

	local cacheKey = getCacheKey(self, key)
	self._service.mockCache[cacheKey] = nil

	return data, keyInfo
end

function MockDataStore:GetVersionAsync(key, version)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "GetVersion")

	local versions = getVersionsForKey(self, key)
	for _, v in versions do
		if v.Version == version then
			return v.Value, createMockKeyInfo(v.UserIds, v.Metadata)
		end
	end
	return nil, nil :: any
end

function MockDataStore:ListVersionsAsync(key, sortDirection, minDate, maxDate)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self, "GetVersion")

	local versions = getVersionsForKey(self, key)
	local results = {}

	for _, v in versions do
		if (not minDate or v.CreatedTime >= minDate) and (not maxDate or v.CreatedTime <= maxDate) then
			table.insert(results, {
				Version = v.Version,
				CreatedTime = v.CreatedTime,
			})
		end
	end

	if sortDirection == Enum.SortDirection.Descending then
		table.sort(results, function(a, b)
			return a.CreatedTime > b.CreatedTime
		end)
	else
		table.sort(results, function(a, b)
			return a.CreatedTime < b.CreatedTime
		end)
	end

	return {
		IsFinished = true,
		GetCurrentPage = function()
			return results
		end,
	}
end

local function createMockStore(service: any, datastoreName: string, scope: string?)
	return setmetatable({
		datastoreName = datastoreName,
		scope = scope or "global",
		_service = service,
	}, service.mockStoreMeta)
end

local function new()
	local mockStoreMeta = table.clone(MockDataStore)
	mockStoreMeta.__index = mockStoreMeta

	local tbl = {
		dataStores = {},
		mockData = {},
		mockKeyInfo = {},
		mockVersions = {},
		mockCache = {},
		requestQueues = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
			GetVersion = {},
		},
		queuedErrors = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
			GetVersion = {},
		},
		mockStoreMeta = mockStoreMeta,

		_globalLatency = nil,
		_latencyByRequestType = {},
		_randomLatencyRange = nil,
		_errorRates = {},
		_simulateThrottling = false,
		_simulateTimeout = false,
		_customBudgets = {},
		_forcedThrottles = {},
	}

	tbl.GetDataStore = function(self, datastoreName: string, scope: string?)
		local store = self.dataStores[`{datastoreName}{scope or ""}`]
		if not store then
			store = createMockStore(self, datastoreName, scope)
			self.dataStores[`{datastoreName}{scope or ""}`] = store
		end
		return store
	end

	tbl.GetRequestBudgetForRequestType = function(self, requestType: Enum.DataStoreRequestType)
		local requestTypeStr = requestType.Name

		local queueKey = requestTypeStr
		if requestTypeStr == "GetVersionAsync" then
			queueKey = "GetVersion"
		end
		if requestTypeStr == "GetIncrementAsync" then
			queueKey = "GetAsync"
		end
		if requestTypeStr == "SetIncrementAsync" then
			queueKey = "SetAsync"
		end

		if self._customBudgets[queueKey] then
			return self._customBudgets[queueKey]
		end

		local limitData = RATE_LIMITS[queueKey]
		if not limitData then
			limitData = RATE_LIMITS.GetAsync
		end

		local currentPlayers = 15
		local totalBudget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)

		local currentQueueSize = #self.requestQueues[queueKey]
		return math.max(0, totalBudget - currentQueueSize)
	end

	return (tbl :: any) :: DataStoreService
end

return {
	new = new,

	mockStoreMethod = function(service, method: string, jest: any)
		local real = service.mockStoreMeta[method]
		local mock, fn = jest.fn(real)
		service.mockStoreMeta[method] = fn
		return mock, real
	end,

	setGlobalLatency = function(service: any, seconds: number)
		service._globalLatency = seconds
	end,
	setLatencyForRequestType = function(service: any, requestType: string, seconds: number)
		service._latencyByRequestType[requestType] = seconds
	end,
	setRandomLatency = function(service: any, minSeconds: number, maxSeconds: number)
		service._randomLatencyRange = { min = minSeconds, max = maxSeconds }
	end,
	queueError = function(service: any, requestType: string, errorMessage: string, count: number?)
		for _ = 1, count or 1 do
			table.insert(service.queuedErrors[requestType], errorMessage)
		end
	end,
	setErrorRate = function(service: any, requestType: string, rate: number)
		service._errorRates[requestType] = rate
	end,
	simulateThrottling = function(service: any, enabled: boolean)
		service._simulateThrottling = enabled
	end,
	simulateTimeout = function(service: any, enabled: boolean)
		service._simulateTimeout = enabled
	end,
	setRequestBudget = function(service: any, requestType: string, budget: number)
		service._customBudgets[requestType] = budget
	end,
	forceThrottle = function(service: any, requestType: string, duration: number)
		service._forcedThrottles[requestType] = {
			endTime = os.time() + duration,
		}
	end,
	snapshot = function(service: any)
		return HttpService:JSONEncode({
			mockData = service.mockData,
			mockKeyInfo = service.mockKeyInfo,
			mockVersions = service.mockVersions,
			mockCache = service.mockCache,
		})
	end,
	restore = function(service: any, snapshot: string)
		local decoded = HttpService:JSONDecode(snapshot)
		service.mockData = decoded.mockData
		service.mockKeyInfo = decoded.mockKeyInfo
		service.mockVersions = decoded.mockVersions
		service.mockCache = decoded.mockCache
	end,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ab</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="281">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MockMemoryStoreService</string>
								<string name="ScriptGuid">{F0783497-F2FD-46F4-8CDF-4059BF498452}</string>
								<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Tables = require(script.Parent.Tables)

local MAX_QUEUE_SIZE = 30
local RATE_LIMITS = {
	GetAsync = { Base = 100, PlayerMultiplier = 10 },
	SetAsync = { Base = 100, PlayerMultiplier = 10 },
	UpdateAsync = { Base = 100, PlayerMultiplier = 10 },
	RemoveAsync = { Base = 100, PlayerMultiplier = 10 },
}

local MAX_KEY_LENGTH = 128
local MAX_VALUE_SIZE = 32 * 1024 -- 32KB
local MAX_UPDATE_RETRIES = 3
local MAX_EXPIRATION = 3888000 -- 45 days in seconds

local function getNow()
	return DateTime.now().UnixTimestampMillis
end

local function getLatencyForRequest(service: any, requestType: string): number
	if service._latencyByRequestType[requestType] then
		return service._latencyByRequestType[requestType]
	end

	if service._randomLatencyRange then
		local min = service._randomLatencyRange.min
		local max = service._randomLatencyRange.max
		return min + math.random() * (max - min)
	end

	return service._globalLatency or 0.1
end

local function shouldSimulateError(service: any, requestType: string): (boolean, string?)
	if #service.queuedErrors[requestType] > 0 then
		return true, table.remove(service.queuedErrors[requestType], 1)
	end

	if service._errorRates[requestType] and math.random() < service._errorRates[requestType] then
		return true, "InternalError: random error simulation"
	end

	if service._simulateThrottling then
		return true, "Throttled: MemoryStore request was throttled, try again later"
	end

	if service._simulateTimeout then
		return true, "Timeout: MemoryStore request timed out"
	end

	return false, nil
end

local function doLatency(service: any, requestType: string)
	local latency = getLatencyForRequest(service, requestType)
	if latency > 0 then
		task.wait(latency)
	end
end

local function doRateLimitAndQueue(service: any, requestType: string)
	local queue = service.requestQueues[requestType]
	local limitData = RATE_LIMITS[requestType]
	local budget = service._customBudgets[requestType]
	if not budget then
		local currentPlayers = 15
		budget = limitData.Base + (currentPlayers * limitData.PlayerMultiplier)
	end

	if #queue >= budget then
		error("TotalRequestsOverLimit", 0)
	end

	if #queue >= MAX_QUEUE_SIZE then
		error("RequestThrottled", 0)
	end

	if service._forcedThrottles[requestType] then
		local throttleInfo = service._forcedThrottles[requestType]
		if throttleInfo.endTime > os.time() then
			error("MemoryStore request is currently throttled", 0)
		else
			service._forcedThrottles[requestType] = nil
		end
	end

	table.insert(queue, true)
	doLatency(service, requestType)
	local fn = table.remove(queue, 1)

	local shouldError, errorMessage = shouldSimulateError(service, requestType)
	if shouldError then
		error(errorMessage, 0)
	end

	if typeof(fn) == "function" then
		fn()
	end
end

local function enforceKeyLimits(key: string)
	if typeof(key) ~= "string" then
		error("InvalidRequest: key must be a string", 0)
	end
	if #key == 0 then
		error("InvalidRequest: key cannot be empty", 0)
	end
	if #key > MAX_KEY_LENGTH then
		error("InvalidRequest: key length exceeds limit", 0)
	end
end

local function enforceValueLimits(value: any)
	if value == nil then
		return
	end

	local success, encoded = pcall(function()
		return game:GetService("HttpService"):JSONEncode(value)
	end)

	if not success then
		error("InvalidRequest: value cannot be encoded to JSON", 0)
	end

	if #encoded > MAX_VALUE_SIZE then
		error("ItemValueSizeTooLarge", 0)
	end
end

local function enforceExpirationLimits(expiration: number)
	if typeof(expiration) ~= "number" then
		error("InvalidRequest: expiration must be a number", 0)
	end
	if expiration < 0 then
		error("InvalidRequest: expiration must be >= 0", 0)
	end
	if expiration > MAX_EXPIRATION then
		error("InvalidRequest: expiration exceeds maximum", 0)
	end
end

local function getScopedData(self: any)
	local hashMap = self.service.mockData[self.name]
	if not hashMap then
		hashMap = {}
		self.service.mockData[self.name] = hashMap
	end
	return hashMap
end

local function isExpired(entry: any): boolean
	if not entry or not entry.expiration then
		return true
	end
	return getNow() > entry.expiration
end

local function sanitize(value: any): any
	return Tables.copyDeep(value)
end

local MockHashMap = {}

function MockHashMap:GetAsync(key: string): any?
	enforceKeyLimits(key)

	doRateLimitAndQueue(self.service, "GetAsync")

	local scopedData = getScopedData(self)
	local entry = scopedData[key]

	if isExpired(entry) then
		scopedData[key] = nil
		return nil
	end

	return entry.value
end

function MockHashMap:SetAsync(key: string, value: any, expiration: number): boolean
	value = sanitize(value)
	enforceKeyLimits(key)
	enforceValueLimits(value)
	enforceExpirationLimits(expiration)

	doRateLimitAndQueue(self.service, "SetAsync")

	local scopedData = getScopedData(self)
	local serialized = HttpService:JSONEncode(value)
	if serialized == nil then
		return false
	end

	scopedData[key] = {
		value = value,
		expiration = getNow() + expiration * 1000,
	}

	return true
end

function MockHashMap:UpdateAsync(key: string, transformFunction: (any?) -> any?, expiration: number): any?
	enforceKeyLimits(key)
	enforceExpirationLimits(expiration)

	doRateLimitAndQueue(self.service, "UpdateAsync")

	local scopedData = getScopedData(self)
	local retries = 0

	while retries < MAX_UPDATE_RETRIES do
		local entry = scopedData[key]
		local currentValue = nil

		if not isExpired(entry) then
			currentValue = Tables.copyDeep(entry.value)
		end

		local success, newValue = pcall(transformFunction, currentValue)
		if not success then
			error("TransformCallbackFailed", 0)
		end

		if newValue == nil then
			return nil
		end
		newValue = sanitize(newValue)

		enforceValueLimits(newValue)

		if entry and not isExpired(entry) and not Tables.equalsDeep(entry.value, currentValue) then
			retries += 1
			if retries >= MAX_UPDATE_RETRIES then
				error("DataUpdateConflict", 0)
			end
			continue
		end

		scopedData[key] = {
			value = newValue,
			expiration = getNow() + expiration * 1000,
		}

		return newValue
	end

	error("UpdateConflict: Exceeded max number of retries", 0)
end

function MockHashMap:RemoveAsync(key: string)
	enforceKeyLimits(key)

	doRateLimitAndQueue(self.service, "RemoveAsync")

	local scopedData = getScopedData(self)
	scopedData[key] = nil
end

local function createMockHashMap(service: any, name: string): any
	return setmetatable({
		service = service,
		name = name,
	}, { __index = service.mockHashMapMeta })
end

local function new(): MemoryStoreService
	local mockHashMapMeta = table.clone(MockHashMap)
	mockHashMapMeta.__index = mockHashMapMeta

	local tbl = {
		mockData = {},
		hashMaps = {},
		mockHashMapMeta = mockHashMapMeta,
		requestQueues = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
		},
		queuedErrors = {
			GetAsync = {},
			SetAsync = {},
			UpdateAsync = {},
			RemoveAsync = {},
		},

		_globalLatency = nil,
		_latencyByRequestType = {},
		_randomLatencyRange = nil,
		_errorRates = {},
		_simulateThrottling = false,
		_simulateTimeout = false,
		_customBudgets = {},
		_forcedThrottles = {},
	}

	tbl.GetHashMap = function(self, name: string): any
		if not self.hashMaps[name] then
			self.hashMaps[name] = createMockHashMap(self, name)
		end
		return self.hashMaps[name]
	end

	return (tbl :: any) :: MemoryStoreService
end

return {
	new = new,

	mockHashMapMethod = function(service: any, method: string, jest: any)
		local real = service.mockHashMapMeta[method]
		local mock, fn = jest.fn(real)
		service.mockHashMapMeta[method] = fn
		return mock, real
	end,

	setGlobalLatency = function(service: any, seconds: number)
		service._globalLatency = seconds
	end,
	setLatencyForRequestType = function(service: any, requestType: string, seconds: number)
		service._latencyByRequestType[requestType] = seconds
	end,
	setRandomLatency = function(service: any, minSeconds: number, maxSeconds: number)
		service._randomLatencyRange = { min = minSeconds, max = maxSeconds }
	end,
	queueError = function(service: any, requestType: string, errorMessage: string, count: number?)
		for _ = 1, count or 1 do
			table.insert(service.queuedErrors[requestType], errorMessage)
		end
	end,
	setErrorRate = function(service: any, requestType: string, rate: number)
		service._errorRates[requestType] = rate
	end,
	simulateThrottling = function(service: any, enabled: boolean)
		service._simulateThrottling = enabled
	end,
	simulateTimeout = function(service: any, enabled: boolean)
		service._simulateTimeout = enabled
	end,
	setRequestBudget = function(service: any, requestType: string, budget: number)
		service._customBudgets[requestType] = budget
	end,
	forceThrottle = function(service: any, requestType: string, duration: number)
		service._forcedThrottles[requestType] = {
			endTime = os.time() + duration,
		}
	end,

	snapshot = function(service: any)
		return HttpService:JSONEncode({
			mockData = service.mockData,
		})
	end,
	restore = function(service: any, snapshot: string)
		local decoded = HttpService:JSONDecode(snapshot)
		service.mockData = decoded.mockData
	end,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ac</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="282">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PlayerStore</string>
								<string name="ScriptGuid">{0FA7BEF4-0386-4448-9ED8-CC235AFF77E6}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	A PlayerStore wraps a regular Store to provide a more convenient API for working with Player data.
	It automatically converts Players to UserId keys and handles player kicks on data errors.

	```lua
	local playerStore = PlayerStore.create({
		name = "PlayerData",
		template = {
			coins = 0,
			items = {},
		},
		schema = function(data)
			return typeof(data.coins) == "number" and typeof(data.items) == "table",
			"Invalid data format"
		end,
	})

	-- Load data when player joins
	Players.PlayerAdded:Connect(function(player)
		playerStore:loadAsync(player)
	end)

	-- Unload data when player leaves
	Players.PlayerRemoving:Connect(function(player)
		playerStore:unloadAsync(player)
	end)
	```

	@class PlayerStore
]=]

local Players = game:GetService("Players")

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Store = require(script.Parent.Store)
local Types = require(script.Parent.Types)

type PlayerStoreImpl<T> = {
	__index: PlayerStoreImpl<T>,
	_kickPlayer: (self: PlayerStore<T>, keyOrPlayer: string | Player, message: string) -> (),

	get: (self: PlayerStore<T>, player: Player) -> Promise.TPromise<T>,
	load: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	unload: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	update: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> boolean
	) -> Promise.TPromise<boolean>,
	updateImmutable: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> T | false
	) -> Promise.TPromise<boolean>,
	tx: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> boolean
	) -> Promise.TPromise<boolean>,
	txImmutable: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
	) -> Promise.TPromise<boolean>,
	save: (self: PlayerStore<T>, player: Player) -> Promise.Promise,
	close: (self: PlayerStore<T>) -> Promise.Promise,
	peek: (self: PlayerStore<T>, userId: number) -> T,

	getAsync: (self: PlayerStore<T>, player: Player) -> T,
	loadAsync: (self: PlayerStore<T>, player: Player) -> (),
	unloadAsync: (self: PlayerStore<T>, player: Player) -> (),
	updateAsync: (self: PlayerStore<T>, player: Player, transformFunction: (data: T) -> boolean) -> boolean,
	updateImmutableAsync: (
		self: PlayerStore<T>,
		player: Player,
		transformFunction: (data: T) -> T | false
	) -> boolean,
	txAsync: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> boolean
	) -> (),
	txImmutableAsync: (
		self: PlayerStore<T>,
		players: { Player },
		transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
	) -> boolean,
	saveAsync: (self: PlayerStore<T>, player: Player) -> (),
	closeAsync: (self: PlayerStore<T>) -> (),
	peekAsync: (self: PlayerStore<T>, userId: number) -> T,
}

type PlayerStoreProps<T> = {
	_store: Store.Store<T>,
}

--[=[
	Configuration for creating a new Store.

	@interface PlayerStoreConfig
	.name string -- The name of the store
	.template T -- The template data for new keys
	.schema (value: any) -> (boolean, string?) -- A function to validate data
	.migrationSteps { MigrationStep }? -- Optional migration steps
	.importLegacyData ((key: string) -> any?)? -- Optional function to import legacy data
	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () }? -- Optional callbacks for data changes
	.logCallback ((logMessage: LogMessage) -> ())? -- Optional callback for log messages
	.memoryStoreService MemoryStoreService? -- Optional MemoryStoreService instance for mocking
	.dataStoreService DataStoreService? -- Optional DataStoreService instance for mocking

	@within PlayerStore
]=]
type PlayerStoreConfig<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),
	migrationSteps: { Types.MigrationStep }?,
	importLegacyData: ((key: string) -> any?)?,
	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () }?,
	logCallback: ((logMessage: Log.LogMessage) -> ())?,
	memoryStoreService: MemoryStoreService?,
	dataStoreService: DataStoreService?,
}

type PlayerStore<T> = typeof(setmetatable({} :: PlayerStoreProps<T>, {} :: PlayerStoreImpl<T>))

local function getUserIdKey(player: Player): string
	return tostring(player.UserId)
end

local PlayerStore: PlayerStoreImpl<any> = {} :: PlayerStoreImpl<any>
PlayerStore.__index = PlayerStore

--[=[
	Creates a new PlayerStore with the given configuration.
	Configuration is similar to Store.createStore, but automatically adds player kick handling.

	```lua
	local playerStore = PlayerStore.create({
		name = "PlayerData",
		template = { coins = 0 },
		schema = function(data)
			return typeof(data.coins) == "number", "coins must be a number"
		end,

		-- Optional: Runs whenever data changes
		changedCallbacks = {
			function(key, newData, oldData)
				print(key, "changed from", oldData.coins, "to", newData.coins)
			end,
		},
	})
	```

	Players will be automatically kicked with an error message if:
	- Their data fails to load
	- The DataStore lock is lost during their session

	@param config PlayerStoreConfig<T> -- Configuration for the store
	@return PlayerStore<T>
	@within PlayerStore
]=]
local function createPlayerStore<T>(config: PlayerStoreConfig<T>): PlayerStore<T>
	local self: PlayerStore<T>

	local storeConfig: Store.StoreConfig<T> = {
		name = config.name,
		template = config.template,
		schema = config.schema,
		migrationSteps = config.migrationSteps,
		importLegacyData = config.importLegacyData,
		changedCallbacks = config.changedCallbacks,
		logCallback = config.logCallback,
		onLockLost = function(key: string)
			self:_kickPlayer(key, "DataStore lock lost, please rejoin the game.")
		end,
		memoryStoreService = config.memoryStoreService,
		dataStoreService = config.dataStoreService,
	}

	local store = Store.createStore(storeConfig)
	self = setmetatable({ _store = store }, PlayerStore)
	return self
end

--[=[
	Internal helper to kick players when data errors occur.

	@within PlayerStore
	@private
]=]
function PlayerStore:_kickPlayer(keyOrPlayer: string | Player, message: string): ()
	if typeof(keyOrPlayer) ~= "string" then
		keyOrPlayer:Kick(message)
	else
		local player = Players:GetPlayerByUserId(tonumber(keyOrPlayer))
		if player ~= nil then
			player:Kick(message)
		end
	end
end

--[=[
	Gets the current data for the given player.

	```lua
	playerStore:get(player):andThen(function(data)
		print(player.Name, "has", data.coins, "coins")
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@return Promise<T> -- Resolves with the player's data
	@within PlayerStore
]=]
function PlayerStore:get(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:get(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:get(player):expect()`.

	See [PlayerStore:get]
	@yields
]=]
function PlayerStore:getAsync(player: Player)
	return self:get(player):expect()
end

--[=[
	Loads data for the given player. Must be called before using other methods.

	```lua
	playerStore:load(player):andThen(function()
		print("Data loaded for", player.Name)
	end)
	```

	:::caution
	If loading fails, the player will be kicked from the game.
	:::

	@error "Load already in progress" -- Another load is in progress for this player
	@error "Store is closed" -- The store has been closed
	@return Promise -- Resolves when data is loaded
	@within PlayerStore
]=]
function PlayerStore:load(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:load(userIdKey, { player.UserId }):catch(function(e)
		self:_kickPlayer(player, "DataStore load failed, please rejoin the game.")
		return Promise.reject(e)
	end)
end

--[=[
	Syntactic sugar for `playerStore:load(player):expect()`.

	See [PlayerStore:load]
	@yields
]=]
function PlayerStore:loadAsync(player: Player)
	return self:load(player):expect()
end

--[=[
	Unloads data for the given player.

	```lua
	playerStore:unload(player):andThen(function()
		print("Data unloaded for", player.Name)
	end)
	```

	@error "Store is closed" -- The store has been closed
	@return Promise<boolean> -- Resolves when the update is complete, with a boolean indicating success
	@within PlayerStore
]=]
function PlayerStore:unload(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:unload(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:unload(player):expect()`.

	See [PlayerStore:unload]
	@yields
]=]
function PlayerStore:unloadAsync(player: Player)
	return self:unload(player):expect()
end

--[=[
	Updates data for the given player using a transform function.
	The transform function must return true to commit changes, or false to abort.

	```lua
	playerStore:update(player, function(data)
		if data.coins < 100 then
			data.coins += 50
			return true -- Commit changes
		end
		return false -- Don't commit changes
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves when the update is complete
	@within PlayerStore
]=]
function PlayerStore:update<T>(player: Player, transformFunction: (data: T) -> boolean)
	local userIdKey = getUserIdKey(player)
	return self._store:update(userIdKey, transformFunction)
end

--[=[
	Syntactic sugar for `playerStore:update(player, transformFunction):expect()`.

	See [PlayerStore:update]
	@yields
]=]
function PlayerStore:updateAsync<T>(player: Player, transformFunction: (data: T) -> boolean)
	return self:update(player, transformFunction):expect()
end

--[=[
	Updates data for the given player using a transform function that does not mutate the original data.
	The transform function must return the new data or false to abort.

	```lua
	playerStore:updateImmutable(player, function(data)
		if data.coins < 100 then
			return { coins = data.coins + 50 } -- Return new data to commit changes
		end
		return false -- Don't commit changes
	end)
	```

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves when the update is complete
	@within PlayerStore
]=]
function PlayerStore:updateImmutable<T>(
	player: Player,
	transformFunction: (data: T) -> T | false
): Promise.TPromise<boolean>
	local userIdKey = getUserIdKey(player)
	return self._store:updateImmutable(userIdKey, transformFunction)
end

--[=[
	Syntactic sugar for `playerStore:updateImmutable(player, transformFunction):expect()`.

	See [PlayerStore:updateImmutable]
	@yields
]=]
function PlayerStore:updateImmutableAsync<T>(player: Player, transformFunction: (data: T) -> T | false)
	return self:updateImmutable(player, transformFunction):expect()
end

--[=[
	Performs a transaction across multiple players' data atomically.
	All players' data must be loaded first. Either all changes apply or none do.

	```lua
	playerStore:tx({player1, player2}, function(state)
		-- Transfer coins between players
		if state[player1].coins >= 100 then
			state[player1].coins -= 100
			state[player2].coins += 100
			return true -- Commit transaction
		end
		return false -- Abort transaction
	end)
	```

	@error "Key not loaded" -- One or more players' data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@within PlayerStore
]=]
function PlayerStore:tx<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> boolean
): Promise.TPromise<boolean>
	local userIdKeys = table.create(#players)
	local userIdKeyToPlayer = {}
	for i, player in players do
		local key = getUserIdKey(player)
		userIdKeys[i] = key
		userIdKeyToPlayer[key] = player
	end

	local function wrapped(state: { [string]: any }): boolean
		local userIdState = {}
		for key, value in state do
			local player = userIdKeyToPlayer[key]
			userIdState[player] = value
		end

		local success = transformFunction(userIdState)
		if success == false then
			return false
		end

		for key in state do
			state[key] = nil
		end

		for playerVariant, value in userIdState do
			local stringKey = getUserIdKey(playerVariant)
			state[stringKey] = value
		end

		return success
	end

	return self._store:tx(userIdKeys, wrapped)
end

--[=[
	Syntactic sugar for `playerStore:tx(players, transformFunction):expect()`.

	See [PlayerStore:tx]
	@yields
]=]
function PlayerStore:txAsync<T>(players: { Player }, transformFunction: (state: { [Player]: T }) -> boolean)
	return self:tx(players, transformFunction):expect()
end

--[=[
	Performs a transaction across multiple players' data atomically using immutable updates.
	All players' data must be loaded first. Either all changes apply or none do.

	```lua
	playerStore:txImmutable({player1, player2}, function(state)
		-- Transfer coins between players
		if state[player1].coins >= 100 then
			return {
				[player1] = { coins = state[player1].coins - 100 },
				[player2] = { coins = state[player2].coins + 100 },
			} -- Commit transaction with new data
		end
		return false -- Abort transaction
	end)
	```

	@error "Key not loaded" -- One or more players' data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@error "Schema validation failed" -- The transformed data failed schema validation
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@within PlayerStore
]=]
function PlayerStore:txImmutable<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
): Promise.TPromise<boolean>
	local userIdKeys = table.create(#players)
	local userIdKeyToPlayer = {}
	for i, player in players do
		local key = getUserIdKey(player)
		userIdKeys[i] = key
		userIdKeyToPlayer[key] = player
	end

	local function wrapped(state: { [string]: any }): { [string]: any } | false
		local userIdState = {}
		for key, value in state do
			local player = userIdKeyToPlayer[key]
			userIdState[player] = value
		end

		local newData = transformFunction(userIdState)
		if newData == false then
			return false
		end

		for key in state do
			state[key] = nil
		end

		for playerVariant, value in newData :: { [Player]: T } do
			local stringKey = getUserIdKey(playerVariant)
			state[stringKey] = value
		end

		return state
	end

	return self._store:txImmutable(userIdKeys, wrapped)
end

--[=[
	Syntactic sugar for `playerStore:txImmutable(players, transformFunction):expect()`.

	See [PlayerStore:txImmutable]
	@yields
]=]
function PlayerStore:txImmutableAsync<T>(
	players: { Player },
	transformFunction: (state: { [Player]: T }) -> { [Player]: T } | false
)
	return self:txImmutable(players, transformFunction):expect()
end

--[=[
	Forces an immediate save of the given player's data.

	:::info
	Data is automatically saved periodically, so manual saves are usually unnecessary.
	:::

	@error "Key not loaded" -- The player's data hasn't been loaded
	@error "Store is closed" -- The store has been closed
	@return Promise -- Resolves when the save is complete
	@within PlayerStore
]=]
function PlayerStore:save(player: Player)
	local userIdKey = getUserIdKey(player)
	return self._store:save(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:save(player):expect()`.

	See [PlayerStore:save]
	@yields
]=]
function PlayerStore:saveAsync(player: Player)
	return self:save(player):expect()
end

--[=[
	Closes the store and unloads all active sessions.
	The store cannot be used after closing.

	@return Promise -- Resolves when the store is closed
	@within PlayerStore
]=]
function PlayerStore:close()
	return self._store:close()
end

--[=[
	Syntactic sugar for `playerStore:close():expect()`.

	See [PlayerStore:close]
	@yields
]=]
function PlayerStore:closeAsync()
	return self:close():expect()
end

--[=[
	Returns the current data for the given key without loading it into the store.

	```lua
	playerStore:peek(userId):andThen(function(data)
		print("Current coins:", data.coins)
	end)
	```

	@return Promise<T> -- Resolves with the current data
	@within PlayerStore
]=]
function PlayerStore:peek(userId: number)
	local userIdKey = tostring(userId)
	return self._store:peek(userIdKey)
end

--[=[
	Syntactic sugar for `playerStore:peek(userId):expect()`.

	See [PlayerStore:peek]
	@yields
]=]
function PlayerStore:peekAsync(userId: number)
	return self:peek(userId):expect()
end

return {
	createPlayerStore = createPlayerStore,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ad</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="283">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Promise</string>
								<string name="ScriptGuid">{4F71F606-1A72-47F7-812D-C6D6B3710B30}</string>
								<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)

export type Status = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise = {
	andThen: (
		self: Promise,
		successHandler: (...any) -> ...any,
		failureHandler: ((...any) -> ...any)?
	) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> any,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, ...any),
	awaitStatus: (self: Promise) -> (Status, ...any),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> ...any,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (...any) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

export type TPromise<T... = ...any> = {
	andThen: (self: Promise, successHandler: (T...) -> ...any, failureHandler: ((...any) -> ...any)?) -> Promise,
	andThenCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, T...),
	awaitStatus: (self: Promise) -> (Status, T...),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> T...,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <TArgs...>(self: Promise, callback: (TArgs...) -> ...any, TArgs...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (T...) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

type Signal<T...> = {
	Connect: (self: Signal<T...>, callback: (T...) -> ...any) -> SignalConnection,
}

type SignalConnection = {
	Disconnect: (self: SignalConnection) -> ...any,
	[any]: any,
}

export type ErrorKind = "ExecutionError" | "AlreadyCancelled" | "NotResolvedInTime" | "TimedOut"

type Error = {
	is: (anything: any) -> boolean,
	isKind: (anything: any, kind: ErrorKind) -> boolean,
	Kind: {
		ExecutionError: "ExecutionError",
		AlreadyCancelled: "AlreadyCancelled",
		NotResolvedInTime: "NotResolvedInTime",
		TimedOut: "TimedOut",
	},
}

type PromiseModule = {
	Error: Error,
	Status: {
		Started: Status,
		Resolved: Status,
		Rejected: Status,
		Cancelled: Status,
	},

	all: <T>(promises: { TPromise<T> }) -> TPromise<{ T }>,
	allSettled: <T>(promise: { TPromise<T> }) -> TPromise<{ Status }>,
	any: <T>(promise: { TPromise<T> }) -> TPromise<T>,
	defer: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TPromise<TReturn...>,
	delay: (seconds: number) -> TPromise<number>,
	each: <T, TReturn>(
		list: { T | TPromise<T> },
		predicate: (value: T, index: number) -> TReturn | TPromise<TReturn>
	) -> TPromise<{ TReturn }>,
	fold: <T, TReturn>(
		list: { T | TPromise<T> },
		reducer: (accumulator: TReturn, value: T, index: number) -> TReturn | TPromise<TReturn>
	) -> TPromise<TReturn>,
	fromEvent: <TReturn...>(
		event: Signal<TReturn...>,
		predicate: ((TReturn...) -> boolean)?
	) -> TPromise<TReturn...>,
	is: (object: any) -> boolean,
	new: <TReturn...>(
		executor: (
			resolve: (TReturn...) -> (),
			reject: (...any) -> (),
			onCancel: (abortHandler: (() -> ())?) -> boolean
		) -> ()
	) -> TPromise<TReturn...>,
	onUnhandledRejection: (callback: (promise: TPromise<any>, ...any) -> ()) -> () -> (),
	promisify: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn...) -> (TArgs...) -> TPromise<TReturn...>,
	race: <T>(promises: { TPromise<T> }) -> TPromise<T>,
	reject: (...any) -> TPromise<...any>,
	resolve: <TReturn...>(TReturn...) -> TPromise<TReturn...>,
	retry: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TPromise<TReturn...>,
		times: number,
		TArgs...
	) -> TPromise<TReturn...>,
	retryWithDelay: <TArgs..., TReturn...>(
		callback: (TArgs...) -> TPromise<TReturn...>,
		times: number,
		seconds: number,
		TArgs...
	) -> TPromise<TReturn...>,
	some: <T>(promise: { TPromise<T> }, count: number) -> TPromise<{ T }>,
	try: <TArgs..., TReturn...>(callback: (TArgs...) -> TReturn..., TArgs...) -> TPromise<TReturn...>,
}

return (Promise :: any) :: PromiseModule
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ae</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="284">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PromiseQueue</string>
								<string name="ScriptGuid">{FD8C312E-673E-4EDA-8199-683912729DD6}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class PromiseQueue
	@private

	Implements a queue that processes asynchronous operations (represented by functions
	returning Promises or synchronous functions) one at a time, ensuring serial execution.

	**Purpose:** Useful for scenarios where operations on a shared resource must not
	run concurrently to prevent race conditions or ensure logical order. For example,
	processing updates to a specific player's data session.

	**Core Logic:**
	- Operations are added to the queue via the `add` method.
	- Each operation is wrapped in a `Promise`.
	- A single processing loop ([PromiseQueue:_processQueue]) runs as long as the queue is not empty.
	- The loop takes the next item, executes its associated function, and waits for
	  its Promise to resolve or reject before moving to the next item.
	- Includes timeout and deadlock detection for individual items.
	- Supports adding an operation atomically across multiple queues ([PromiseQueue:multiQueueAdd]).
]=]

local Log = require(script.Parent.Log)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)

--[=[
	Internal implementation details and methods for the PromiseQueue class.
	@interface PromiseQueueImpl
	@within PromiseQueue
	@private
	.__index PromiseQueueImpl
	.new (params: CreatePromiseQueueParams) -> PromiseQueue
	._processQueue (self: PromiseQueue) -> ()
	._addResumableBlock (queue: PromiseQueue) -> Promise<() -> ()>
	._getLogContext (self: PromiseQueue, item: QueueItem?) -> { [string]: any }
	.add (self: PromiseQueue, callback: () -> ()) -> Promise
	.multiQueueAdd (queues: { PromiseQueue }, callback: () -> ()) -> Promise -- Public static method
]=]
type PromiseQueueImpl = {
	__index: PromiseQueueImpl,
	new: (params: CreatePromiseQueueParams) -> PromiseQueue,
	_processQueue: (self: PromiseQueue) -> (),
	_addResumableBlock: (queue: PromiseQueue) -> Promise.TPromise<() -> ()>,
	_getLogContext: (self: PromiseQueue, item: QueueItem?) -> { [string]: any },
	multiQueueAdd: (queues: { PromiseQueue }, callback: () -> ()) -> Promise.Promise,
	add: (self: PromiseQueue, callback: () -> ()) -> Promise.Promise,
}

--[=[
	Internal properties stored within a PromiseQueue instance.
	@interface PromiseQueueProps
	@within PromiseQueue
	@private
	._queue { QueueItem } -- The actual queue holding items to be processed.
	._logger Log.Logger -- Logger instance for internal logging.
	._totalItemCount number -- Counter for assigning unique IDs to queue items.
]=]
type PromiseQueueProps = {
	_queue: { QueueItem },
	_logger: Log.Logger,
	_totalItemCount: number,
}

--[=[
	Represents a single item within the queue.
	@interface QueueItem
	@within PromiseQueue
	@private
	.id number -- Unique identifier for the item within this queue instance.
	.fn () -> () -- The function to execute for this item. Can be sync or return a Promise.
	.resolve (value: any) -> () -- The resolve function of the Promise returned by `add`.
	.reject (error: any) -> () -- The reject function of the Promise returned by `add`.
	.trace string -- Debug traceback captured when the item was added.
]=]
type QueueItem = {
	id: number,
	fn: () -> (),
	resolve: (value: any) -> (),
	reject: (error: any) -> (),
	trace: string,
}

export type PromiseQueue = typeof(setmetatable({} :: PromiseQueueProps, {} :: PromiseQueueImpl))

local PromiseQueue = {} :: PromiseQueueImpl
PromiseQueue.__index = PromiseQueue

--[=[
	Parameters for creating a new PromiseQueue instance.
	@interface CreatePromiseQueueParams
	@within PromiseQueue
	.logger Log.Logger
]=]
type CreatePromiseQueueParams = {
	logger: Log.Logger,
}

--[=[
	Creates a new PromiseQueue instance.
	@param params -- Configuration parameters.
	@return PromiseQueue -- A new PromiseQueue object.
	@within PromiseQueue
]=]
function PromiseQueue.new(params: CreatePromiseQueueParams): PromiseQueue
	return setmetatable({
		_queue = {},
		_logger = params.logger,
		_totalItemCount = 0,
	}, PromiseQueue) :: PromiseQueue
end

--[=[
	Adds a new operation (callback function) to the end of the queue.

	The callback will be executed only after all preceding items in the queue
	have completed.

	@param callback () -> T -- The function to execute. This function can be synchronous or return a Promise. Its result or error will resolve/reject the Promise returned by this `add` call.
	@return Promise<T> -- A Promise that resolves or rejects with the result or error of the provided `callback` function once it's processed by the queue.
	@within PromiseQueue
]=]
function PromiseQueue:add(callback: () -> ()): Promise.Promise
	local trace = debug.traceback(nil, 2) -- Capture stack trace for debugging slow/failed items.
	return Promise.new(function(resolve, reject, onCancel)
		self._totalItemCount += 1

		-- Create the queue item record.
		local record = {
			id = self._totalItemCount,
			fn = callback,
			resolve = resolve,
			reject = reject,
			trace = trace,
		}
		table.insert(self._queue, record)

		self._logger:log("trace", "added item to queue", self:_getLogContext())

		-- Handle cancellation: if the returned promise is cancelled before processing,
		-- remove the item from the queue.
		onCancel(function()
			local idx = table.find(self._queue, record)
			if idx then
				table.remove(self._queue, idx)
				self._logger:log("trace", "removed cancelled item from queue", self:_getLogContext(record))
			end
		end)

		-- If this is the first item added to an empty queue, start the processing loop.
		if #self._queue == 1 then
			task.spawn(function()
				self:_processQueue()
			end)
		end
	end)
end

--[=[
	Internal function that processes items from the queue sequentially.
	It runs as long as there are items in the queue.
	@within PromiseQueue
	@private
]=]
function PromiseQueue:_processQueue()
	self._logger:log("trace", "processing queue", self:_getLogContext())
	-- Loop continues as long as items exist in the queue.
	while #self._queue > 0 do
		local item = self._queue[1] -- Get the next item from the front.

		-- Set up a warning timer for potential deadlocks or long-running items.
		-- If an item takes longer than 60 seconds, a warning is logged.
		local deadlockWarn = task.delay(60, function()
			local ctx = self:_getLogContext(item)
			ctx.trace = item.trace -- Include original call stack in warning.
			self._logger:log("warn", "queue item taking > 60s", ctx)
		end)

		self._logger:log("trace", "processing queue item", self:_getLogContext(item))
		-- Execute the item's function within a Promise context.
		Promise
			.try(item.fn)
			:timeout(60) -- Apply a 60-second timeout to the item's execution.
			:andThen(
				item.resolve, -- If successful, resolve the original promise returned by `add`.
				function(e) -- If failed (error or timeout)...
					-- Log the failure details.
					local ctx = self:_getLogContext(item)
					ctx.error = e
					ctx.trace = item.trace

					local msg
					if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
						msg = "queue item timed out"
					else
						msg = "queue item failed"
					end
					self._logger:log("debug", msg, ctx)

					-- Reject the original promise with the error and traceback.
					item.reject(`Queue item failed: {e}\nCreated at:\n{item.trace}`)
				end
			)
			:finally(function()
				-- This runs regardless of success or failure.
				self._logger:log("trace", "finished processing queue item", self:_getLogContext(item))

				-- Remove the item *only if* it's still the first item.
				-- This prevents issues if an item was cancelled and removed while processing.
				if self._queue[1] == item then
					table.remove(self._queue, 1)
				end

				-- Cancel the deadlock warning timer as the item has finished.
				task.cancel(deadlockWarn)
			end)
			:await() -- Wait for the item's promise (including timeout/finally) to complete before the loop continues.
	end
	self._logger:log("trace", "finished processing queue", self:_getLogContext())
end

--[=[
	Internal helper function used by `multiQueueAdd`.
	Adds a special "blocking" item to a single queue. This item's function
	returns a Promise that only resolves when an external `resume` function is called.
	`resume` is just a Promise resolver function - calling it unblocks the queue item.

	@param queue -- The PromiseQueue instance to add the block to.
	@return Promise<() -> ()> -- A Promise that resolves with the `resume` function once the block becomes the active item in the queue.
	@within PromiseQueue
	@private
]=]
local function addResumableBlock(queue: PromiseQueue): Promise.TPromise<() -> ()>
	return Promise.new(function(outerResolve)
		-- Add an item whose function returns a promise...
		queue:add(function()
			return Promise.new(function(resume)
				-- ...that resolves the outer promise (`addResumableBlock`'s promise)
				-- with the `resume` function needed to unblock this item.
				outerResolve(resume :: any)
			end)
		end)
	end)
end
PromiseQueue._addResumableBlock = addResumableBlock -- Assign to the metatable for internal use.

--[=[
	Atomically adds a callback function to be executed across multiple queues.

	Ensures that the callback only runs when it has effectively acquired the "lock"
	(become the currently processing item) on *all* specified queues simultaneously.
	This is useful for operations that need to coordinate across multiple resources
	managed by separate queues.

	**Mechanism:**
	1. Uses `_addResumableBlock` to add a blocking item to each queue.
	2. Waits for all these blocking items to become active (i.e., all `_addResumableBlock`
	   promises resolve, returning their `resume` functions).
	3. Once all queues are blocked, executes the provided `callback`.
	4. After the `callback` finishes (successfully or with an error), calls all the
	   `resume` functions to unblock all the queues.

	@param queues -- A table array of PromiseQueue instances to coordinate.
	@param callback -- The function to execute once all queues are ready.
	@return Promise -- A Promise that resolves/rejects with the result/error of the `callback`.
	@within PromiseQueue
]=]
function PromiseQueue.multiQueueAdd(queues: { PromiseQueue }, callback: () -> ()): Promise.Promise
	local trace = debug.traceback(nil, 2)
	return Promise.new(function(resolve, reject)
		-- Add a resumable block to each queue.
		local promises = Tables.map(queues, addResumableBlock)

		-- Wait for all blocks to be added and become active.
		Promise.all(promises):andThen(function(resumes)
			-- All queues are now blocked at our added item. Execute the callback.
			Promise.try(callback)
				:andThen(resolve, function(e) -- Handle callback success/failure
					reject(`multiQueueAdd callback failed: {e}\nCreated at:\n{trace}`)
				end)
				:finally(function()
					-- Unblock all queues regardless of callback outcome.
					for _, resume in resumes do
						resume()
					end
				end)
		end)
	end)
end

--[=[
	Internal helper to generate a context table for logging.
	@param item -- (Optional) The QueueItem currently being processed.
	@return { [string]: any } -- A table containing common context fields like queue length and item ID.
	@within PromiseQueue
	@private
]=]
function PromiseQueue:_getLogContext(item: QueueItem?): { [string]: any }
	return {
		queueLength = #self._queue,
		totalItems = self._totalItemCount,
		itemId = item and item.id,
	}
end

return PromiseQueue
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004af</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="285">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Session</string>
								<string name="ScriptGuid">{52739354-D539-4E38-9468-4BE5A7377077}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	Manages the in-memory state and persistence lifecycle for a single data key
	within a Store. A Session represents an active, locked instance of a key's
	data, coordinating data loading, saving, updates, transactions, migrations,
	and cleanup.

	Sessions are created internally by [Store:load] after acquiring a distributed
	lock via the Locks module. They handle:
	- Loading initial data by reading the main record, file shards, and pending
	  transactions, applying migrations, or importing legacy data.
	- Providing access to the current data ([Session:get]).
	- Applying mutations ([Session:update]) safely within a `noYield` context and
	  tracking changes.
	- Saving changes back to DataStores ([Session:save], [Session:updateRecord], [Session:writeRecord]),
	  potentially sharding large data via the Files module.
	- Coordinating multi-key transactions ([Store:tx] interacts with Session state).
	- Automatically saving data periodically ([Session:startAutosaving]).
	- Cleaning up orphaned file shards in the background ([Session:orphanFile]).
	- Gracefully unloading data ([Session:unload]), ensuring final saves and lock release.

	A Session is intrinsically tied to a [Locks.LockHandle]. If the lock is lost,
	the Session becomes 'closed' and unusable, triggering cleanup.

	@class Session
	@private
]=]

local HttpService = game:GetService("HttpService")

local Constants = require(script.Parent.Constants)
local Files = require(script.Parent.Files)
local Locks = require(script.Parent.Locks)
local Log = require(script.Parent.Log)
local Migrations = require(script.Parent.Migrations)
local PromiseQueue = require(script.Parent.PromiseQueue)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local t = require(script.Parent.Parent.t)
local Types = require(script.Parent.Types)
local Transactions = require(script.Parent.Transactions)
local dataStoreRetry = require(script.Parent.dataStoreRetry)
local noYield = require(script.Parent.noYield)

--[=[
	Internal type definition for Session methods (used for metatable).

	@interface SessionImpl<T>
	@within Session
	@private
	.__index SessionImpl<T> -- Metatable self-reference.

	-- Static method to load data and create a session
	.load (params: LoadSessionParams<T>) -> Promise<Session<T>>

	-- Internal methods for saving data
	.updateRecord (self: Session<T>) -> Promise<any>
	.orphanFile (self: Session<T>, file: Types.File) -> ()
	.writeRecord (self: Session<T>, txInfo: Types.TxInfo) -> Promise<any>

	-- State checking
	.isSaved (self: Session<T>) -> boolean

	-- Internal state mutation
	.setData (self: Session<T>, data: T) -> ()
	.mutateKey (self: Session<T>, newData: T) -> ()

	-- Autosave management
	.startAutosaving (self: Session<T>) -> ()
	.stopAutosaving (self: Session<T>) -> ()

	-- Public API methods (called via Store)
	.unload (self: Session<T>) -> Promise
	.get (self: Session<T>) -> Promise<T>
	.update (self: Session<T>, transformFunction: (data: T) -> boolean) -> Promise<boolean>
	.save (self: Session<T>) -> Promise
]=]
type SessionImpl<T> = {
	__index: SessionImpl<T>,
	load: (params: LoadSessionParams<T>) -> Promise.TPromise<Session<T>>,
	updateRecord: (self: Session<T>) -> Promise.TPromise<any>,
	orphanFile: (self: Session<T>, file: Types.File) -> (),
	writeRecord: (self: Session<T>, txInfo: Types.TxInfo) -> Promise.TPromise<any>,
	isSaved: (self: Session<T>) -> boolean,
	setData: (self: Session<T>, data: T) -> (),
	mutateKey: (self: Session<T>, newData: T) -> (),
	startAutosaving: (self: Session<T>) -> (),
	stopAutosaving: (self: Session<T>) -> (),
	unload: (self: Session<T>) -> Promise.Promise,
	get: (self: Session<T>) -> Promise.TPromise<T>,
	update: (self: Session<T>, transformFunction: (data: T) -> boolean) -> Promise.TPromise<boolean>,
	updateImmutable: (self: Session<T>, transformFunction: (data: T) -> T | false) -> Promise.TPromise<boolean>,
	save: (self: Session<T>) -> Promise.Promise,
}

--[=[
	Internal state properties of a Session instance.

	@interface SessionProps<T>
	@within Session
	@private
	._cleanupAutosave (() -> ())? -- Function to stop the running autosave loop, if active.

	.key string -- The unique key this session manages.
	.ctx Types.StoreContext<T> -- Shared context from the parent Store.
	.lockHandle Locks.LockHandle -- The active distributed lock handle for this key.

	.userIds { number }? -- User IDs associated with this session (primarily for SetAsync).

	.data T? -- The current, mutable in-memory data.
	.appliedMigrations { string } -- List of migration step names already applied to this data.

	.changeSet { [string]: true } -- Tracks unsaved changes. Keys are unique mutation IDs, value is always true. Cleared on successful save.

	.orphanedFiles { Types.File } -- List of file shards (from previous saves) marked for deletion.
	.currentFile Types.File? -- Reference to the current file structure (potentially sharded) representing the saved state.
	.queue PromiseQueue.PromiseQueue -- PromiseQueue to serialize save/unload/tx operations for this key.
	.txLockPromise Promise? -- A promise used during multi-key transactions (`Store:tx`) to block concurrent `Session:update` calls on this key until the transaction completes.

	.closed boolean -- Flag indicating if the session is closed (e.g., lock lost, unloaded).
	.unloadPromise Promise? -- Promise tracking an ongoing unload operation.

	.keyInfo DataStoreKeyInfo? -- DataStoreKeyInfo obtained during the initial load.

	.logger Log.Logger -- Logger instance specific to this session (includes key).
]=]
type SessionProps<T> = {
	_cleanupAutosave: (() -> ())?,
	key: string,
	ctx: Types.StoreContext<T>,
	lockHandle: Locks.LockHandle,
	userIds: { number }?,
	data: T?,
	appliedMigrations: { string },
	changeSet: { [string]: true },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	queue: PromiseQueue.PromiseQueue,
	txLockPromise: Promise.Promise?,
	closed: boolean,
	unloadPromise: Promise.Promise?,
	keyInfo: DataStoreKeyInfo?,
	logger: Log.Logger,
}

--[=[
	Represents an active, locked session for a specific data key.

	@type Session<T> typeof(setmetatable({} :: SessionProps<T>, {} :: SessionImpl<T>))
	@within Session
]=]
export type Session<T> = typeof(setmetatable({} :: SessionProps<T>, {} :: SessionImpl<T>))

--[=[
	Parameters for the static Session.load method.

	@interface LoadSessionParams<T>
	@within Session
	@private
	.key string
	.storeContext Types.StoreContext<T>
	.userIds { number }?
]=]
type LoadSessionParams<T> = {
	key: string,
	storeContext: Types.StoreContext<T>,
	userIds: { number }?,
}
-- Runtime check for LoadSessionParams.
local loadSessionParamsCheck = t.strictInterface({
	key = t.string,
	storeContext = t.any, -- StoreContext is a complex type, using `any` for simplicity
	userIds = t.optional(t.array(t.number)),
})

--[=[
	Parameters for the internal load helper function.

	@interface LoadParams
	@within Session
	@private
	.storeContext Types.StoreContext<any>
	.key string
]=]
export type LoadParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
}

--[=[
	Result structure for the internal load helper function.

	@interface LoadResult
	@within Session
	@private
	.data any
	.appliedMigrations { string }
	.orphanedFiles { Types.File }
	.currentFile Types.File?
	.keyInfo DataStoreKeyInfo?
]=]
export type LoadResult = {
	data: any,
	appliedMigrations: { string },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	keyInfo: DataStoreKeyInfo?,
}

--[=[
	Internal helper function to perform the multi-stage loading process for a key.
	This runs *after* the lock has been acquired.

	Steps:
	1. Get the main record from `recordStore`.
	2. Extract metadata (applied migrations, orphaned files).
	3. If a file reference exists, read the file data (potentially from shards via `Files.read`).
	4. If file data contains transaction info (`txInfo`), resolve the transaction state via `Transactions.readTx`.
	5. If no data found yet, attempt to import legacy data via `ctx.importLegacyData`.
	6. If still no data, use the `ctx.template` as the base.
	7. Apply any pending migrations via `Migrations.apply`.
	8. Return the final loaded data and metadata.

	@within Session
	@private
	@param params LoadParams -- Parameters for loading.
	@return Promise<LoadResult> -- Promise resolving with the loaded data and metadata.
]=]
local function load(params: LoadParams): Promise.TPromise<LoadResult>
	local ctx = params.storeContext
	local key = params.key

	local logger = ctx.logger:extend({ method = "load", key = params.key })
	logger:log("trace", `loading key`)

	-- Initialize default metadata
	local appliedMigrations: { string } = Migrations.getStepNames(ctx.migrationSteps)
	local orphanedFiles: { Types.File } = {}
	local currentFile: Types.File?
	local keyInfo: DataStoreKeyInfo?

	-- 1. Get the main record
	return dataStoreRetry(function()
			return ctx.recordStore:GetAsync(key)
		end)
		:andThen(function(record: Types.DataStoreRecord?, _keyInfo: DataStoreKeyInfo?)
			-- 2. Extract metadata
			logger:log("trace", "got record")
			if record == nil then
				record = {} :: Types.DataStoreRecord -- Handle case where key doesn't exist yet
			end
			assert(record, "luau") -- Forcefully narrowing type due to old type solver limitations

			keyInfo = _keyInfo
			if record.appliedMigrations then
				appliedMigrations = record.appliedMigrations
			end

			if record.orphanedFiles then
				orphanedFiles = record.orphanedFiles
			end

			-- 3. Read file data if reference exists
			local file = record.file
			if file then
				if Files.isLargeFile(file) then
					currentFile = file -- Store reference if it's sharded
				end

				logger:log("trace", "reading file", { file = HttpService:JSONEncode(file) })
				local readParams: Files.ReadParams = {
					store = ctx.shardStore,
					file = file,
				}
				return Files.read(readParams)
			end

			logger:log("trace", "no file reference in record")
			return nil :: any -- No file means no TxInfo
		end)
		:andThen(function(txInfo: Types.TxInfo?): Promise.TPromise<any?>
			-- 4. Resolve transaction state if TxInfo exists
			if txInfo then
				logger:log("trace", "got txInfo, resolving transaction", { txInfo = txInfo })

				local readTxParams = {
					store = ctx.txStore,
					txInfo = txInfo,
				}
				return Transactions.readTx(readTxParams)
			end

			logger:log("trace", "no txInfo from file")
			return Promise.resolve(nil) -- No TxInfo means no data from file
		end)
		:andThen(function(data: any?)
			-- 5. Attempt legacy import if no data yet
			if data ~= nil then
				logger:log("trace", "got data from file/transaction")
				return data -- Data found, proceed to migrations
			end

			local importLegacyData = ctx.importLegacyData
			if importLegacyData == nil then
				logger:log("trace", "no data, no importLegacyData function provided")
				return nil -- No data, no import function, proceed to template
			end

			-- Try importing
			logger:log("trace", "no data, attempting to import legacy data")
			local importOk, importResult = pcall(importLegacyData, key)
			if not importOk then
				logger:log("error", "failed to import legacy data", { error = importResult })
				return Promise.reject(`Failed to import legacy data for key {key}: {importResult}`)
			end

			local oldData = importResult
			if oldData == nil then
				logger:log("trace", "legacy import returned nil")
				return nil -- Import returned nothing, proceed to template
			else
				-- Data was imported, assume no migrations have been applied to it
				appliedMigrations = {}
				logger:log("trace", "imported legacy data", { oldData = oldData })
				return oldData -- Imported data found, proceed to migrations
			end
		end)
		:andThen(function(data: any?)
			-- 6. Use template if still no data
			if data == nil then
				logger:log("trace", "no data found, using template")
				data = Tables.copyDeep(ctx.template)
			end
			assert(data, "luau") -- Forcefully narrowing type due to old type solver limitations

			-- 7. Apply migrations
			if #ctx.migrationSteps > 0 then
				logger:log("debug", "applying migrations if necessary")
				local migrationParams: Migrations.ApplyParams = {
					logger = logger:extend({ component = "Migrations" }),
					data = data,
					steps = ctx.migrationSteps,
					appliedMigrations = appliedMigrations,
				}

				return Migrations.apply(migrationParams):andThen(function(result: Migrations.ApplyResult)
					-- Update appliedMigrations list based on migration result
					appliedMigrations = result.appliedMigrations
					logger:log(
						"trace",
						"migrations applied",
						{ data = result.data, appliedMigrations = appliedMigrations }
					)
					return result.data -- Return the potentially migrated data
				end)
			end

			-- No migrations to apply or needed
			logger:log("trace", "data loaded (no migrations run)")
			return data
		end)
		:andThen(function(finalData)
			-- 8. Return final result
			logger:log("trace", "load process complete")
			local loadResult: LoadResult = {
				data = finalData,
				appliedMigrations = appliedMigrations,
				orphanedFiles = orphanedFiles,
				currentFile = currentFile,
				keyInfo = keyInfo,
			}
			return loadResult
		end)
end

local Session: SessionImpl<any> = {} :: SessionImpl<any>
Session.__index = Session

--[=[
	Parameters for the internal createSession function.

	@interface CreateSessionParams
	@within Session
	@private
	.storeContext Types.StoreContext<any>
	.key string
	.lockHandle Locks.LockHandle
	.userIds { number }?
	.appliedMigrations { string }
	.orphanedFiles { Types.File }
	.currentFile Types.File?
	.keyInfo DataStoreKeyInfo?
]=]
type CreateSessionParams = {
	storeContext: Types.StoreContext<any>,
	key: string,
	lockHandle: Locks.LockHandle,
	userIds: { number }?,
	appliedMigrations: { string },
	orphanedFiles: { Types.File },
	currentFile: Types.File?,
	keyInfo: DataStoreKeyInfo?,
}

--[=[
	Internal factory function to create a new Session instance.
	Initializes the session state based on loaded data and acquired lock.

	@within Session
	@private
	@param params CreateSessionParams -- Parameters for session creation.
	@return Session<T> -- The newly created session instance.
]=]
local function createSession<T>(params: CreateSessionParams): Session<T>
	local logger = params.storeContext.logger:extend({ key = params.key })

	-- Create a dedicated queue for this session's save/unload/tx operations
	local queue = PromiseQueue.new({
		logger = logger:extend({ component = "PromiseQueue" }),
	})

	local props: SessionProps<T> = {
		key = params.key,
		ctx = params.storeContext,
		lockHandle = params.lockHandle,

		userIds = params.userIds,

		data = nil, -- Initial data set later by mutateKey
		appliedMigrations = params.appliedMigrations,

		changeSet = {}, -- Starts with no unsaved changes

		orphanedFiles = params.orphanedFiles,
		currentFile = params.currentFile,

		queue = queue,
		txLockPromise = nil, -- Not initially locked by a transaction

		closed = false, -- Starts open
		unloadPromise = nil, -- Not initially unloading

		keyInfo = params.keyInfo,
		logger = logger,
		_cleanupAutosave = nil, -- Autosave not started yet
	}

	return setmetatable(props, Session) :: Session<T>
end

--[=[
	Static method to load data and create a Session. This is the main entry point
	called by `Store:load`.

	Steps:
	1. Acquire the distributed lock for the key using `Locks.acquireLock`.
	2. If lock acquired, call the internal `load` helper function.
	3. If load successful and lock still held, create the Session instance using `createSession`.
	4. Set up lock loss handling (`lockHandle.onLockLost`) to close the session.
	5. Initiate background cleanup for any orphaned files found during load.
	6. Set the initial data in the session using `mutateKey`.
	7. Return the created Session.
	8. Ensure the lock is released if loading fails at any stage.

	@within Session
	@param params LoadSessionParams<T> -- Parameters for loading the session.
	@return Promise<Session<T>> -- Resolves with the new Session instance.
	@error "Lock was lost while loading key"
	@error string -- Propagates errors from `Locks.acquireLock` or internal `load`.
]=]
function Session.load<T>(params: LoadSessionParams<T>): Promise.TPromise<Session<T>>
	assert(loadSessionParamsCheck(params))

	local ctx = params.storeContext
	local logger = ctx.logger:extend({ method = "load", key = params.key })

	-- 1. Acquire lock
	local acquireLockParams: Locks.AcquireLockParams = {
		storeContext = ctx,
		key = params.key,
		duration = Constants.LOCK_DURATION_SECONDS,
		refreshInterval = Constants.LOCK_REFRESH_INTERVAL_SECONDS,
	}

	return Locks.acquireLock(acquireLockParams):andThen(function(lockHandle)
		-- Lock acquired, proceed to load data
		local loadParams: LoadParams = {
			storeContext = ctx,
			key = params.key,
		}

		-- 2. Call internal load helper
		return load(loadParams):andThen(function(loadResult: LoadResult)
			-- 3. Check lock still held after potentially long load operation
			if not lockHandle.isLocked() then
				logger:log("error", "lock was lost while loading key")
				-- Lock release handled by the `finally` block below
				return Promise.reject("Lock was lost while loading key")
			end

			-- 4. Create Session instance
			local createParams: CreateSessionParams = {
				storeContext = ctx,
				key = params.key,
				lockHandle = lockHandle,
				userIds = params.userIds,
				appliedMigrations = loadResult.appliedMigrations,
				orphanedFiles = loadResult.orphanedFiles,
				currentFile = loadResult.currentFile,
				keyInfo = loadResult.keyInfo,
			}
			local session = createSession(createParams)

			-- 5. Set up lock loss handler
			lockHandle.onLockLost(function()
				logger:log("warn", "lock was lost, closing session and stopping autosave")
				session.closed = true
				session:stopAutosaving()
				-- Mark unload as immediately resolved if lock is lost
				session.unloadPromise = Promise.resolve()
				-- Trigger Store's onLockLost callback if provided
				if ctx.onLockLost then
					ctx.onLockLost(params.key)
				end
			end)

			-- 6. Initiate orphan cleanup for files found during load
			for _, file in loadResult.orphanedFiles do
				session:orphanFile(file)
			end

			-- 7. Set initial data (triggers changed callbacks if enabled)
			logger:log("trace", "loaded key, setting initial data", { data = loadResult.data })
			session:mutateKey(loadResult.data)

			-- 8. Return the fully initialized session
			return session :: any
		end):finally(function(status): ()
			-- 9. Ensure lock release on failure
			-- This runs if `load(loadParams)` or the subsequent steps reject, or if the load was canceled.
			if status ~= Promise.Status.Resolved then
				logger:log("trace", "failed to load key, releasing lock")
				-- Attempt to release the lock, but don't block or fail further if release fails.
				lockHandle.release():catch(function(e)
					logger:log("warn", "failed to release lock after load failure", { error = e })
				end)
			end
		end)
	end)
end

--[=[
	Internal method to trigger a save operation if there are pending changes.
	This is called by `Session:save` and `Session:unload`.

	@within Session
	@private
	@return Promise -- Resolves when the save is complete (or immediately if no changes).
]=]
function Session:updateRecord(): Promise.TPromise<any>
	local logger = self.logger:extend({ method = "updateRecord" })
	logger:log("trace", "updateRecord called")

	-- Check if there are any unsaved changes
	if self:isSaved() then
		logger:log("trace", "no changes detected, skipping write")
		return Promise.resolve() -- Nothing to save
	end

	-- Prepare the data structure to be saved. TxInfo is the harness even if there's no transaction.
	local txInfo: Types.TxInfo = { committedData = self.data }

	logger:log("trace", "writing record via writeRecord", { txInfo = txInfo })
	-- Delegate the actual writing process to writeRecord
	return self:writeRecord(txInfo)
end

--[=[
	Marks a file (usually an older, sharded file) for deletion and starts a
	background task to remove its shards from the `shardStore`.

	Handles DataStore budget limitations by waiting if the budget is too low.

	@within Session
	@private
	@param file Types.File -- The file metadata (must include `shard` and `count` if sharded).
]=]
function Session:orphanFile(file: Types.File): ()
	-- Only sharded files need cleanup
	if not Files.isLargeFile(file) then
		return
	end
	local logger = self.ctx.logger:extend({ method = "orphanFile", key = self.key, shard = file.shard })

	logger:log("trace", "adding file to orphaned list", { file = file })
	-- Add to list immediately so `writeRecord` includes it if it runs concurrently.
	table.insert(self.orphanedFiles, file)

	-- Start background cleanup task
	task.spawn(function()
		-- Wait for sufficient DataStore budget before proceeding
		-- RemoveAsync uses the SetIncrementAsync budget.
		while true do
			local minBudget = 100 -- Arbitrary minimum budget threshold
			local curBudget =
				self.ctx.dataStoreService:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
			if curBudget < minBudget then
				logger:log("debug", "insufficient budget for orphan cleanup, waiting", {
					curBudget = curBudget,
					minBudget = minBudget,
				})
				task.wait(1) -- Wait and retry
			else
				break -- Budget sufficient
			end
		end

		logger:log("debug", "sufficient budget, processing orphaned file")

		-- Create promises to remove each shard
		local promises = {}
		for i = 1, file.count do
			logger:log("trace", `Queueing removal of shard {i} of {file.count}`)
			table.insert(
				promises,
				dataStoreRetry(function()
					-- Construct shard key and remove it
					return self.ctx.shardStore:RemoveAsync(`{file.shard}-{i}`)
				end)
			)
		end

		-- Wait for all shard removals to complete
		Promise.all(promises)
			:andThen(function()
				logger:log("trace", "successfully removed all shards for orphaned file")
				-- Remove the file from the session's orphaned list now that it's cleaned up.
				for i, otherFile in self.orphanedFiles do
					if Tables.equalsDeep(file, otherFile) then
						table.remove(self.orphanedFiles, i)
						break
					end
				end
			end)
			:catch(function(err)
				-- Log error but don't retry indefinitely. The file remains in orphanedFiles.
				-- Subsequent removals on already removed keys are idempotent.
				logger:log("error", `failed to remove shards for orphaned file: {err}`)
			end)
			:finally(function()
				logger:log("trace", "finished processing orphaned file task")
			end)
	end)
end

--[=[
	Core internal method responsible for writing the current session data to DataStores.

	Steps:
	1. Write the data (as `txInfo`) to potentially multiple shards using `Files.write`.
	2. If sharding fails, mark the failed shards as orphaned and reject.
	3. If file write succeeds, check if the session lock is still held.
	4. If lock lost, mark the newly written file as orphaned and reject.
	5. Prepare the main record (`DataStoreRecord`) containing metadata (migrations,
	   new file reference, list of files now orphaned by this save).
	6. Write the main record to the `recordStore` using SetAsync.
	7. If record write succeeds:
		a. Mark the *previous* `currentFile` (if any) as orphaned using `orphanFile`.
		b. Update `self.currentFile` to the newly written file reference.
		c. Return the written record.
	8. If record write fails, mark the newly written file as orphaned and reject.

	@within Session
	@private
	@param txInfo Types.TxInfo -- The data payload to write (contains `committedData`).
	@return Promise<Types.DataStoreRecord> -- Resolves with the written record on success.
	@error "lock was lost while writing file"
	@error string -- Propagates errors from `Files.write` or `SetAsync`.
]=]
function Session:writeRecord(txInfo: Types.TxInfo): Promise.TPromise<Types.DataStoreRecord>
	local logger = self.logger:extend({ method = "writeRecord" })
	logger:log("trace", "writeRecord called")

	-- 1. Write data to file (potentially sharded)
	local writeParams: Files.WriteParams = {
		store = self.ctx.shardStore,
		data = txInfo,
		maxShardSize = Constants.MAX_CHUNK_SIZE,
		key = self.key,
		userIds = self.userIds,
	}
	logger:log("trace", "calling Files.write", { writeParams = writeParams })

	return Files.write(writeParams)
		:catch(function(err: Files.WriteError)
			-- 2. Handle file write failure
			logger:log("error", "Files.write failed", { error = err.error })
			-- Mark the potentially partially written shards for cleanup
			self:orphanFile(err.file)
			return Promise.reject(err.error)
		end)
		:andThen(function(file: Types.File)
			-- File write successful
			logger:log("trace", "Files.write succeeded", { file = file })

			-- 3. Check lock status *after* potentially long file write
			if not self.lockHandle.isLocked() then
				logger:log("error", "lock was lost while writing file")
				-- Mark the newly created file/shards for cleanup as they are now unreachable
				self:orphanFile(file)
				return Promise.reject("lock was lost while writing file")
			end

			-- 5. Prepare the main record
			-- Clone orphanedFiles list at this point to avoid race conditions with background cleanup.
			local stagedOrphanedFiles = table.clone(self.orphanedFiles)
			-- Add the file that *this* save is replacing to the list of orphans for this record.
			if self.currentFile then
				table.insert(stagedOrphanedFiles, self.currentFile)
			end

			local record: Types.DataStoreRecord = {
				appliedMigrations = self.appliedMigrations,
				file = file, -- Reference to the file structure just written
				orphanedFiles = stagedOrphanedFiles,
			}

			-- 6. Write the main record
			logger:log("trace", "writing main record", { record = record })
			return dataStoreRetry(function()
					return self.ctx.recordStore:SetAsync(self.key, record, self.userIds)
				end)
				:andThen(function()
					-- 7. Record write successful
					logger:log("trace", "main record written successfully")

					-- a. Orphan the previous file now that the record points to the new one
					if self.currentFile then
						self:orphanFile(self.currentFile)
					end
					-- b. Update session state to point to the new file
					self.currentFile = if Files.isLargeFile(file) then file else nil

					-- c. Return the record written
					return record
				end)
				:catch(function(err)
					-- 8. Handle record write failure
					logger:log("error", "failed to write main record", { error = err })
					-- Mark the file/shards created in step 1 for cleanup as the record update failed.
					self:orphanFile(file)
					return Promise.reject(err)
				end)
		end)
end

--[=[
	Checks if the session has any unsaved changes.

	@within Session
	@return boolean -- True if there are no unsaved changes, false otherwise.
]=]
function Session:isSaved(): boolean
	-- The changeSet is empty if and only if `next` returns nil.
	return next(self.changeSet) == nil
end

--[=[
	Internal method to update the session's in-memory data state.
	Marks the session as having unsaved changes and updates the data.

	@within Session
	@private
	@param data any -- The new data value.
]=]
function Session:setData(data: any): ()
	-- Generate a unique ID for this mutation and add it to the changeSet.
	local mutationId = HttpService:GenerateGUID(false)
	self.changeSet[mutationId] = true
	-- Freeze and update the data reference.
	Tables.freezeDeep(data)
	self.data = data
end

--[=[
	Internal method called after data has been changed (either initially loaded or via `update`).
	Updates the session state (`setData`) and triggers any configured `changedCallbacks`.

	@within Session
	@private
	@param newData any -- The new data value.
]=]
function Session:mutateKey(newData: any): ()
	local oldData = self.data -- Store reference to previous data

	-- Update internal data (sets .data and marks changeSet)
	self:setData(newData)

	-- Trigger change callbacks asynchronously
	for _, callback in self.ctx.changedCallbacks do
		task.spawn(callback, self.key, self.data, oldData)
	end
end

--[=[
	Starts the background autosave loop for this session.
	Does nothing if already started or if the session is closed.

	@within Session
]=]
function Session:startAutosaving(): ()
	local logger = self.logger:extend({ method = "startAutosaving" })

	if self._cleanupAutosave then
		logger:log("warn", "autosave already started")
		return
	end
	if self.closed then
		logger:log("warn", "Session is closed, not starting autosave")
		return
	end

	logger:log("trace", "starting autosave loop")
	local stop = false -- Flag to signal loop termination

	-- Spawn the loop in a separate thread
	task.spawn(function()
		while true do
			-- Wait for the configured interval
			-- This is at the top of the loop to ensure the first wait is immediate - we just loaded the session.
			task.wait(Constants.AUTOSAVE_INTERVAL_SECONDS)
			-- Check if stopped or closed during wait
			if self.closed or stop then
				logger:log("trace", "autosave loop stopping", { closed = self.closed, stop = stop })
				break
			end

			-- Attempt to save any pending changes
			logger:log("trace", "autosave triggered")
			local ok, err = self:save():await()
			if not ok then
				-- Log error but continue the loop
				logger:log("warn", "failed to autosave key", { error = err })
			else
				logger:log("trace", "autosave completed successfully")
			end
		end
	end)

	-- Store the cleanup function to stop the loop
	self._cleanupAutosave = function()
		logger:log("trace", "cleanup function called, signaling autosave loop to stop")
		stop = true
		self._cleanupAutosave = nil -- Prevent multiple calls
	end
end

--[=[
	Stops the background autosave loop if it's running.

	@within Session
]=]
function Session:stopAutosaving(): ()
	if self._cleanupAutosave then
		self.logger:log("trace", "stopping autosave loop")
		self._cleanupAutosave()
	else
		self.logger:log("trace", "autosave loop not running or already stopped")
	end
end

--[=[
	Initiates the graceful shutdown process for the session.
	Stops autosaving, queues a final save operation, and releases the lock.

	@within Session
	@return Promise -- Resolves when the unload process is complete.
]=]
function Session:unload(): Promise.Promise
	local logger = self.logger:extend({ method = "unload" })
	logger:log("trace", "unload called")

	-- If unload is already in progress, return the existing promise
	if self.unloadPromise then
		logger:log("trace", "unload already in progress, returning existing promise")
		return self.unloadPromise
	end

	-- Mark session as closed immediately
	self.closed = true
	-- Stop the autosave loop
	self:stopAutosaving()

	logger:log("trace", "queueing final save and lock release")
	-- Add the final operations to the session's queue to ensure serialization
	self.unloadPromise = self
		.queue
		:add(function()
			-- Perform a final save attempt if there are changes
			logger:log("trace", "performing final updateRecord before unloading")
			return self:updateRecord()
		end)
		:andThenReturn(nil) -- Discard result of updateRecord
		:finally(function()
			-- This block runs regardless of whether the final save succeeded or failed
			logger:log("trace", "releasing lock as part of unload")
			-- Attempt to release the lock, logging any errors but not failing unload
			return self.lockHandle.release():catch(function(e)
				logger:log("warn", "failed to release lock during unload", { error = e })
			end)
		end)

	return self.unloadPromise :: any
end

--[=[
	Gets the current data for the session. Value returned is deep frozen to prevent modification.

	@within Session
	@return Promise<T> -- Resolves immediately with the data.
]=]
function Session:get<T>(): Promise.TPromise<T>
	return Promise.resolve(self.data) :: any
end

-- Internal function to encapsulate shared logic for update and updateImmutable.
local function updateInternal(
	self: Session<any>,
	transformFunction: (data: any) -> any | false,
	immutable: boolean,
	logger: Log.Logger
): Promise.TPromise<boolean>
	-- Use Promise.new to handle potential waits for txLockPromise
	return Promise.new(function(resolve, reject)
		-- Wait if a multi-key transaction is currently holding the lock on this session
		while self.txLockPromise ~= nil do
			logger:log("trace", "waiting for txLockPromise to resolve")
			self.txLockPromise:await()
			-- Re-check if closed after waiting, as lock loss could occur during tx
			if self.closed then
				logger:log("warn", "Session closed while waiting for txLockPromise, rejecting update")
				return reject("Session is closed")
			end
		end
		logger:log("trace", `txLockPromise resolved or was nil, proceeding with update`)

		-- Store a reference to our current data - we'll need this later to
		-- check if the data changed at all
		local currentData = self.data

		local nextData
		if immutable then
			-- If immutable is true, we'll pass in `self.data` (which is frozen)
			-- and expect to get a copy-on-write result from `transformFunction`
			nextData = self.data
		else
			-- If immutable is false, we allow the transform to modify the data
			-- directly, so we need a deep copy in case we want to abandon the
			-- changes
			nextData = Tables.copyDeep(self.data)
		end

		-- Execute the transform function safely using `noYield`
		local transformOk, result = pcall(noYield, transformFunction, nextData :: any)
		if not transformOk then
			logger:log("error", "transformFunction errored", { error = result })
			return reject(`transformFunction failed: {result}`)
		end

		-- Check the return value of the transform function
		if immutable == false then
			-- If immutable is false, we expect the transform to return a boolean
			if typeof(result) ~= "boolean" then
				logger:log("error", "transformFunction did not return a boolean")
				return reject("transformFunction must return a boolean")
			end
		else
			-- If immutable is true, we expect the transform to return a new copy of data or false
			if typeof(result) ~= "table" and result ~= false then
				logger:log("error", "transformFunction returned a boolean when it should return data or false")
				return reject("transformFunction must return data or false")
			end
		end

		-- If transform returned false, abort the update
		if result == false then
			logger:log("trace", "transformFunction returned false, update aborted")
			return resolve(false)
		end

		if immutable then
			-- If immutable is true, we expect the transform to return a new
			-- copy of data
			nextData = result :: any
		end

		-- Validate the modified data against the schema
		local schemaOk, err = self.ctx.schema(nextData :: any)
		if not schemaOk then
			logger:log("error", "schema validation failed after transform", { error = err })
			return reject(`Store:update schema validation failed: {err}`)
		end

		-- Ensure the new data is frozen
		Tables.freezeDeep(nextData :: any)

		-- Check if the data actually changed
		if Tables.equalsDeep(nextData :: any, currentData :: any) then
			logger:log("trace", "transform resulted in no data change, resolving true")
			return resolve(true) -- Considered successful, but data remains same
		end

		if immutable == false then
			nextData = Tables.reconcileDeep(currentData :: any, nextData :: any)
		end

		-- Data changed and is valid, apply the mutation
		self:mutateKey(nextData)

		logger:log("trace", "update applied successfully")

		-- Resolve indicating changes were committed
		return resolve(true)
	end)
end

--[=[
	Applies updates to the session's data via a transform function.
	Ensures the transform runs without yielding and validates the result against the schema.
	Allows you to directly mutate the data in-place.

	@within Session
	@param transformFunction (data: T) -> boolean -- Function to modify data. Must return `true` to commit, `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if changes were committed, `false` if aborted by the transform.
	@error "Session is closed"
	@error "transformFunction failed: ..." -- If the transform function errors.
	@error "transformFunction must return a boolean"
	@error "Store:update schema validation failed: ..." -- If the modified data fails schema validation.
]=]
function Session:update<T>(transformFunction: (data: T) -> boolean): Promise.TPromise<boolean>
	assert(t.callback(transformFunction))

	local logger = self.logger:extend({ method = "update" })
	logger:log("trace", "update called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting update")
		return Promise.reject("Session is closed")
	end

	return updateInternal(self, transformFunction, false, logger)
end

--[=[
	Applies updates to the session's data via a transform function.
	Ensures the transform runs without yielding and validates the result against the schema.
	Requires the use of copy-on-write semantics in transformFunction, where
	the data is not directly mutated but instead a new copy is returned.

	@within Session
	@param transformFunction (data: T) -> T | false -- Function to modify data. Must return a new copy of the data with changes to commit changes, or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if changes were committed, `false` if aborted by the transform.
	@error "Session is closed"
	@error "transformFunction failed: ..." -- If the transform function errors.
	@error "transformFunction must return a boolean"
	@error "Store:update schema validation failed: ..." -- If the modified data fails schema validation.
]=]
function Session:updateImmutable<T>(transformFunction: (data: T) -> T | false): Promise.TPromise<boolean>
	assert(t.callback(transformFunction))

	local logger = self.logger:extend({ method = "updateImmutable" })
	logger:log("trace", "updateImmutable called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting update")
		return Promise.reject("Session is closed")
	end

	return updateInternal(self, transformFunction, true, logger)
end

--[=[
	Queues a save operation for the current session state if changes are pending.
	Uses the session's PromiseQueue to serialize saves.

	@within Session
	@return Promise -- Resolves when the save operation completes (or immediately if no changes).
	@error "Session is closed"
]=]
function Session:save(): Promise.Promise
	local logger = self.logger:extend({ method = "save" })
	logger:log("trace", "save called")

	-- Reject if session is closed
	if self.closed then
		logger:log("warn", "Session is closed, rejecting save")
		return Promise.reject("Session is closed")
	end
	-- If no changes, resolve immediately
	if self:isSaved() then
		logger:log("trace", "no changes pending, resolving save immediately")
		return Promise.resolve()
	end

	-- Capture the current changeSet IDs at the time save was called
	local changesToSave = table.clone(self.changeSet)

	logger:log("trace", "queueing save operation")
	-- Add the save logic to the session's queue
	return self.queue:add(function()
		logger:log("trace", "save task running from queue")

		-- Check if the changes captured earlier (`changesToSave`) have already
		-- been saved by a *different* save task that ran before this one.
		local changesWereAlreadySaved = true
		for id in self.changeSet do -- Check the *current* changeSet
			if changesToSave[id] then -- Is an ID from *our* captured set still present?
				changesWereAlreadySaved = false -- At least one change is still pending, we need to save
				break
			end
		end

		if changesWereAlreadySaved then
			logger:log("trace", "changes were already saved by another task, skipping redundant save")
			return Promise.resolve() -- No need to save again
		end

		-- Capture the *current* changeSet again, as more changes might have occurred
		-- while this task was waiting in the queue.
		local currentChanges = table.clone(self.changeSet)

		logger:log("trace", "saving current changes", { changes = currentChanges })
		-- Perform the actual save via updateRecord
		return self:updateRecord():andThen(function()
			-- Save successful, remove the saved change IDs from the session's changeSet
			for id in currentChanges do
				self.changeSet[id] = nil
			end
			logger:log("trace", "changes saved successfully, updated changeSet", { latestChangeSet = self.changeSet })
		end)
		-- Errors from updateRecord will propagate through the queue's promise
	end)
end

return Session
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="286">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Store</string>
								<string name="ScriptGuid">{CAF341C6-B59C-4550-A8BC-D414764FB0FC}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Store
	@private

	Coordinates Sessions and provides a safe, high-level API for interacting with
	persistent data stored in Roblox DataStores and MemoryStores.

	**Core Responsibilities:**
	- Manages the lifecycle of `Session` objects for individual data keys (e.g., player IDs).
	- Provides methods for loading, reading (`get`), updating (`update`), and saving data.
	- Implements atomic multi-key transactions (`tx`).
	- Handles data validation, migrations, and optional legacy data import.
	- Abstracts away underlying complexities like data sharding (`Files`), distributed
	  locking (`Locks`), and transaction coordination (`Transactions`).
	- Integrates with a configurable logging system (`Log`).

	**Usage Example:**
	```lua
	local store = Store.createStore({
		name = "PlayerData",
		template = {
			coins = 0,
			items = {},
		},
		schema = function(data)
			return typeof(data.coins) == "number" and typeof(data.items) == "table",
			"Invalid data format"
		end,
		-- ... other config options
	})

	-- Load data for a player
	store:load("player_1"):andThen(function()
		-- Get current data
		return store:get("player_1")
	end):andThen(function(data)
		print(data.coins) -- 0

		-- Update data
		return store:update("player_1", function(data)
			data.coins += 100
			return true -- Must return true to commit changes
		end)
	end)
	```
]=]

local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local MemoryStoreService = game:GetService("MemoryStoreService")
local RunService = game:GetService("RunService")

local Constants = require(script.Parent.Constants)
local Files = require(script.Parent.Files)
local JsonPatch = require(script.Parent.JsonPatch)
local Locks = require(script.Parent.Locks)
local Session = require(script.Parent.Session)
local Log = require(script.Parent.Log)
local MockDataStoreService = require(script.Parent.MockDataStoreService)
local MockMemoryStoreService = require(script.Parent.MockMemoryStoreService)
local PromiseQueue = require(script.Parent.PromiseQueue)
local Transactions = require(script.Parent.Transactions)
local Promise = require(script.Parent.Promise)
local Tables = require(script.Parent.Tables)
local Types = require(script.Parent.Types)
local dataStoreRetry = require(script.Parent.dataStoreRetry)
local noYield = require(script.Parent.noYield)
local t = require(script.Parent.Parent.t)

--[=[
	Configuration options for creating a new Store instance using `createStore`.

	@interface StoreConfig
	@within Store
	.name string -- A unique name for this store (e.g., "PlayerDataProd"). Used for logging and deriving DataStore/MemoryStore keys.

	.template T -- A deep copyable Luau table/value representing the default state for a new key.

	.schema (value: any) -> (boolean, string?) -- A validation function (e.g., created with `t`) that checks if data conforms to the expected structure. Returns `true` if valid, or `false` and an error message if invalid.

	.migrationSteps {Types.MigrationStep}? -- An optional ordered list of migration steps to apply to data loaded from the DataStore if its schema is older than the current version. See `Migrations.luau`.

	.importLegacyData ((key: string) -> any?)? -- An optional function to load data from a different, legacy storage system when a key is accessed for the first time and doesn't exist in this store.

	.dataStoreService DataStoreService? -- An optional override for the Roblox DataStoreService. Useful for testing or custom storage implementations. Defaults to `game:GetService("DataStoreService")`.

	.memoryStoreService MemoryStoreService? -- An optional override for the Roblox MemoryStoreService. Useful for testing. Defaults to `game:GetService("MemoryStoreService")`.

	.useMock boolean? -- If true (and running in Studio), uses mock in-memory implementations of DataStoreService and MemoryStoreService instead of the actual Roblox services. Useful for testing in a controlled environment. Defaults to `false`.

	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () }? -- An optional list of functions called *after* data for a key has been successfully updated. Provides the key, the new data state, and the previous data state (if available).

	.logCallback ((logMessage: Log.LogMessage) -> ())? -- A function to receive log messages generated by this Store instance and its components. If omitted, logs are discarded. See [Log].

	.onLockLost ((key: string) -> ())? -- An optional callback function triggered if the distributed lock for a key's session is lost unexpectedly (e.g., due to expiration or external interference). This usually indicates the session is no longer safe to use.
]=]
export type StoreConfig<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),
	migrationSteps: { Types.MigrationStep }?,
	importLegacyData: ((key: string) -> any?)?,
	dataStoreService: DataStoreService?,
	memoryStoreService: MemoryStoreService?,
	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () }?,
	logCallback: ((logMessage: Log.LogMessage) -> ())?,
	onLockLost: ((key: string) -> ())?,
	useMock: boolean?,
}
local storeConfigCheck = t.strictInterface({
	name = t.string,
	template = t.any,
	schema = t.callback,
	migrationSteps = t.optional(t.array(t.strictInterface({
		name = t.string,
		apply = t.callback,
	}))),
	importLegacyData = t.optional(t.callback),
	dataStoreService = t.optional(t.any),
	memoryStoreService = t.optional(t.any),
	changedCallbacks = t.optional(t.array(t.callback)),
	logCallback = t.optional(t.callback),
	onLockLost = t.optional(t.callback),
	useMock = t.optional(t.boolean),
})

-- Parameters for the listVersions method. Mirrors DataStore:ListVersionsAsync parameters.
type ListVersionParams = {
	key: string,
	sortDirection: Enum.SortDirection?,
	minDate: number?,
	maxDate: number?,
	pageSize: number?,
}

type StoreImpl<T> = {
	__index: StoreImpl<T>,

	-- Internal helper methods
	_withSession: (self: Store<T>, key: string, callback: (session: Session.Session<any>) -> ()) -> Promise.Promise,
	_getKeyInfo: (self: Store<T>, key: string) -> Promise.TPromise<DataStoreKeyInfo?>,

	-- Core public API (Promise-based)
	load: (self: Store<T>, key: string, userIds: { number }?) -> Promise.Promise,
	unload: (self: Store<T>, key: string) -> Promise.Promise,
	get: (self: Store<T>, key: string) -> Promise.TPromise<T>,
	update: (self: Store<T>, key: string, transformFunction: (data: T) -> boolean) -> Promise.TPromise<boolean>,
	updateImmutable: (
		self: Store<T>,
		key: string,
		transformFunction: (data: T) -> T | false
	) -> Promise.TPromise<boolean>,
	tx: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> boolean
	) -> Promise.TPromise<boolean>,
	txImmutable: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> { [string]: T } | false
	) -> Promise.TPromise<boolean>,
	save: (self: Store<T>, key: string) -> Promise.Promise,
	close: (self: Store<T>) -> Promise.Promise,

	-- Utility/Inspection API (Promise-based)
	peek: (self: Store<T>, key: string) -> Promise.TPromise<T?>,
	probeLockActive: (self: Store<T>, key: string) -> Promise.TPromise<boolean>,
	listVersions: (self: Store<T>, params: ListVersionParams) -> Promise.TPromise<DataStoreVersionPages>,
	readVersion: (self: Store<T>, key: string, version: string) -> Promise.TPromise<T, DataStoreKeyInfo>,

	-- Core public API (Async/Await syntactic sugar)
	loadAsync: (self: Store<T>, key: string, userIds: { number }?) -> (),
	unloadAsync: (self: Store<T>, key: string) -> (),
	getAsync: (self: Store<T>, key: string) -> T,
	updateAsync: (self: Store<T>, key: string, transformFunction: (data: T) -> boolean) -> boolean,
	updateImmutableAsync: (self: Store<T>, key: string, transformFunction: (data: T) -> T | false) -> boolean,
	txAsync: (self: Store<T>, keys: { string }, transformFunction: (state: { [string]: T }) -> boolean) -> (),
	txImmutableAsync: (
		self: Store<T>,
		keys: { string },
		transformFunction: (state: { [string]: T }) -> T | false
	) -> boolean,
	saveAsync: (self: Store<T>, key: string) -> (),
	closeAsync: (self: Store<T>) -> (),

	-- Utility/Inspection API (Async/Await syntactic sugar)
	peekAsync: (self: Store<T>, key: string) -> T?,
	probeLockActiveAsync: (self: Store<T>, key: string) -> boolean,
	listVersionsAsync: (self: Store<T>, params: ListVersionParams) -> DataStoreVersionPages,
	readVersionAsync: (self: Store<T>, key: string, version: string) -> (T, DataStoreKeyInfo),
}

type StoreProps<T> = {
	_ctx: Types.StoreContext<T>, -- Shared context containing config and dependencies.
	_closed: boolean, -- Flag indicating if the store has been closed.
	_sessions: { [string]: Session.Session<T> }, -- Map of active sessions, keyed by data key.
	_loadPromises: { [string]: Promise.Promise }, -- Tracks ongoing load operations to prevent duplicates.
	_unloadPromises: { [string]: Promise.Promise }, -- Tracks ongoing unload operations.
}

export type Store<T> = typeof(setmetatable({} :: StoreProps<T>, {} :: StoreImpl<T>))

local Store: StoreImpl<any> = {} :: StoreImpl<any>
Store.__index = Store

--[=[
	Factory function to create a new Store instance.

	Initializes the store context, sets up DataStore and MemoryStore connections
	(real or mock), validates the template schema, and returns the configured Store object.

	@within Store
	@param config StoreConfig<T> -- Configuration options for the store.
	@return Store<T> -- A new, initialized Store instance.
]=]
local function createStore<T>(config: StoreConfig<T>): Store<T>
	assert(storeConfigCheck(config))

	local logger = Log.createLogger(config.logCallback or function() end, {
		lib = "lyra",
		store = config.name,
	})

	logger:log("debug", `creating store`)

	-- Determine which DataStoreService implementation to use (real, mock, or custom).
	local dataStoreService = config.dataStoreService
	if dataStoreService == nil then
		if config.useMock then
			assert(RunService:IsStudio(), "useMock can only be true in Studio")
			logger:log("info", `using mock DataStoreService`)
			dataStoreService = (MockDataStoreService.new() :: any) :: DataStoreService
		else
			logger:log("trace", `using real DataStoreService`)
			dataStoreService = DataStoreService
		end
	end
	assert(dataStoreService, "luau") -- Forcefully narrowing type due to old type solver limitations

	-- Determine which MemoryStoreService implementation to use (real, mock, or custom).
	local memoryStoreService = config.memoryStoreService
	if memoryStoreService == nil then
		if config.useMock then
			assert(RunService:IsStudio(), "useMock can only be true in Studio")
			logger:log("info", `using mock MemoryStoreService`)
			memoryStoreService = (MockMemoryStoreService.new() :: any) :: MemoryStoreService
		else
			logger:log("trace", `using real MemoryStoreService`)
			memoryStoreService = MemoryStoreService
		end
	end
	assert(memoryStoreService, "luau") -- Forcefully narrowing type due to old type solver limitations

	local migrationSteps = config.migrationSteps or {}

	-- Assemble the StoreContext object, which bundles all dependencies and config.
	local storeContext: Types.StoreContext<T> = {
		name = config.name,
		template = config.template,
		schema = config.schema,

		migrationSteps = migrationSteps,
		importLegacyData = config.importLegacyData,

		dataStoreService = dataStoreService,
		memoryStoreService = memoryStoreService,

		changedCallbacks = config.changedCallbacks or {},
		logger = logger,
		onLockLost = config.onLockLost,

		-- Get specific DataStore/MemoryStore instances using derived names/scopes.
		recordStore = dataStoreService:GetDataStore(`{Constants.RECORD_SCOPE}/{config.name}`),
		shardStore = dataStoreService:GetDataStore(`{Constants.SHARD_SCOPE}/{config.name}`),
		txStore = dataStoreService:GetDataStore(`{Constants.TX_SCOPE}/{config.name}`),
		lockHashMap = memoryStoreService:GetHashMap(`{Constants.LOCK_SCOPE}/{config.name}`),
	}

	-- Validate that the provided template data conforms to the schema.
	local ok, err = storeContext.schema(storeContext.template)
	if not ok then
		error(`Failed to validate template for store '{config.name}': {err}`)
	end

	local self = setmetatable({
		_ctx = storeContext,
		_closed = false,
		_sessions = {},
		_loadPromises = {},
		_unloadPromises = {},
	}, Store)

	logger:log("trace", `created store`)
	return self
end

--[[
	Handling Concurrent Load and Unload Requests:

	The `load` and `unload` methods manage the state of data associated with a
	specific key (like a player ID). Because these operations can be called
	close together or even overlap for the same key, the Store implements
	specific rules to ensure data consistency and prevent conflicts:

	- **Loading a Key:**
	    - If you try to `load` a key that's *already loading*, the second `load`
	      request is rejected ("Load already in progress"). You should only
	      initiate one load at a time per key, as concurrent loads often
	      indicate a logic issue.
	    - If you try to `load` a key that's *currently unloading*, the `load`
	      request will patiently wait until the unload process is completely
	      finished before it starts acquiring the lock and loading the data.
	    - If you try to `load` a key that's *already loaded* and ready (and not
	      unloading), the request completes instantly without doing anything.

	- **Unloading a Key:**
	    - If you try to `unload` a key that's *currently loading*, the `unload`
	      request takes priority. It immediately cancels the ongoing load
	      operation (preventing the session from being fully created) and
	      finishes quickly. This avoids creating a session only to tear it down
	      immediately.
	    - If you try to `unload` a key that's *already unloading*, the second
	      `unload` request simply waits for the first one to finish.
	    - If you try to `unload` a key that's *already unloaded* (or was never
	      loaded), the request completes instantly without doing anything.

	These rules, managed internally using promise tracking (`_loadPromises`,
	`_unloadPromises`), guarantee that operations happen in a safe, predictable
	order. They prevent race conditions like those introduced by players joining
	and leaving quickly.
]]

--[=[
	Acquires a distributed lock, loads data for the given key into memory, 
	and establishes a `Session` object to manage the key's state.

	This must be called before performing operations like `get`, `update`, or `save`
	on the key. It handles concurrent load attempts and waits for any ongoing unload
	operations to complete first.

	Propagates errors from `Session.load` (e.g., lock acquisition failure, DataStore errors).
	
	@within Store
	@param key string -- The unique identifier for the data to load (e.g., "player_123").
	@param userIds {number}? -- Optional list of UserIDs for DataStore key tagging.
	@return Promise -- Resolves when the data is successfully loaded and the session is ready, or rejects on error.
	@error "Load already in progress" -- If `load` is called again for the same key while a previous load is still running.
	@error "Store is closed" -- If the store instance has been closed via `close()`.
]=]
function Store:load(key: string, userIds: { number }?): Promise.Promise
	assert(t.string(key))
	assert(t.optional(t.array(t.number))(userIds))

	local logger = self._ctx.logger:extend({ method = "load", key = key })
	logger:log("trace", "attempting to load key")

	-- Prevent operations if the store is closed.
	if self._closed then
		logger:log("warn", "attempted to load key while store is closed")
		return Promise.reject("Store is closed")
	end

	-- If a session exists and isn't currently unloading, it's already loaded.
	if self._sessions[key] and not self._unloadPromises[key] then
		logger:log("trace", "key is already loaded")
		return Promise.resolve()
	end

	-- Prevent concurrent load attempts for the same key.
	if self._loadPromises[key] then
		logger:log("trace", "key is currently being loaded")
		-- We reject instead of returning the existing promise because load
		-- being called more than once on the same key indicates a code smell or bug.
		return Promise.reject("Load already in progress")
	end

	-- If an unload is in progress, wait for it to finish before starting the load.
	local waitForUnload = Promise.try(function()
		local unloadPromise = self._unloadPromises[key]
		if unloadPromise then
			logger:log("trace", "waiting for unload to complete")
			unloadPromise:await()
		end
	end)

	local sessionLoadParams = {
		storeContext = self._ctx,
		key = key,
		userIds = userIds,
	}
	-- Chain the actual session loading after the potential unload wait.
	local loadPromise = waitForUnload:andThenCall(Session.load, sessionLoadParams):andThen(function(session)
		-- Check if the store was closed *while* this load was in progress.
		if self._closed then
			logger:log("warn", "store closed before key loaded, unloading immediately")
			-- If closed, immediately start unloading the session that was just loaded.
			self._unloadPromises[key] = session:unload():finally(function()
				logger:log("trace", "key unloaded after store closed during load")
				self._unloadPromises[key] = nil
			end)
			return Promise.reject("Store closed before key loaded")
		end

		-- Session was loaded successfully; let's store it, start autosaving,
		-- and set up lock loss handling.

		self._sessions[key] = session

		session:startAutosaving()

		session.lockHandle.onLockLost(function()
			logger:log("warn", "lock lost for key, removing session")
			if self._ctx.onLockLost then
				-- Use pcall as user callback could error.
				pcall(self._ctx.onLockLost, key)
			end
			-- Remove the session as it's no longer valid without the lock.
			self._sessions[key] = nil
		end)
		logger:log("debug", "key loaded successfully")
	end)

	-- Store the load promise to handle concurrent calls.
	self._loadPromises[key] = loadPromise

	-- Ensure the load promise is removed from the tracking table once settled,
	-- and suppress unhandled rejection warnings if the caller doesn't attach a .catch.
	loadPromise
		:finally(function()
			-- Remove the promise regardless of outcome.
			self._loadPromises[key] = nil
		end)
		:catch(function()
			-- Mark original rejection as handled to prevent "Unhandled Promise
			-- Rejection" spam if user doesn't catch. Note that this is a new
			-- promise chain - the original rejection is still propagated to the
			-- caller.
		end)

	-- Final check for cancellation after the main load logic.
	return loadPromise:finally(function(status)
		if status == (Promise :: any).Status.Cancelled then
			logger:log("trace", "load was cancelled")
			return Promise.reject("Load was cancelled")
		end
	end)
end

--[=[
	Synchronous wrapper for [Store:load]. Waits for the Promise to settle.
	Throws an error if the load fails or is cancelled.
	
	@within Store
	@param key string -- The unique identifier for the data to load.
	@param userIds {number}? -- Optional list of UserIDs for DataStore key tagging.
	@error any -- Throws any error encountered during the load process.
	@yields
]=]
function Store:loadAsync(key: string, userIds: { number }?): ()
	self:load(key, userIds):expect()
end

--[=[
	Unloads data for the given key from memory, saves any pending changes,
	releases the distributed lock, and ends the session.

	Propagates errors from `Session:unload` (e.g., save failures).
	
	@within Store
	@param key string -- The unique identifier for the data to unload.
	@return Promise -- Resolves when the data is successfully unloaded, or rejects on error.
	@error "Store is closed" -- If the store instance has been closed.
]=]
function Store:unload(key: string): Promise.Promise
	assert(t.string(key))

	local logger = self._ctx.logger:extend({ method = "unload", key = key })
	logger:log("trace", "attempting to unload key")

	-- Prevent operations if the store is closed.
	if self._closed then
		logger:log("warn", "attempted to unload key while store is closed")
		return Promise.reject("Store is closed")
	end

	-- If a load is in progress, cancel it instead of unloading.
	if self._loadPromises[key] then
		logger:log("trace", "key is being loaded, cancelling load instead of unloading")
		self._loadPromises[key]:cancel()
		-- Resolve immediately as the load cancellation handles cleanup.
		return Promise.resolve()
	end

	-- If an unload is already in progress, return the existing promise.
	if self._unloadPromises[key] then
		logger:log("trace", "key is already being unloaded")
		return self._unloadPromises[key]
	end

	-- If there's no active session, there's nothing to unload.
	local session = self._sessions[key]
	if not session then
		logger:log("warn", "key not loaded, nothing to unload")
		return Promise.resolve()
	end

	logger:log("trace", "unloading key")
	-- Store the unload promise to handle concurrent calls.
	self._unloadPromises[key] = session:unload():finally(function()
		-- Clean up regardless of unload success or failure.
		logger:log("trace", "key unload finished, cleaning up state")
		self._sessions[key] = nil
		self._unloadPromises[key] = nil
	end)

	return self._unloadPromises[key] or Promise.resolve()
end

--[=[
	Synchronous wrapper for [Store:unload]. Waits for the Promise to settle.
	Throws an error if the unload fails.
	
	@within Store
	@param key string -- The unique identifier for the data to unload.
	@error any -- Throws any error encountered during the unload process.
	@yields
]=]
function Store:unloadAsync(key: string): ()
	self:unload(key):expect()
end

--[=[
	Internal helper function to safely access the session for a given key.
	Handles waiting for load/unload operations and checks store/session state.

	@within Store
	@private
	@param key string -- The key whose session is needed.
	@param callback (session: Session.Session<any>) -> any -- The function to execute with the session object.
	@return Promise -- Resolves with the return value of the callback, or rejects if the session cannot be accessed (e.g., not loaded, store closed, load cancelled).
]=]
function Store:_withSession(key: string, callback: (session: Session.Session<any>) -> any): Promise.Promise
	local logger = self._ctx.logger:extend({ method = "_withSession", key = key })

	return Promise.new(function(resolve, reject)
		-- Check if store is closed first.
		if self._closed then
			logger:log("warn", "attempted to use key while store is closed")
			return reject("Store is closed")
		end

		-- If a load is in progress, wait for it.
		local loadPromise = self._loadPromises[key]
		if loadPromise then
			logger:log("trace", "key being loaded, waiting for load promise")
			local resolved, err = loadPromise:await()
			if not resolved then
				if loadPromise:getStatus() == Promise.Status.Cancelled then
					logger:log("trace", "load was cancelled while waiting")
					return reject("Load was cancelled")
				else
					logger:log("warn", "load failed while waiting")
					return reject(err)
				end
			end
			-- Load completed successfully while waiting.
		end

		-- Check if an unload is in progress.
		if self._unloadPromises[key] then
			logger:log("warn", "key is being unloaded")
		end

		-- Get the session; it should exist now if load succeeded or was already loaded.
		local session = self._sessions[key]
		if not session then
			logger:log("warn", "key not loaded")
			return reject("Key not loaded")
		end

		-- Session exists and is ready, execute the callback.
		-- Use Promise.try to handle potential errors within the callback itself.
		resolve(Promise.try(callback, session))
	end)
end

--[=[
	Internal helper to get the DataStoreKeyInfo for a loaded key's session.

	@within Store
	@private
	@param key string -- The key whose info is needed.
	@return Promise<DataStoreKeyInfo?> -- Resolves with the key info object, or nil if the session doesn't have key info (shouldn't normally happen for loaded sessions). Rejects if the session cannot be accessed.
]=]
function Store:_getKeyInfo(key: string): Promise.TPromise<DataStoreKeyInfo?>
	return self:_withSession(key, function(session)
		-- Access the keyInfo property stored on the session object after load.
		return session.keyInfo
	end)
end

--[=[
	Gets the current, in-memory data state for the given key.
	Requires the key to be loaded first via `load()`.
	If the key is still loading, this will wait for it to finish.

	@within Store
	@param key string -- The key whose data to retrieve.
	@return Promise<T> -- Resolves with the current data object (potentially a deep copy).
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store has been closed.
]=]
function Store:get<T>(key: string): Promise.TPromise<T>
	assert(t.string(key))

	return self:_withSession(key, function(session)
		return session:get()
	end)
end

--[=[
	Synchronous wrapper for [Store:get]. Waits for the Promise to settle.
	Throws an error if getting the data fails.
	
	@within Store
	@param key string -- The key whose data to retrieve.
	@return T -- The current data object.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store has been closed.
	@yields
]=]
function Store:getAsync<T>(key: string): T
	return self:get(key):expect()
end

--[=[
	Applies changes to the data for a given key using a transform function.

	The `transformFunction` receives the current data and can modify it directly.
	It **must** return `true` to indicate that changes were made and should be
	saved, or `false` to abort the update without saving.

	Changes are applied optimistically to the in-memory state first and then queued
	for saving to the DataStore.

	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> boolean -- A function that receives the current data and returns `true` to commit changes or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if the transform function returned `true` and the update was successfully queued, or `false` if the transform function returned `false`. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
]=]
function Store:update<T>(key: string, transformFunction: (data: T) -> boolean): Promise.TPromise<boolean>
	assert(t.string(key))
	assert(t.callback(transformFunction))

	-- Use _withSession to safely access the session and call its update method.
	return self:_withSession(key, function(session)
		return session:update(transformFunction)
	end)
end

--[=[
	Synchronous wrapper for [Store:update]. Waits for the Promise to settle.
	Throws an error if the update fails.
	
	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> boolean -- The transformation function.
	@return boolean -- Returns the boolean value returned by the `transformFunction`.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
	@yields
]=]
function Store:updateAsync<T>(key: string, transformFunction: (data: T) -> boolean): boolean
	return self:update(key, transformFunction):expect()
end

--[=[
	Applies changes to the data for a given key using a transform function,
	with immutable copy-on-write semantics.

	The `transformFunction` receives the current data but frozen (immutable),
	and cannot modify it directly. Instead, it should return new data that
	reflects the desired changes. Otherwise it should return `false` to abort
	the update without saving.

	Changes are applied optimistically to the in-memory state first and then queued
	for saving to the DataStore.

	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> T | false -- A function that receives the current data and returns a new copy of the data with changes to commit changes, or `false` to abort.
	@return Promise<boolean> -- Resolves with `true` if the transform function committed and the update was successfully queued, or `false` if the transform function returned `false`. Rejects on errors like key not loaded, store closed, or schema validation failure after transformation.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
]=]
function Store:updateImmutable<T>(key: string, transformFunction: (data: T) -> T | false): Promise.TPromise<boolean>
	assert(t.string(key))
	assert(t.callback(transformFunction))

	-- Use _withSession to safely access the session and call its updateImmutable method.
	return self:_withSession(key, function(session)
		return session:updateImmutable(transformFunction)
	end)
end

--[=[
	Synchronous wrapper for [Store:updateImmutable]. Waits for the Promise to settle.
	Throws an error if the update fails.
	
	@within Store
	@param key string -- The key whose data to update.
	@param transformFunction (data: T) -> T | false -- The transformation function.
	@return boolean -- Returns `true` if the update was successful, or `false` if the transform function returned `false`.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data returned by `transformFunction` does not pass the store's schema check.
	@yields
]=]
function Store:updateImmutableAsync<T>(key: string, transformFunction: (data: T) -> T | false): boolean
	return self:updateImmutable(key, transformFunction):expect()
end

--[=[
	Internal helper to perform transaction logic on multiple keys.
	Handles acquiring locks, validating state, and committing changes atomically
	via a two-phase commit process.
	
	Supports both immutable and mutable transactions, where `immutable` controls
	whether the data passed to the `transformFunction` is a deep copy (mutable)
	or a reference to the canonical, frozen data (immutable).

	**Implementation Details:**
	- Uses `PromiseQueue.multiQueueAdd` to ensure the transform function only runs
	  when all involved session queues are ready.
	- Uses a temporary `txLockPromise` on sessions to block concurrent `update` calls
	  while the transaction logic is executing.
	- Performs a two-phase commit using a transaction marker in the `txStore`:
		1. Write `false` to `txStore` under a unique `txId`.
		2. Update all primary `recordStore` entries with the new data and `txId`.
		3. If successful, remove the `txId` entry from `txStore`.
	- If any step fails, attempts to revert changes by rewriting records without the `txId`
	  and removing the `txId` marker.
	- Uses `JsonPatch` to calculate differences for efficient storage in `TxInfo`.

	Propagates DataStore errors encountered during the commit or revert phases.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction ((state: { [string]: any }) -> boolean) | ((state: { [string]: any }) -> { [string]: any } | false) -- A function that receives the current state of all keys and, depending on `immutable`, either modifies it directly (mutable) and returns `true` to commit, or returns a new state (immutable) to commit. Must return `false` to abort the transaction.
	@return Promise -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
local function txInternal<T>(
	self: Store<T>,
	keys: { string },
	transformFunction: ((state: T) -> boolean) | ((state: T) -> T | false),
	immutable: boolean
): Promise.TPromise<boolean>
	-- Generate a unique ID for this transaction attempt.
	local txId = HttpService:GenerateGUID(false)
	local logger = self._ctx.logger:extend({ method = "tx", keys = keys, txId = txId, immutable = immutable })

	logger:log("trace", "starting transaction")
	if self._closed then
		logger:log("warn", "attempted to start transaction while store is closed")
		return Promise.reject("Store is closed")
	end

	-- Pre-checks: Ensure all keys are loaded and not already involved in a transaction or closed.
	for _, key in keys do
		local session = self._sessions[key]
		if not session then
			logger:log("error", `key not loaded: {key}`)
			return Promise.reject(`Key not loaded: {key}`)
		end
		-- Check if the session is already locked by another transaction.
		if session.txLockPromise then
			logger:log("error", `key is already locked by another transaction: {key}`)
			return Promise.reject(`Key is already locked by another transaction: {key}`)
		end
		-- Check if the session was closed (e.g., due to lock loss).
		if session.closed then
			logger:log("error", `key is closed: {key}`)
			return Promise.reject(`Key is closed: {key}`)
		end
	end

	-- Create a promise that acts as a lock signal for the involved sessions.
	-- It resolves only when the transaction completes (success or failure).
	local txLockResolve
	local txLockPromise = Promise.new(function(resolve)
		txLockResolve = resolve
	end)

	-- Get the PromiseQueues for all involved sessions.
	local queues = Tables.map(keys, function(key)
		return self._sessions[key].queue
	end)

	-- Helper function to manage setting and clearing the txLockPromise on sessions.
	local function withTxLock(fn: () -> Promise.Promise): Promise.Promise
		-- Set the lock promise on all involved sessions *before* executing the function.
		-- This prevents concurrent :update calls from modifying state while tx runs.
		for _, key in keys do
			local session = self._sessions[key]
			session.txLockPromise = txLockPromise
		end
		logger:log("trace", "set txLockPromise on Sessions")

		-- Execute the provided function and ensure the lock is cleared afterwards.
		return Promise.try(fn):finally(function()
			-- Clear the lock promise from all involved sessions.
			for _, key in keys do
				local session = self._sessions[key]
				-- Only clear if it's still *our* lock promise (sanity check).
				if session and session.txLockPromise == txLockPromise then
					session.txLockPromise = nil
				end
			end
			logger:log("trace", "cleared txLockPromise on Sessions")
			-- Resolve the lock promise to signal completion to any waiting operations.
			txLockResolve()
		end)
	end

	logger:log("trace", `acquiring PromiseQueue lock on keys`)
	-- Use multiQueueAdd to ensure the core transaction logic runs only when
	-- all session queues are ready (atomicity across queues).
	return PromiseQueue.multiQueueAdd(queues, function()
		logger:log("trace", `acquired PromiseQueue lock on keys`)

		-- Wrap the core transaction logic with the session tx lock mechanism.
		return withTxLock(function()
			-- 1. Get current state from all sessions.
			local currentState: { [string]: T } = {}
			for _, key in keys do
				local session = self._sessions[key]
				-- Use session.data directly as we hold the queue lock.
				currentState[key] = session.data :: T
			end

			local nextState
			if immutable then
				-- If immutable, the transformFunction has to handle
				-- copy-on-write semantics itself, and we'll pass the current
				-- state directly. The sessions' data are already frozen, but we
				-- still need to freeze the table containing them.
				table.freeze(currentState)
				nextState = currentState
			else
				-- If mutable, we allow the transform function to modify a copy.
				nextState = Tables.copyDeep(currentState)
			end

			-- 2. Execute the user's transform function.
			-- Use noYield to prevent yielding within the transform function.
			local transformOk, result = pcall(noYield, transformFunction, nextState :: any)
			if not transformOk then
				logger:log("error", "tx transformFunction failed", { error = result })
				return Promise.reject(`Store:tx transformFunction failed: {result}`)
			end

			if immutable == false then
				-- If mutable, the transform function should return a boolean.
				-- This indicates whether the changes should be committed.
				assert(typeof(result) == "boolean", "Mutable transaction transform function must return a boolean")
			else
				-- If immutable, the transform function should return a new state or false.
				-- This indicates the new state to commit or that the transaction should be aborted.
				assert(
					typeof(result) == "table" or result == false,
					"Immutable transaction transform function must return a table or false"
				)
			end

			-- If transform returned false, abort the transaction.
			if result == false then
				logger:log("trace", "tx transformFunction returned false, aborting")
				return Promise.resolve(false)
			end

			if immutable then
				nextState = result
			end

			-- We freeze the nextState to prevent further modifications.
			Tables.freezeDeep(nextState)

			-- 3. Check if the transform function illegally modified the set of keys.
			local didKeysChange = false
			for key in currentState do
				if nextState[key] == nil then
					didKeysChange = true
					break
				end
			end
			if not didKeysChange then
				for key in nextState do
					if currentState[key] == nil then
						didKeysChange = true
						break
					end
				end
			end
			if didKeysChange then
				logger:log("error", "keys changed in transaction")
				return Promise.reject("Keys changed in transaction")
			end

			-- 4. Validate the resulting state against schemas.
			for _, key in keys do
				local schemaOk, err = self._ctx.schema(nextState[key] :: any)
				if not schemaOk then
					logger:log("error", `schema validation for key {key} failed: {err}`)
					return Promise.reject(`Store:tx schema validation failed for key '{key}': {err}`)
				end
			end

			-- 5. Determine which keys actually changed.
			local changedKeys = {}
			for key in currentState do
				if not Tables.equalsDeep(currentState[key] :: any, nextState[key] :: any) then
					table.insert(changedKeys, key)
				end
			end

			-- Handle cases where no keys or only one key changed.
			if #changedKeys == 0 then
				logger:log("trace", "tx had no mutations, skipping update")
				return Promise.resolve(true) -- No changes, resolve successfully.
			elseif #changedKeys == 1 then
				-- If only one key changed, treat it as a standard single-key update for efficiency.
				logger:log("trace", `tx only changed one key ('{changedKeys[1]}'), treating as Session:update`)

				local key = changedKeys[1]
				local nextData = nextState[key]

				if immutable == false then
					-- If mutable, reconcile the data before mutating.
					local currentData = currentState[key]
					nextData = Tables.reconcileDeep(currentData, nextData)
				end

				-- Directly mutate the session state and let its normal save mechanism handle it.
				self._sessions[key]:mutateKey(nextData)

				return Promise.resolve(true)
			end

			-- 6. Multi-key change: Proceed with the two-phase commit.
			logger:log("trace", "tx changed multiple keys, beginning multi-key update")
			local patches = {}
			for key, newData in nextState do
				-- Generate JSON patches representing the changes for each key.
				patches[key] = JsonPatch.createPatch(currentState[key], newData)
			end

			-- Phase 1a: Prepare - Write the transaction status marker (`false` = pending).
			local prepareTxPromise = dataStoreRetry(function()
				return self._ctx.txStore:SetAsync(txId, false)
			end):catch(function(err)
				logger:log("error", "failed to prepare txId", { error = err })
				return Promise.reject("Failed to prepare tx") -- Abort if status marker fails.
			end)

			-- Phase 1b: Write Records - After preparing, write the new records with TxInfo.
			local keyWritePromises = prepareTxPromise:andThen(function()
				logger:log("trace", "tx status prepared, writing records with TxInfo")
				-- Create promises for writing each key's record.
				return Promise.all(Tables.map(keys, function(key)
					local txInfo: Types.TxInfo = {
						txId = txId,
						txPatch = patches[key],
						committedData = currentState[key], -- Store pre-tx data for potential reads.
					}
					return self._sessions[key]:writeRecord(txInfo)
				end))
			end)

			-- Function to handle reverting the transaction if commit fails.
			local function revert(err)
				logger:log("error", "multi-key update or tx commit failed, reverting", { error = err })

				-- Attempt to rewrite all records *without* the TxInfo.
				local cleanupPromises = Tables.map(keys, function(key)
					local txInfo = { committedData = currentState[key] } -- Revert to pre-tx state reference.
					return self._sessions[key]:writeRecord(txInfo)
				end)

				-- After attempting record reverts, try to clean up the tx
				-- status marker. It's important we use `Promise.all` instead of
				-- `Promise.allSettled` here, as we want to ensure the tx marker
				-- is scrubbed from all keys before removing it, since a `nil`
				-- tx status means the tx was committed successfully.
				return Promise.all(cleanupPromises)
					:andThen(function()
						logger:log("trace", "multi-key update reverted, cleaning up tx status")
						return dataStoreRetry(function()
							return self._ctx.txStore:RemoveAsync(txId)
						end)
					end)
					:finally(function()
						logger:log("trace", "tx status cleanup attempted after failure")
						-- Reject with the original error that triggered the revert.
						return Promise.reject(err)
					end)
			end

			-- Phase 2: Commit - If all records wrote successfully, remove the tx status marker.
			local commitPromise = keyWritePromises
				:andThen(function()
					logger:log(
						"trace",
						"multi-key records written successfully, committing transaction by removing tx status"
					)
					return dataStoreRetry(function()
						return self._ctx.txStore:RemoveAsync(txId)
					end)
				end)
				:catch(revert) -- If commit fails, trigger the revert process.

			-- Post-Commit/Revert Logic
			return commitPromise
				:andThen(function()
					-- Runs only if commit succeeded (revert path rejects).
					logger:log("debug", "transaction committed successfully")

					-- Update the in-memory session state to reflect the committed changes.
					for _, key in keys do
						local session = self._sessions[key]
						if session then -- Check if session still exists (e.g., wasn't closed due to lock loss during tx)
							local nextData = nextState[key]

							if immutable == false then
								-- If mutable, reconcile the data before mutating.
								local currentData = currentState[key]
								nextData = Tables.reconcileDeep(currentData, nextData)
							end

							session:mutateKey(nextData)
							session.changeSet = {} -- Reset changeset as data is now saved.
						end
					end

					return true
				end)
				:finally(function()
					-- Runs after commit or revert finishes.
					logger:log("trace", "tx finished")
				end)
		end) -- End of withTxLock
	end) -- End of multiQueueAdd
end

--[=[
	Performs an atomic transaction across multiple keys.
	
	Requires the keys to be loaded first via `load()`. The `transformFunction`
	is called with the current state of all involved keys and must return `true`
	to commit changes or `false` to abort.

	Propagates errors from the transaction process, including DataStore errors,
	schema validation failures, and key loading issues.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> boolean -- The transformation function.
	@return Promise<boolean> -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
function Store:tx<T>(keys: { string }, transformFunction: (state: { [string]: T }) -> boolean): Promise.TPromise<boolean>
	assert(t.array(t.string)(keys))
	assert(t.callback(transformFunction))

	return txInternal(self, keys, transformFunction, false)
end

--[=[
	Synchronous wrapper for [Store:tx]. Waits for the Promise to settle.
	Throws an error if the transaction fails or is aborted.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> boolean -- The transformation function.
	@error any -- Throws any error encountered during the transaction.
	@yields
]=]
function Store:txAsync<T>(keys: { string }, transformFunction: (state: { [string]: T }) -> boolean): ()
	self:tx(keys, transformFunction):expect()
end

--[=[
	Performs an atomic transaction across multiple keys with immutable, copy-on-write semantics.

	The data passed to the function is frozen and cannot be modified directly.
	Instead, the function should return a new table with the desired changes.

	Requires the keys to be loaded first via `load()`. The `transformFunction`
	is called with the current state of all involved keys and must return the
	new state to commit or `false` to abort.

	Propagates errors from the transaction process, including DataStore errors,
	schema validation failures, and key loading issues.

	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> { [string]: T } | false -- The transformation function.
	@return Promise<boolean> -- Resolves with `true` if the transaction was successful, or `false` if it was aborted. Rejects on error.
	@error "Key not loaded" -- If any key in the `keys` array has not been loaded.
	@error "Key is already locked by another transaction" -- If any key is already involved in an ongoing `tx`.
	@error "Key is closed" -- If any involved session has been closed (e.g., due to lock loss).
	@error "Store is closed" -- If the store instance has been closed.
	@error "Schema validation failed" -- If the data for any key after transformation fails the schema check.
	@error "Keys changed in transaction" -- If the `transformFunction` attempts to add or remove keys from the state table it receives.
]=]
function Store:txImmutable<T>(
	keys: { string },
	transformFunction: (state: { [string]: T }) -> { [string]: T } | false
): Promise.TPromise<boolean>
	assert(t.array(t.string)(keys))
	assert(t.callback(transformFunction))

	return txInternal(self, keys, transformFunction, true)
end

--[=[
	Synchronous wrapper for [Store:txImmutable]. Waits for the Promise to settle.
	Throws an error if the transaction fails or is aborted.
	
	@within Store
	@param keys {string} -- An array of keys involved in the transaction.
	@param transformFunction (state: { [string]: T }) -> { [string]: T } | false -- The transformation function.
	@error any -- Throws any error encountered during the transaction.
	@yields
]=]
function Store:txImmutableAsync<T>(
	keys: { string },
	transformFunction: (state: { [string]: T }) -> { [string]: T } | false
): boolean
	return self:txImmutable(keys, transformFunction):expect()
end

--[=[
	Forces an immediate save of the given key's current in-memory data state
	to the DataStore.

	:::note
	Data is automatically saved periodically by the Session's autosave mechanism.
	Manual saves are typically only needed in specific scenarios like processing
	developer product purchases (`MarketplaceService.ProcessReceipt`) where immediate
	persistence is crucial before granting benefits.
	:::

	Propagates errors from `Session:save` (e.g., DataStore write errors).
	
	@within Store
	@param key string -- The key whose data to save.
	@return Promise -- Resolves when the save operation completes successfully, rejects on error.
	@error "Key not loaded" -- If `load()` has not been successfully called for this key.
	@error "Store is closed" -- If the store instance has been closed.
]=]
function Store:save(key: string): Promise.Promise
	assert(t.string(key))

	return self:_withSession(key, function(session)
		return session:save()
	end)
end

--[=[
	Synchronous wrapper for [Store:save]. Waits for the Promise to settle.
	Throws an error if the save fails.
	
	@within Store
	@param key string -- The key whose data to save.
	@error any -- Throws any error encountered during the save operation.
	@yields
]=]
function Store:saveAsync(key: string): ()
	self:save(key):expect()
end

--[=[
	Closes the store, gracefully unloading all active sessions.

	Attempts to save any pending changes for all loaded keys before releasing locks
	and removing sessions from memory. The store instance becomes unusable as soon as this is called.

	@within Store
	@return Promise -- Resolves when all sessions have attempted to unload, or rejects if any session encountered an error during its unload process (errors are aggregated).
]=]
function Store:close(): Promise.Promise
	local logger = self._ctx.logger:extend({ method = "close" })
	logger:log("trace", "closing store")

	-- Cancel any loads that are still in progress.
	for key, loadPromise in self._loadPromises do
		logger:log("trace", "cancelling in-progress load", { key = key });
		(loadPromise :: any):cancel()
	end

	-- Collect errors encountered during individual session unloads.
	local rejections = {}

	-- Initiate unload for all currently active sessions.
	local unloadPromises = {}
	for key, session in self._sessions do
		if self._unloadPromises[key] then
			logger:log("trace", "key already being unloaded", { key = key })
			table.insert(unloadPromises, self._unloadPromises[key])
		else
			logger:log("trace", "unloading key", { key = key })
			table.insert(
				unloadPromises,
				self:unload(key):catch(function(err)
					logger:log("error", "error unloading key during close", { key = key, error = err })
					table.insert(rejections, { key = key, error = err })
					-- Don't re-throw; let Promise.allSettled handle aggregation.
				end)
			)
		end
	end

	-- Mark the store as closed immediately. Further operations will be rejected.
	self._closed = true
	logger:log("trace", "store marked as closed")

	return Promise.allSettled(unloadPromises):andThen(function()
		logger:log("debug", "store closed")
		-- If any individual unload failed, reject the main close promise with the errors.
		if #rejections > 0 then
			return Promise.reject(rejections)
		end
	end)
end

--[=[
	Synchronous wrapper for [Store:close]. Waits for the Promise to settle.
	Throws an error if closing fails (i.e., if any session failed to unload).
	
	@within Store
	@error any -- Throws an error (potentially a table of errors) if closing fails.
	@yields
]=]
function Store:closeAsync(): ()
	self:close():expect()
end

--[=[
	Reads the current data for the given key directly from the DataStore,
	bypassing the session cache and locking mechanism.

	This provides a snapshot of the last saved state but does not load the key
	into an active session. Useful for inspecting data without acquiring a lock.
	Handles potential sharding and transaction status automatically.

	Propagates DataStore errors from underlying reads.
	
	@within Store
	@param key string -- The key whose data to peek at.
	@return Promise<T?> -- Resolves with the data object, or `nil` if the key doesn't exist. Rejects on DataStore errors.
]=]
function Store:peek<T>(key: string): Promise.TPromise<T?>
	-- 1. Get the main record from the recordStore.
	return dataStoreRetry(function()
			return self._ctx.recordStore:GetAsync(key)
		end)
		:andThen(function(record: Types.DataStoreRecord?)
			-- If no record exists, the key is empty.
			if record == nil then
				return nil
			end
			assert(record, "luau") -- Forcefully narrowing type due to old type solver limitations

			local file = record.file
			if file then
				local readParams: Files.ReadParams = {
					store = self._ctx.shardStore,
					file = file,
				}
				-- Files.read handles direct data or reconstruction from shards.
				return Files.read(readParams)
			end

			return nil
		end)
		:andThen(function(txInfo: Types.TxInfo?)
			if txInfo == nil then
				return nil
			end
			assert(txInfo, "luau") -- Forcefully narrowing type due to old type solver limitations

			local readTxParams = {
				store = self._ctx.txStore,
				txInfo = txInfo,
			}
			return Transactions.readTx(readTxParams)
		end)
end

--[=[
	Synchronous wrapper for [Store:peek]. Waits for the Promise to settle.
	Returns the data for the key if it exists. Throws on any errors from underlying DataStore operations.

	@within Store
	@param key string -- The key whose data to peek at.
	@return T? -- The data object, or `nil` if the key doesn't exist.
	@error any -- May throw errors from underlying DataStore operations.
	@yields
]=]
function Store:peekAsync<T>(key: string): T?
	return self:peek(key):expect()
end

--[=[
	Checks if a distributed lock is currently active for the given key in MemoryStore.

	Propagates errors from `Locks.probeLockActive`.
	
	@within Store
	@param key string -- The key to check the lock status for.
	@return Promise<boolean> -- Resolves with `true` if a lock is active, `false` otherwise. Rejects on MemoryStore errors.
]=]
function Store:probeLockActive(key: string): Promise.TPromise<boolean>
	-- Delegate directly to the Locks module.
	return Locks.probeLockActive({
		storeContext = self._ctx,
		key = key,
	})
end

--[=[
	Synchronous wrapper for [Store:probeLockActive]. Waits for the Promise to settle.
	Throws an error if the check fails.
	
	@within Store
	@param key string -- The key to check the lock status for.
	@return boolean -- `true` if a lock is active, `false` otherwise.
	@error any -- Throws any error encountered during the probe operation.
	@yields
]=]
function Store:probeLockActiveAsync(key: string): boolean
	return self:probeLockActive(key):expect()
end

--[=[
	Lists historical versions of the data for a given key using DataStore versioning.

	Propagates errors from `DataStore:ListVersionsAsync`.
	
	@within Store
	@param params ListVersionParams -- Parameters specifying the key, sorting, date range, and page size.
	@return Promise<DataStoreVersionPages> -- Resolves with an iterator object (`DataStoreVersionPages`) that can be used to fetch pages of version history. Rejects on DataStore errors.
]=]
function Store:listVersions(params: ListVersionParams): Promise.TPromise<DataStoreVersionPages>
	-- Wrap the DataStore call with retry logic.
	return dataStoreRetry(function()
		return self._ctx.recordStore:ListVersionsAsync(
			params.key,
			params.sortDirection,
			params.minDate,
			params.maxDate,
			params.pageSize
		)
	end)
end

--[=[
	Synchronous wrapper for [Store:listVersions]. Waits for the Promise to settle.
	Throws an error if listing versions fails.
	
	@within Store
	@param params ListVersionParams -- Parameters for listing versions.
	@return DataStoreVersionPages -- An iterator for version history.
	@error any -- Throws any error encountered during the list operation.
	@yields
]=]
function Store:listVersionsAsync(params: ListVersionParams): DataStoreVersionPages
	return self:listVersions(params):expect()
end

--[=[
	Reads the data content of a specific historical version for a given key.

	Propagates DataStore errors from underlying reads.
	
	@within Store
	@param key string -- The key whose version to read.
	@param version string -- The specific version ID (obtained from `listVersions`).
	@return Promise<(T, DataStoreKeyInfo)> -- Resolves with the data object (`T`) and the `DataStoreKeyInfo` for that version. Rejects if the version doesn't exist or on DataStore/read errors.
	@error "Record not found" -- If the specified version doesn't exist.
]=]
function Store:readVersion<T>(key: string, version: string): Promise.TPromise<(T, DataStoreKeyInfo)>
	-- 1. Get the specific version record from the recordStore.
	return dataStoreRetry(function()
			return self._ctx.recordStore:GetVersionAsync(key, version)
		end)
		:andThen(function(record: Types.DataStoreRecord?, keyInfo: DataStoreKeyInfo?)
			-- Ensure both the record content and key info were returned.
			if not record or not keyInfo then
				return Promise.reject("Record not found for the specified version")
			end

			-- 2. Read the data file associated with that version record.
			local readParams: Files.ReadParams = {
				store = self._ctx.recordStore,
				file = record.file,
			}
			return Files.read(readParams):andThen(function(txInfo)
				return txInfo, keyInfo -- Pass both results to the next step.
			end)
		end)
		:andThen(function(txInfo: Types.TxInfo, keyInfo: DataStoreKeyInfo)
			local readTxParams = {
				store = self._ctx.txStore,
				txInfo = txInfo,
			}
			-- Return the final data along with the original keyInfo.
			return Transactions.readTx(readTxParams):andThen(function(finalData)
				return finalData, keyInfo
			end)
		end)
end

--[=[
	Synchronous wrapper for [Store:readVersion]. Waits for the Promise to settle.
	Throws an error if reading the version fails.
	
	@within Store
	@param key string -- The key whose version to read.
	@param version string -- The specific version ID.
	@return T -- The data object for the specified version.
	@return DataStoreKeyInfo -- The key info for the specified version.
	@error any -- Throws any error encountered during the read operation.
	@yields
]=]
function Store:readVersionAsync<T>(key: string, version: string): (T, DataStoreKeyInfo)
	return self:readVersion(key, version):expect()
end

return {
	createStore = createStore,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b1</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="287">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Tables</string>
								<string name="ScriptGuid">{507FF2E4-9FEC-48BF-9593-0696D00133ED}</string>
								<ProtectedString name="Source"><![CDATA[local function copyDeep<T>(t: T): T
	if typeof(t) ~= "table" then
		return t
	end

	local new = table.clone(t :: any)

	for key, value in t :: any do
		if typeof(value) == "table" then
			new[key] = copyDeep(value)
		elseif typeof(value) == "buffer" then
			local copy = buffer.create(buffer.len(value))
			new[key] = buffer.copy(value, 0, copy)
		end
	end

	return new :: any
end

local function mergeDeep<T>(...: any): T
	local result = {}

	for tIndex = 1, select("#", ...) do
		local t = select(tIndex, ...)

		if typeof(t) ~= "table" then
			continue
		end

		for key, value in t do
			if typeof(value) == "table" then
				if result[key] == nil or typeof(result[key]) ~= "table" then
					result[key] = copyDeep(value)
				else
					result[key] = mergeDeep(result[key], value)
				end
			elseif typeof(value) == "buffer" then
				local copy = buffer.create(buffer.len(value))
				result[key] = buffer.copy(value, 0, copy)
			else
				result[key] = value
			end
		end
	end

	return result :: any
end

local function mergeShallow<T>(...: any): T
	local result = {}

	for tIndex = 1, select("#", ...) do
		local t = select(tIndex, ...)

		if typeof(t) ~= "table" then
			continue
		end

		for key, value in t do
			result[key] = value
		end
	end

	return result :: any
end

local function map<T, U>(array: { T }, mapper: (value: T, index: number, array: { T }) -> U?): { U }
	local mapped = {}

	for index, value in array do
		local mappedValue = mapper(value, index, array)

		if mappedValue ~= nil then
			table.insert(mapped, mappedValue)
		end
	end

	return mapped
end

local function equalsDeep(a: { [any]: any }, b: { [any]: any }): boolean
	if typeof(a) ~= "table" or typeof(b) ~= "table" then
		return a == b
	end

	for key, value in a do
		if not equalsDeep(value, b[key]) then
			return false
		end
	end

	for key, value in b do
		if not equalsDeep(value, a[key]) then
			return false
		end
	end

	return true
end

local function freezeDeep<T>(t: T): ()
	if typeof(t) ~= "table" then
		return
	end

	if table.isfrozen(t) == false then
		table.freeze(t)
	end

	for _, value in t :: any do
		if typeof(value) == "table" then
			freezeDeep(value)
		end
	end
end

-- Performs a deep reconciliation of a target table with a source table,
-- applying Copy-On-Write (COW) semantics for the target.
-- The function assumes 'target' and 'source' are non-nil tables.
--
-- Behavior:
-- - Values from 'source' overwrite corresponding values in 'target'.
--   If a value in 'source' is a table, its reference is used directly.
-- - Keys present in 'source' but not in 'target' are added to the result,
--   using 'source's values/references.
-- - Keys present in 'target' but not in 'source' (omitted) are removed from the result.
-- - If 'source' is an empty table, the result will be an empty table, unless 'target'
--   was already empty, in which case 'target' is returned.
local function reconcileDeep<T>(target: T, source: T): T
	-- 1. Handle empty source table:
	-- If 'source' is empty, it dictates that the resulting state should have no keys
	if next(source :: any) == nil then
		if next(target :: any) == nil then
			-- Both 'target' and 'source' are empty. 'target' is unchanged.
			return target
		else
			-- 'target' has keys, but 'source' (empty) dictates they should be removed.
			-- Return source.
			return source
		end
	end

	-- At this point, 'source' is guaranteed to be non-empty.
	-- 'target' can be empty or non-empty.

	-- 2. Main reconciliation logic:
	-- Start by assuming no changes; 'result' points to the original 'target'.
	local result: T = target
	-- Tracks if 'result' has been shallow copied from 'target' at the current level.
	local hasBeenCopied = false

	-- Pass 1: Iterate over 'source' keys to update or add to 'target'.
	-- This pass applies 'source's state onto 'target'.
	for key, sourceValue in source :: any do
		local targetValue = (target :: any)[key]

		if typeof(sourceValue) == "table" then
			local sourceTableValue = sourceValue :: T

			if typeof(targetValue) == "table" then
				local targetTableValue = targetValue :: T
				-- Recursively reconcile the sub-tables.
				local reconciledSubTable = reconcileDeep(targetTableValue, sourceTableValue)

				-- If the recursive call returned a new table instance for the sub-table,
				-- it means a change occurred at a deeper level.
				if reconciledSubTable ~= targetTableValue then
					if not hasBeenCopied then
						-- First change at this level requiring 'target' to be copied.
						result = table.clone(target :: any) :: any
						hasBeenCopied = true
					end
					(result :: any)[key] = reconciledSubTable
				end
			else
				-- 'targetValue' is not a table (or is nil), but 'sourceValue' is a table.
				-- This is an overwrite or an addition of a new table.
				-- Use 'sourceTableValue's reference directly.
				-- This always constitutes a change unless targetValue was already identically sourceTableValue (rare).
				if not hasBeenCopied then
					result = table.clone(target :: any) :: any
					hasBeenCopied = true
				end
				(result :: any)[key] = sourceTableValue
			end
		else
			-- 'sourceValue' is a primitive (number, string, boolean).
			-- (Note: nil sourceValue means key is absent from source, handled by Pass 2 for deletions)
			-- A change is needed if 'targetValue' is different from 'sourceValue'.
			if targetValue ~= sourceValue then
				if not hasBeenCopied then
					result = table.clone(target :: any) :: any
					hasBeenCopied = true
				end
				(result :: any)[key] = sourceValue
			end
		end
	end

	-- Pass 2: Iterate over original 'target's keys to handle deletions.
	-- If a key was in 'target' but is not in 'source', it should be removed from 'result'.
	-- ('source' is non-empty here).
	for keyInTarget in target :: any do
		if (source :: any)[keyInTarget] == nil then -- Key is in 'target' but absent in 'source'.
			if not hasBeenCopied then
				-- This deletion is the first change requiring 'target' to be copied.
				result = table.clone(target :: any) :: any
				hasBeenCopied = true
			end
			-- Remove the key from 'result' by setting its value to nil.
			(result :: any)[keyInTarget] = nil
		end
	end

	-- If 'hasBeenCopied' is false, no merging operations (updates, additions, or deletions)
	-- resulted in any change to 'target' at this level. The original 'target' is returned.
	-- Otherwise, 'result' (the shallow copy with reconciled changes) is returned.
	return result
end

return {
	copyDeep = copyDeep,
	mergeDeep = mergeDeep,
	mergeShallow = mergeShallow,
	equalsDeep = equalsDeep,
	freezeDeep = freezeDeep,
	map = map,
	reconcileDeep = reconcileDeep,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="288">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Transactions</string>
								<string name="ScriptGuid">{AFAC86FD-FB12-4693-A947-978AA63D1EA2}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Transactions
	@private

	Provides functionality for reading data that might be involved in an ongoing,
	uncommitted transaction initiated by `Store:tx()`.

	:::note
	This module only contains the implementation for [Transactions.readTx]. Writing transactions is handled in [Store:tx]
	:::

	**Purpose:** When a `Store:tx()` operation begins, it might involve multiple steps
	(e.g., reading current data, applying changes, writing back). If a server crashes
	*before* the transaction is fully committed or rolled back, this module helps
	determine the correct state to return.

	It checks the status of the transaction ID (`txId`) stored separately in the DataStore.
	If the transaction is still pending (represented as `false`) or has failed, it returns the last known
	*committed* data. If the transaction has successfully committed (represented as `nil`), it applies the
	transaction's patch (`txPatch`) to the previously committed data (`committedData`)
	to return the *newly* committed state.

	This ensures that readers either get the stable state before the transaction or the
	final state after a successful transaction, avoiding inconsistent intermediate states.
]=]

local JsonPatch = require(script.Parent.JsonPatch)
local Types = require(script.Parent.Types)
local Promise = require(script.Parent.Promise)
local dataStoreRetry = require(script.Parent.dataStoreRetry)

--[=[
	Parameters required for the `readTx` function.

	@interface ReadTxParams
	@within Transactions
	.store DataStore -- The DataStore instance where transaction status markers are stored.
	.txInfo Types.TxInfo -- The transaction information associated with the data being read.
]=]
export type ReadTxParams = {
	store: DataStore,
	txInfo: Types.TxInfo,
}

-- We never want to read a cached value for a transaction marker.
local getOptions = Instance.new("DataStoreGetOptions")
getOptions.UseCache = false

--[=[
	Reads data, considering the status of an associated transaction.

	Checks the status of the transaction ID (`txInfo.txId`) in the DataStore.
	- If `txId` is nil (meaning no transaction was associated or it was cleaned up),
	  returns the `committedData` directly.
	- If `txId` exists:
		- Fetches the status from the DataStore using the `txId` as the key.
		- **Status Convention:**
			- `nil`: The transaction successfully committed. The corresponding `txPatch`
			  should be applied to `committedData`.
			- `false`: The transaction is still in progress or failed/rolled back. The
			  `committedData` (state before the transaction) should be returned.
		- Applies the patch if the status is `nil` and a patch exists.
		- Returns `committedData` if the status is `false`.

	Using `nil` to indicate a successful transaction allows for easier cleanup of
	transaction markers in the DataStore. Instead of setting the marker to `true`
	and only removing it after the `txId` is no longer needed, we can simply delete
	the marker immediately after a successful transaction.

	@within Transactions
	@param params ReadTxParams -- The parameters for the read operation.
	@return Promise<any> -- A Promise that resolves with the appropriate data (either committed or patched).
	@error string -- Rejects if the transaction status indicates commitment (`nil`) but the `txPatch` is missing, or if DataStore operations fail (via `dataStoreRetry`). Propagates errors from `DataStore:GetAsync` via `dataStoreRetry`.
]=]
local function readTx(params: ReadTxParams): Promise.TPromise<any>
	local txInfo = params.txInfo

	-- If there's no transaction ID, the data is simply the last committed state.
	local txId = txInfo.txId
	if txId == nil then
		return Promise.resolve(txInfo.committedData)
	end

	-- Fetch the transaction status marker from the DataStore using the txId.
	return dataStoreRetry(function()
		return params.store:GetAsync(txId, getOptions)
	end):andThen(function(txStatus)
		-- Check the transaction status using the nil/false convention.
		-- `nil` means the transaction successfully committed.
		-- `false` means it's pending or failed (rolled back).
		-- This convention avoids the need to set the marker to `true` after a
		-- successful transaction, allowing for immediate cleanup of the marker.
		if txStatus == nil then
			-- Transaction committed successfully. Apply the patch.
			if txInfo.txPatch == nil then
				-- This indicates an inconsistent state - committed but no changes recorded.
				return Promise.reject(`Transaction '{txId}' is committed but has no patch`)
			end
			-- Apply the patch to the data that was committed *before* this transaction.
			return JsonPatch.applyPatch(txInfo.committedData, txInfo.txPatch)
		else
			-- Transaction is pending or failed. Return the data as it was *before* this transaction.
			return txInfo.committedData
		end
	end)
end

return {
	readTx = readTx,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="289">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{62A8F6C0-6C3E-473C-803E-BC81B723D661}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Types
	@private

	Common types shared among different modules.
]=]

local Log = require(script.Parent.Log)
local t = require(script.Parent.Parent.t)

--[=[
	Represents a single operation within a JSON Patch array.
	Used for describing changes between data states.

	@interface PatchOperation
	@within Types
	.op "add" | "replace" | "remove" -- The operation type.
	.path string -- A JSON Pointer string indicating the target location.
	.value any? -- The value to add or replace (used for "add" and "replace"). Optional for "remove".
]=]
export type PatchOperation =
	{ op: "add", path: string, value: any }
	| { op: "replace", path: string, value: any }
	| { op: "remove", path: string }

--[=[
	An array of PatchOperation objects representing the changes made during a transaction.

	@type TxPatch { PatchOperation }
	@within Types
]=]
export type TxPatch = { PatchOperation }

--[=[
	Holds information about the state of data potentially involved in a transaction.
	Used by the `Transactions` module to determine the correct data to return during reads.

	@interface TxInfo
	@within Types
	.committedData any -- The last known data state that was successfully saved to the primary DataStore record *before* the transaction identified by `txId` began.
	.txId string? -- The unique identifier of the transaction currently attempting to modify this data. If `nil`, no transaction is active or the last one completed and was cleaned up.
	.txPatch TxPatch? -- The set of changes (JSON Patch) applied by the transaction identified by `txId`. This is used to reconstruct the final state if the transaction is confirmed as committed.
]=]
export type TxInfo = {
	committedData: any,
	txId: string?,
	txPatch: TxPatch?,
}

--[=[
	Represents the stored data, abstracting away the sharding mechanism.

	If the data was small enough, it's stored directly in the `data` field.
	If the data was large and sharded, `shard` and `count` are present instead,
	pointing to the location and number of data shards stored separately.

	@interface File
	@within Types
	.data any? -- The actual data, if it was stored directly (not sharded). Mutually exclusive with `shard` and `count`.
	.shard string? -- The unique identifier for the set of shards, if the data was sharded. Mutually exclusive with `data`.
	.count number? -- The total number of shards, if the data was sharded. Mutually exclusive with `data`.
]=]
export type File = {
	data: any,
} & {
	shard: string,
	count: number,
}

--[=[
	The structure of the primary record stored in the main DataStore for each key.
	This record contains metadata and a reference (`File`) to the actual user data.

	@interface DataStoreRecord
	@within Types
	.appliedMigrations {string} -- A list of names of migration steps that have already been successfully applied to the data associated with this record. Initialized as empty.
	.file File -- A `File` object representing the actual user data. This might contain the data directly or point to shards.
	.orphanedFiles {File} -- A list of sharded `File` objects that are no longer referenced by any active record. This is used for cleanup and garbage collection of unused data. Initialized as empty.
]=]
export type DataStoreRecord = {
	appliedMigrations: { string },
	file: File,
	orphanedFiles: { File },
}

--[=[
	Represents a migration step that can be applied to data when loading it.
	Each step has a name and an `apply` function that takes the data as input
	and returns a modified version of the data.

	@interface MigrationStep
	@within Types
	.name string -- The unique name of the migration step.
	.apply (data: { [string]: any }) -> { [string]: any } -- The function that transforms the data for this step.
]=]
export type MigrationStep = {
	name: string,
	apply: (data: { [string]: any }) -> { [string]: any },
}

--[=[
	Contains all the contextual information and dependencies required for a `Store`
	or `PlayerStore` instance to operate. This includes configuration, service instances,
	callbacks, and underlying storage objects.

	@interface StoreContext<T>
	@within Types
	.name string -- The name of the store, used for logging and potentially identifying DataStore keys.
	.template T -- A default template object representing the initial state for new data entries.
	.schema (value: any) -> (boolean, string?) -- A validation function (like one created by `t`) used to check if loaded or modified data conforms to the expected structure. Returns `true` if valid, or `false` and an error message string if invalid.

	.migrationSteps {MigrationStep} -- A list of migration steps to apply to data when it's loaded, based on the `appliedMigrations` field in the `DataStoreRecord`. Initialized as empty.
	.importLegacyData ((key: string) -> any?)? -- An optional function to load data from a legacy storage system when a key is accessed for the first time in this store.

	.dataStoreService DataStoreService -- The Roblox DataStoreService instance.
	.memoryStoreService MemoryStoreService -- The Roblox MemoryStoreService instance.

	.changedCallbacks { (key: string, newData: T, oldData: T?) -> () } -- A list of functions to call whenever data for a key is successfully changed. Provides the key, the new data state, and the previous data state (if available). Initialized as empty.
	.logger Logger -- A `Logger` instance used for internal logging within the store and its components.
	.onLockLost ((key: string) -> ())? -- An optional callback function triggered if the distributed lock for a key is lost unexpectedly (e.g., due to expiration or external interference).

	.recordStore DataStore -- The DataStore used to store `DataStoreRecord` objects.
	.shardStore DataStore -- The DataStore used to store the actual data shards for large files.
	.txStore DataStore -- The DataStore used to store transaction status markers (`txId` keys).
	.lockHashMap MemoryStoreHashMap -- The MemoryStore HashMap used for managing distributed locks.
]=]
export type StoreContext<T> = {
	name: string,
	template: T,
	schema: (value: any) -> (boolean, string?),

	migrationSteps: { MigrationStep },
	importLegacyData: ((key: string) -> any?)?,

	dataStoreService: DataStoreService,
	memoryStoreService: MemoryStoreService,

	changedCallbacks: { (key: string, newData: T, oldData: T?) -> () },
	logger: Log.Logger,
	onLockLost: ((key: string) -> ())?,

	recordStore: DataStore,
	shardStore: DataStore,
	txStore: DataStore,
	lockHashMap: MemoryStoreHashMap,
}

-- Validation check for TxInfo structure using 't' library.
local txInfoCheck = t.some(
	t.strictInterface({ committedData = t.any }),
	t.strictInterface({ committedData = t.any, txId = t.string, txPatch = t.any })
)
-- Validation check for File structure using 't' library.
local fileCheck = t.some(t.strictInterface({ data = t.any }), t.strictInterface({ shard = t.string, count = t.number }))

--[=[
	A handle returned by retry utility functions like `hashMapRetry`.
	It bundles the core Promise with a way to cancel the retry operation.

	When the `cancel` function is called, instead of cancelling the Promise itself,
	the retry mechanism is stopped, and the Promise is rejected with a cancellation error
	when the next retry attempt is made.

	@interface RetryHandle<T>
	@within Types
	.promise T -- The Promise representing the asynchronous operation being retried. This promise resolves or rejects based on the outcome of the operation after retries.
	.cancel () -> () -- A function that can be called to signal cancellation. If called, the retry mechanism will stop further attempts and reject the `promise`.
]=]
export type RetryHandle<T> = {
	promise: T,
	cancel: () -> (),
}

return {
	txInfoCheck = txInfoCheck,
	fileCheck = fileCheck,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="290">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">dataStoreRetry</string>
								<string name="ScriptGuid">{8DBFAD8E-C8E6-478A-9B42-376C294649FA}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class dataStoreRetry
	@private

	Provides a utility function to wrap Roblox DataStore API calls with automatic
	retries for specific, commonly transient error codes.

	**Purpose:** DataStore operations can sometimes fail due to temporary service issues,
	throttling, or internal errors. This module implements a retry mechanism with
	exponential backoff to increase the likelihood of success for operations that
	encounter these transient failures.

	**Usage:**
	```lua
	local DataStoreService = game:GetService("DataStoreService")
	local dataStoreRetry = require(script.Parent.dataStoreRetry)
	local myStore = DataStoreService:GetDataStore("MyStore")

	dataStoreRetry(function()
		-- This function will be retried automatically on specific errors
		return myStore:GetAsync("MyKey")
	end):andThen(function(data)
		print("Successfully retrieved data:", data)
	end):catch(function(err)
		warn("Failed to get data after retries:", err)
	end)
	```
]=]

local Promise = require(script.Parent.Promise)

-- Maximum number of times to attempt the operation before giving up.
local MAX_RETRIES = 5

--[[
	List of DataStore error codes that are considered potentially transient and
	worth retrying. These generally indicate temporary issues like internal server
	errors, throttling, or temporary unavailability.

	Refer to the Roblox Creator Documentation for details on specific DataStore error codes:
	https://create.roblox.com/docs/cloud-services/data-stores/error-codes-and-limits
]]
local RETRY_ERROR_CODES = {
	-- 3xx: Throttling errors (indicating the request was throttled and dropped due to a full queue)
	301, -- 301: GetAsyncThrottle
	302, -- 302: SetAsyncThrottle
	303, -- 303: IncreAsyncThrottle
	304, -- 304: UpdateAsyncThrottle / TransformThrottle
	305, -- 305: GetSortedThrottle
	306, -- 306: RemoveAsyncThrottle

	-- 5xx: Server errors (most likely to be transient)
	500, -- 500: Undocumented, included for completeness.
	501, -- 501: InternalError - Can't parse response because data might be corrupted.
	502, -- 502: RequestRejected - Error occurred when processing on Roblox servers.
	503, -- 503: InternalError - Request was successful but key wasn't found.
	504, -- 504: InternalError - Request was successful but the response wasn't formatted correctly.
	505, -- 505: InternalError - OrderedDataStore request was successful but the response wasn't formatted correctly.
	-- Note: Other errors (e.g., 4xx permission errors, 1xx argument errors) are generally not transient
	-- and are not retried by default.
}

--[=[
	Wraps a function that performs a DataStore operation, automatically retrying it
	if it fails with specific transient error codes.

	Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries.

	@within dataStoreRetry
	@param func () -> T -- The function to execute and potentially retry. This function should perform the desired DataStore operation (e.g., `GetAsync`, `SetAsync`, `UpdateAsync`). It should return the result of the operation on success or throw an error on failure.
	@return Promise<T> -- A Promise that resolves with the return value of `func` if it succeeds within `MAX_RETRIES` attempts.
	@error string -- Rejects with the error message if `func` fails with a non-retriable error code, or if it fails with a retriable error code `MAX_RETRIES` times.
]=]
local function dataStoreRetry<T>(func: () -> T): Promise.TPromise<T>
	return Promise.new(function(resolve, reject)
		local lastError -- Store the last retriable error encountered
		for i = 1, MAX_RETRIES do
			-- Apply exponential backoff delay before retrying (starting from the second attempt)
			if i > 1 then
				-- Wait times: 2^0=1s, 2^1=2s, 2^2=4s, 2^3=8s
				local retryAfter = 2 ^ (i - 1)
				task.wait(retryAfter)
			end

			-- Execute the provided function within a protected call
			local result = table.pack(pcall(func)) :: any -- { success: boolean, ...results | error: string }
			if result[1] == true then
				-- Success! Resolve the promise with the function's return values.
				return resolve(table.unpack(result, 2))
			end

			-- Failure. Extract the error message and attempt to parse the error code.
			local errorMessage = result[2]
			local errorCode = errorMessage:match("^(%d+):") -- Match code at the beginning (e.g., "502: API Services...")
			errorCode = if errorCode then tonumber(errorCode) else nil

			-- Check if the error code is in the list of retriable codes.
			if errorCode ~= nil and table.find(RETRY_ERROR_CODES, errorCode) then
				-- Retriable error. Store it and continue the loop for the next attempt.
				lastError = errorMessage
				continue
			else
				-- Non-retriable error or failed to parse code. Reject immediately.
				return reject(errorMessage)
			end
		end
		-- If the loop completes, it means MAX_RETRIES were reached without success.
		return reject(`DataStore error: too many retries ({MAX_RETRIES}). Last error: {lastError}`)
	end) :: any
end

return dataStoreRetry
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b5</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="291">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">hashMapRetry</string>
								<string name="ScriptGuid">{89A222E5-C40F-4B9E-AB7C-55AC415999AB}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class hashMapRetry
	@private

	Provides a utility function to wrap Roblox MemoryStoreService HashMap API calls
	(like `GetAsync`, `SetAsync`, `UpdateAsync`) with automatic retries for specific,
	commonly transient error conditions identified by error message strings.

	**Purpose:** Similar to [dataStoreRetry], MemoryStore operations can fail due to
	temporary service issues, throttling, or internal errors. This module implements
	a retry mechanism with exponential backoff to handle these transient failures.
	It differs from [dataStoreRetry] by matching against error *strings* rather than
	numeric codes, as MemoryStore errors often manifest this way. It also includes
	a cancellation mechanism.

	**Usage:**
	```lua
	local MemoryStoreService = game:GetService("MemoryStoreService")
	local hashMapRetry = require(script.Parent.hashMapRetry)
	local myMap = MemoryStoreService:GetHashMap("MyMap")

	local handle = hashMapRetry(function()
		-- This function will be retried automatically on specific errors
		return myMap:GetAsync("MyKey")
	end)

	handle.promise:andThen(function(data)
		print("Successfully retrieved data:", data)
	end):catch(function(err)
		warn("Failed to get data after retries or cancelled:", err)
	end)

	-- To cancel the operation:
	-- handle.cancel()
	```
]=]

local Promise = require(script.Parent.Promise)
local Types = require(script.Parent.Types)

-- Maximum number of times to attempt the operation before giving up.
local MAX_RETRIES = 5

--[[
	List of error message substrings that indicate potentially transient MemoryStore
	errors worth retrying. These are based on observed errors and common failure modes
	like throttling and internal issues. Unlike DataStores, MemoryStore often reports
	errors via strings rather than distinct numeric codes.

	Refer to Roblox Creator Documentation for MemoryStore limits and potential issues:
	https://create.roblox.com/docs/cloud-services/memory-stores#observability
	(Note: Specific error message strings may not be exhaustively documented.)
]]
local RETRY_ERROR_CODES = {
	"TotalRequestsOverLimit", -- Exceeds universe-level request unit limit.
	"InternalError", -- Generic internal server error.
	"RequestThrottled", -- Recent MemoryStores requests hit one or more limits.
	"PartitionRequestsOverLimit", -- Exceeds partition request unit limit.
	"Throttled", -- Undocumented, included for completeness.
	"Timeout", -- Undocumented, included for completeness.
}

--[=[
	Wraps a function that performs a MemoryStore HashMap operation, automatically
	retrying it if it fails with specific transient error message substrings.

	Implements an exponential backoff strategy: waits 1s, 2s, 4s, 8s between retries.
	Includes a cancellation mechanism via the returned [RetryHandle].

	@within hashMapRetry
	@param func () -> any -- The function to execute and potentially retry. This function should perform the desired MemoryStore HashMap operation (e.g., `GetAsync`, `SetAsync`, `UpdateAsync`). It should return the result on success or throw an error on failure.
	@return RetryHandle<Promise<any>> -- A handle containing: `promise` (A Promise that resolves with the return value of `func` if it succeeds within `MAX_RETRIES` attempts) and `cancel` (A function that, when called, attempts to stop further retries and rejects the promise).
	@error string -- Rejects if `func` fails with a non-retriable error, if it fails with a retriable error `MAX_RETRIES` times, or if `cancel()` is called.
]=]
local function hashMapRetry(func: () -> any): Types.RetryHandle<Promise.TPromise<any>>
	local cancel = false

	local handle: Types.RetryHandle<Promise.TPromise<any>> = {
		promise = Promise.new(function(resolve, reject)
			local lastError
			for i = 1, MAX_RETRIES do
				-- Apply exponential backoff delay before retrying (starting from the second attempt)
				-- Only wait if the operation hasn't been cancelled.
				if i > 1 and not cancel then
					-- Wait times: 2^0=1s, 2^1=2s, 2^2=4s, 2^3=8s
					local retryAfter = 2 ^ (i - 1)
					task.wait(retryAfter)
				end

				if cancel then
					return reject(`HashMap error: operation cancelled`)
				end

				local result = table.pack(pcall(func)) -- { success: boolean, ...results | error: string }
				if result[1] == true then
					-- Success! Resolve the promise with the function's return values.
					return resolve(table.unpack(result, 2))
				end

				-- Failure. Store the error message.
				lastError = result[2]

				-- Check if the error message contains any of the retriable substrings.
				local retry = false
				for _, errorCodeSubstring in RETRY_ERROR_CODES do
					if lastError:find(errorCodeSubstring, 1, true) then
						retry = true
						break
					end
				end

				-- If the error is retriable, continue to the next iteration (if not cancelled).
				if retry then
					continue
				end

				-- Non-retriable error. Reject immediately.
				return reject(`HashMap error: {lastError}`)
			end
			-- If the loop completes, it means MAX_RETRIES were reached without success.
			-- Check for cancellation one last time before rejecting due to retries.
			if cancel then
				return reject(`HashMap error: operation cancelled`)
			else
				return reject(`HashMap error: too many retries ({MAX_RETRIES}). Last error: {lastError}`)
			end
		end),
		cancel = function()
			cancel = true
		end,
	}

	return handle
end

return hashMapRetry
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b6</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="292">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">noYield</string>
								<string name="ScriptGuid">{CC5B801E-D220-429D-B423-C2B8438595EE}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co: thread, ok: boolean, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "attempt to yield"), 2)
	end

	return ...
end

local function noYield<Input..., Output...>(callback: (Input...) -> Output..., ...: Input...): Output...
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return noYield
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b7</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="293">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">t</string>
							<string name="ScriptGuid">{5B7BA41B-1A98-46A3-8674-4748DBD9A386}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["osyrisrblx_t@3.1.1"]["t"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b8</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="294">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">sleitnick_signal@1.5.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004b9</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="295">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">signal</string>
							<string name="ScriptGuid">{E9C6E566-4059-4DA0-9052-6F95FDEFFCD7}</string>
							<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	```lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	```
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		Connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	Signals allow events to be dispatched and handled.

	For example:
	```lua
	local signal = Signal.new()

	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	signal:Fire("Hello world!")
	```
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
	}, Signal)
	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	```lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	```
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)
	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)
	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- `true` if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	```lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	```
]=]
function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end
	return connection
end

--[=[
	@deprecated v1.3.0 -- Use `Signal:Once` instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	```lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	```
]=]
function Signal:Once(fn)
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		fn(...)
	end)
	return connection
end

function Signal:GetConnections()
	local items = {}
	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end
	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	```lua
	signal:DisconnectAll()
	```
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	```lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, {Test = "Test"}, true)
	```
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as `Fire`, but uses `task.defer` internally & doesn't take advantage of thread reuse.
	```lua
	signal:FireDeferred("Hello")
	```
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		task.defer(item._fn, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using `Once` might be a better solution.
	```lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	```
]=]
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local connection
	local done = false
	connection = self:Connect(function(...)
		if done then
			return
		end
		done = true
		connection:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	`Signal.Wrap`. Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling `Destroy`
	on a signal will also disconnect all connections immediately.
	```lua
	signal:Destroy()
	```
]=]
function Signal:Destroy()
	self:DisconnectAll()
	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return {
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ba</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="296">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">init.spec</string>
								<string name="ScriptGuid">{C152CD83-1714-440D-9D59-442DD7796411}</string>
								<ProtectedString name="Source"><![CDATA[local function AwaitCondition(predicate, timeout)
	local start = os.clock()
	timeout = (timeout or 10)
	while true do
		if predicate() then
			return true
		end
		if (os.clock() - start) > timeout then
			return false
		end
		task.wait()
	end
end

return function()
	local Signal = require(script.Parent)

	local signal

	local function NumConns(sig)
		sig = sig or signal
		return #sig:GetConnections()
	end

	beforeEach(function()
		signal = Signal.new()
	end)

	afterEach(function()
		signal:Destroy()
	end)

	describe("Constructor", function()
		it("should create a new signal and fire it", function()
			expect(Signal.Is(signal)).to.equal(true)
			task.defer(function()
				signal:Fire(10, 20)
			end)
			local n1, n2 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
		end)

		it("should create a proxy signal and connect to it", function()
			local signalWrap = Signal.Wrap(game:GetService("RunService").Heartbeat)
			expect(Signal.Is(signalWrap)).to.equal(true)
			local fired = false
			signalWrap:Connect(function()
				fired = true
			end)
			expect(AwaitCondition(function()
				return fired
			end, 2)).to.equal(true)
			signalWrap:Destroy()
		end)
	end)

	describe("FireDeferred", function()
		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function()
				return (send == value)
			end, 1)).to.equal(true)
		end)

		it("should be able to fire a reference based argument", function()
			local send = { 10, 20 }
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:FireDeferred(send)
			expect(AwaitCondition(function()
				return (send == value)
			end, 1)).to.equal(true)
		end)
	end)

	describe("Fire", function()
		it("should be able to fire primitive argument", function()
			local send = 10
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)

		it("should be able to fire a reference based argument", function()
			local send = { 10, 20 }
			local value
			signal:Connect(function(v)
				value = v
			end)
			signal:Fire(send)
			expect(value).to.equal(send)
		end)
	end)

	describe("ConnectOnce", function()
		it("should only capture first fire", function()
			local value
			local c = signal:ConnectOnce(function(v)
				value = v
			end)
			expect(c.Connected).to.equal(true)
			signal:Fire(10)
			expect(c.Connected).to.equal(false)
			signal:Fire(20)
			expect(value).to.equal(10)
		end)
	end)

	describe("Wait", function()
		it("should be able to wait for a signal to fire", function()
			task.defer(function()
				signal:Fire(10, 20, 30)
			end)
			local n1, n2, n3 = signal:Wait()
			expect(n1).to.equal(10)
			expect(n2).to.equal(20)
			expect(n3).to.equal(30)
		end)
	end)

	describe("DisconnectAll", function()
		it("should disconnect all connections", function()
			signal:Connect(function() end)
			signal:Connect(function() end)
			expect(NumConns()).to.equal(2)
			signal:DisconnectAll()
			expect(NumConns()).to.equal(0)
		end)
	end)

	describe("Disconnect", function()
		it("should disconnect connection", function()
			local con = signal:Connect(function() end)
			expect(NumConns()).to.equal(1)
			con:Disconnect()
			expect(NumConns()).to.equal(0)
		end)

		it("should still work if connections disconnected while firing", function()
			local a = 0
			local c
			signal:Connect(function()
				a += 1
			end)
			c = signal:Connect(function()
				c:Disconnect()
				a += 1
			end)
			signal:Connect(function()
				a += 1
			end)
			signal:Fire()
			expect(a).to.equal(3)
		end)

		it("should still work if connections disconnected while firing deferred", function()
			local a = 0
			local c
			signal:Connect(function()
				a += 1
			end)
			c = signal:Connect(function()
				c:Disconnect()
				a += 1
			end)
			signal:Connect(function()
				a += 1
			end)
			signal:FireDeferred()
			expect(AwaitCondition(function()
				return a == 3
			end)).to.equal(true)
		end)
	end)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004bb</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="297">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{27EBB83C-242B-4A83-9F1F-4B4A2FC9B824}</string>
								<ProtectedString name="Source"><![CDATA[return {
	package = {
		authors = {"Stephen Leitnick"},
		description = "Signal class",
		license = "MIT",
		name = "sleitnick/signal",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "1.5.0",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004bc</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="298">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">sleitnick_table-util@1.2.1</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004bd</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="299">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">table-util</string>
							<string name="ScriptGuid">{DF1B0333-2B54-4E09-A4D0-19355A7DFC6E}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

-- TableUtil
-- Stephen Leitnick
-- September 13, 2017

--[=[
	@class TableUtil

	A collection of helpful table utility functions. Many of these functions are carried over from JavaScript or
	Python that are not present in Lua.

	Tables that only work specifically with arrays or dictionaries are marked as such in the documentation.

	:::info Immutability
	All functions (_except_ `SwapRemove`, `SwapRemoveFirstValue`, and `Lock`) treat tables as immutable and will return
	copies of the given table(s) with the operations performed on the copies.
]=]
local TableUtil = {}

local HttpService = game:GetService("HttpService")
local rng = Random.new()

--[=[
	@within TableUtil
	@function Copy
	@param tbl table -- Table to copy
	@param deep boolean? -- Whether or not to perform a deep copy
	@return table

	Creates a copy of the given table. By default, a shallow copy is
	performed. For deep copies, a second boolean argument must be
	passed to the function.

	:::caution No cyclical references
	Deep copies are _not_ protected against cyclical references. Passing
	a table with cyclical references _and_ the `deep` parameter set to
	`true` will result in a stack-overflow.
]=]
local function Copy<T>(t: T, deep: boolean?): T
	if not deep then
		return (table.clone(t :: any) :: any) :: T
	end
	local function DeepCopy(tbl: { any })
		local tCopy = table.clone(tbl)
		for k, v in tCopy do
			if type(v) == "table" then
				tCopy[k] = DeepCopy(v)
			end
		end
		return tCopy
	end
	return DeepCopy(t :: any) :: T
end

--[=[
	@within TableUtil
	@function Sync
	@param srcTbl table -- Source table
	@param templateTbl table -- Template table
	@return table

	Synchronizes the `srcTbl` based on the `templateTbl`. This will make
	sure that `srcTbl` has all of the same keys as `templateTbl`, including
	removing keys in `srcTbl` that are not present in `templateTbl`. This
	is a _deep_ operation, so any nested tables will be synchronized as
	well.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, experience = 12}
	data = TableUtil.Sync(data, template)
	print(data) --> {kills = 10, deaths = 0, xp = 0}
	```

	:::caution Data Loss Warning
	This is a two-way sync, so the source table will have data
	_removed_ that isn't found in the template table. This can
	be problematic if used for player data, where there might
	be dynamic data added that isn't in the template.

	For player data, use `TableUtil.Reconcile` instead.
]=]
local function Sync<S, T>(srcTbl: S, templateTbl: T): T
	assert(type(srcTbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")

	local tbl = table.clone(srcTbl)

	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k, v in pairs(tbl) do
		local vTemplate = templateTbl[k]

		-- Remove keys not within template:
		if vTemplate == nil then
			tbl[k] = nil

			-- Synchronize data types:
		elseif type(v) ~= type(vTemplate) then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end

			-- Synchronize sub-tables:
		elseif type(v) == "table" then
			tbl[k] = Sync(v, vTemplate)
		end
	end

	-- Add any missing keys:
	for k, vTemplate in pairs(templateTbl) do
		local v = tbl[k]

		if v == nil then
			if type(vTemplate) == "table" then
				tbl[k] = Copy(vTemplate, true)
			else
				tbl[k] = vTemplate
			end
		end
	end

	return (tbl :: any) :: T
end

--[=[
	@within TableUtil
	@function Reconcile
	@param source table
	@param template table
	@return table

	Performs a one-way sync on the `source` table against the
	`template` table. Any keys found in `template` that are
	not found in `source` will be added to `source`. This is
	useful for syncing player data against data template tables
	to ensure players have all the necessary keys, while
	maintaining existing keys that may no longer be in the
	template.

	This is a deep operation, so nested tables will also be
	properly reconciled.

	```lua
	local template = {kills = 0, deaths = 0, xp = 0}
	local data = {kills = 10, abc = 20}
	local correctedData = TableUtil.Reconcile(data, template)
	
	print(correctedData) --> {kills = 10, deaths = 0, xp = 0, abc = 20}
	```
]=]
local function Reconcile<S, T>(src: S, template: T): S & T
	assert(type(src) == "table", "First argument must be a table")
	assert(type(template) == "table", "Second argument must be a table")

	local tbl = table.clone(src)

	for k, v in template do
		local sv = src[k]
		if sv == nil then
			if type(v) == "table" then
				tbl[k] = Copy(v, true)
			else
				tbl[k] = v
			end
		elseif type(sv) == "table" then
			if type(v) == "table" then
				tbl[k] = Reconcile(sv, v)
			else
				tbl[k] = Copy(sv, true)
			end
		end
	end

	return (tbl :: any) :: S & T
end

--[=[
	@within TableUtil
	@function SwapRemove
	@param tbl table -- Array
	@param i number -- Index

	Removes index `i` in the table by swapping the value at `i` with
	the last value in the array, and then trimming off the last
	value from the array.

	This allows removal of the value at `i` in `O(1)` time, but does
	not preserve array ordering. If a value needs to be removed from
	an array, but ordering of the array does not matter, using
	`SwapRemove` is always preferred over `table.remove`.

	In the following example, we remove "B" at index 2. SwapRemove does
	this by moving the last value "E" over top of "B", and then trimming
	off "E" at the end of the array:
	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemove(t, 2) -- Remove "B"
	print(t) --> {"A", "E", "C", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemove<T>(t: { T }, i: number)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end

--[=[
	@within TableUtil
	@function SwapRemoveFirstValue
	@param tbl table -- Array
	@param v any -- Value to find
	@return number?

	Performs `table.find(tbl, v)` to find the index of the given
	value, and then performs `TableUtil.SwapRemove` on that index.

	```lua
	local t = {"A", "B", "C", "D", "E"}
	TableUtil.SwapRemoveFirstValue(t, "C")
	print(t) --> {"A", "B", "E", "D"}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function SwapRemoveFirstValue<T>(t: { T }, v: T): number?
	local index: number? = table.find(t, v)
	if index then
		SwapRemove(t, index)
	end
	return index
end

--[=[
	@within TableUtil
	@function Map
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> newValue: any
	@return table

	Performs a map operation against the given table, which can be used to
	map new values based on the old values at given keys/indices.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Map(t, function(value)
		return value * 2
	end)
	print(t2) --> {A = 20, B = 40, C = 60}
	```
]=]
local function Map<T, M>(t: { T }, f: (T, number, { T }) -> M): { M }
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	for k, v in t do
		newT[k] = f(v, k, t)
	end
	return newT
end

--[=[
	@within TableUtil
	@function Filter
	@param tbl table
	@param predicate (value: any, key: any, tbl: table) -> keep: boolean
	@return table

	Performs a filter operation against the given table, which can be used to
	filter out unwanted values from the table.

	For example:

	```lua
	local t = {A = 10, B = 20, C = 30}
	local t2 = TableUtil.Filter(t, function(value, key)
		return value > 15
	end)
	print(t2) --> {B = 40, C = 60}
	```
]=]
local function Filter<T>(t: { T }, predicate: (T, any, { T }) -> boolean): { T }
	assert(type(t) == "table", "First argument must be a table")
	assert(type(predicate) == "function", "Second argument must be a function")
	local newT = table.create(#t)
	if #t > 0 then
		local n = 0
		for i, v in t do
			if predicate(v, i, t) then
				n += 1
				newT[n] = v
			end
		end
	else
		for k, v in t do
			if predicate(v, k, t) then
				newT[k] = v
			end
		end
	end
	return newT
end

--[=[
	@within TableUtil
	@function Reduce
	@param tbl table
	@param predicate (accumulator: any, value: any, index: any, tbl: table) -> result: any
	@return table

	Performs a reduce operation against the given table, which can be used to
	reduce the table into a single value. This could be used to sum up a table
	or transform all the values into a compound value of any kind.

	For example:

	```lua
	local t = {10, 20, 30, 40}
	local result = TableUtil.Reduce(t, function(accum, value)
		return accum + value
	end)
	print(result) --> 100
	```
]=]
local function Reduce<T, R>(t: { T }, predicate: (R, T, any, { T }) -> R, init: R): R
	assert(type(t) == "table", "First argument must be a table")
	assert(type(predicate) == "function", "Second argument must be a function")
	local result = init :: R
	if #t > 0 then
		local start = 1
		if init == nil then
			result = (t[1] :: any) :: R
			start = 2
		end
		for i = start, #t do
			result = predicate(result, t[i], i, t)
		end
	else
		local start = nil
		if init == nil then
			result = (next(t) :: any) :: R
			start = result
		end
		for k, v in next, t, start :: any? do
			result = predicate(result, v, k, t)
		end
	end
	return result
end

--[=[
	@within TableUtil
	@function Assign
	@param target table
	@param ... table
	@return table

	Copies all values of the given tables into the `target` table.

	```lua
	local t = {A = 10}
	local t2 = {B = 20}
	local t3 = {C = 30, D = 40}
	local newT = TableUtil.Assign(t, t2, t3)
	print(newT) --> {A = 10, B = 20, C = 30, D = 40}
	```
]=]
local function Assign<T>(target: { T }, ...: { any }): { T } & { any }
	local tbl = table.clone(target)
	for _, src in { ... } do
		for k, v in src do
			tbl[k] = v
		end
	end
	return tbl
end

--[=[
	@within TableUtil
	@function Extend
	@param target table
	@param extension table
	@return table

	Extends the target array with the extension array.

	```lua
	local t = {10, 20, 30}
	local t2 = {30, 40, 50}
	local tNew = TableUtil.Extend(t, t2)
	print(tNew) --> {10, 20, 30, 30, 40, 50}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Extend<T, E>(target: { T }, extension: { E }): { T } & { E }
	local tbl = table.clone(target) :: { any }
	for _, v in extension do
		table.insert(tbl, v)
	end
	return tbl
end

--[=[
	@within TableUtil
	@function Reverse
	@param tbl table
	@return table

	Reverses the array.

	```lua
	local t = {1, 5, 10}
	local tReverse = TableUtil.Reverse(t)
	print(tReverse) --> {10, 5, 1}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Reverse<T>(tbl: { T }): { T }
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1, n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end

--[=[
	@within TableUtil
	@function Shuffle
	@param tbl table
	@param rngOverride Random?
	@return table

	Shuffles the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local shuffled = TableUtil.Shuffle(t)
	print(shuffled) --> e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Shuffle<T>(tbl: { T }, rngOverride: Random?): { T }
	assert(type(tbl) == "table", "First argument must be a table")
	local shuffled = table.clone(tbl)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng
	for i = #tbl, 2, -1 do
		local j = random:NextInteger(1, i)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	return shuffled
end

--[=[
	@within TableUtil
	@function Sample
	@param tbl table
	@param sampleSize number
	@param rngOverride Random?
	@return table

	Returns a random sample of the table.

	```lua
	local t = {1, 2, 3, 4, 5, 6, 7, 8, 9}
	local sample = TableUtil.Sample(t, 3)
	print(sample) --> e.g. {6, 2, 5}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Sample<T>(tbl: { T }, size: number, rngOverride: Random?): { T }
	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(size) == "number", "Second argument must be a number")

	-- If given table is empty, just return a new empty table:
	local len = #tbl
	if len == 0 then
		return {}
	end

	local shuffled = table.clone(tbl)
	local sample = table.create(size)
	local random = if typeof(rngOverride) == "Random" then rngOverride else rng

	-- Clamp sample size to be no larger than the given table size:
	size = math.clamp(size, 1, len)

	for i = 1, size do
		local j = random:NextInteger(i, len)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end

	table.move(shuffled, 1, size, 1, sample)

	return sample
end

--[=[
	@within TableUtil
	@function Flat
	@param tbl table
	@param depth number?
	@return table

	Returns a new table where all sub-arrays have been
	bubbled up to the top. The depth at which the scan
	is performed is dictated by the `depth` parameter,
	which is set to `1` by default.

	```lua
	local t = {{10, 20}, {90, 100}, {30, 15}}
	local flat = TableUtil.Flat(t)
	print(flat) --> {10, 20, 90, 100, 30, 15}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function Flat<T>(tbl: { T }, depth: number?): { T }
	local maxDepth: number = if type(depth) == "number" then depth else 1
	local flatTbl = table.create(#tbl)
	local function Scan(t: { any }, d: number)
		for _, v in t do
			if type(v) == "table" and d < maxDepth then
				Scan(v, d + 1)
			else
				table.insert(flatTbl, v)
			end
		end
	end
	Scan(tbl, 0)
	return flatTbl
end

--[=[
	@within TableUtil
	@function FlatMap
	@param tbl table
	@param predicate (key: any, value: any, tbl: table) -> newValue: any
	@return table

	Calls `TableUtil.Map` on the given table and predicate, and then
	calls `TableUtil.Flat` on the result from the map operation.

	```lua
	local t = {10, 20, 30}
	local result = TableUtil.FlatMap(t, function(value)
		return {value, value * 2}
	end)
	print(result) --> {10, 20, 20, 40, 30, 60}
	```

	:::note Arrays only
	This function works on arrays, but not dictionaries.
]=]
local function FlatMap<T, M>(tbl: { T }, callback: (T, number, { T }) -> M): { M }
	return Flat(Map(tbl, callback))
end

--[=[
	@within TableUtil
	@function Keys
	@param tbl table
	@return table

	Returns an array with all the keys in the table.

	```lua
	local t = {A = 10, B = 20, C = 30}
	local keys = TableUtil.Keys(t)
	print(keys) --> {"A", "B", "C"}
	```

	:::caution Ordering
	The ordering of the keys is never guaranteed. If order is imperative, call
	`table.sort` on the resulting `keys` array.
	```lua
	local keys = TableUtil.Keys(t)
	table.sort(keys)
	```
]=]
local function Keys<K, V>(tbl: { [K]: V }): { K }
	local keys = table.create(#tbl)
	for k in tbl do
		table.insert(keys, k)
	end
	return keys
end

--[=[
	@within TableUtil
	@function Values
	@param tbl table
	@return table

	Returns an array with all the values in the table.

	```lua
	local t = {A = 10, B = 20, C = 30}
	local values = TableUtil.Values(t)
	print(values) --> {10, 20, 30}
	```

	:::caution Ordering
	The ordering of the values is never guaranteed. If order is imperative, call
	`table.sort` on the resulting `values` array.
	```lua
	local values = TableUtil.Values(t)
	table.sort(values)
	```
]=]
local function Values<K, V>(tbl: { [K]: V }): { V }
	local values = table.create(#tbl)
	for _, v in tbl do
		table.insert(values, v)
	end
	return values
end

--[=[
	@within TableUtil
	@function Find
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return (value: any?, key: any?)

	Performs a linear scan across the table and calls `callback` on
	each item in the array. Returns the value and key of the first
	pair in which the callback returns `true`.

	```lua
	local t = {
		{Name = "Bob", Age = 20};
		{Name = "Jill", Age = 30};
		{Name = "Ann", Age = 25};
	}

	-- Find first person who has a name starting with J:
	local firstPersonWithJ = TableUtil.Find(t, function(person)
		return person.Name:sub(1, 1):lower() == "j"
	end)

	print(firstPersonWithJ) --> {Name = "Jill", Age = 30}
	```

	:::caution Dictionary Ordering
	While `Find` can also be used with dictionaries, dictionary ordering is never
	guaranteed, and thus the result could be different if there are more
	than one possible matches given the data and callback function.
]=]
local function Find<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): (V?, K?)
	for k, v in tbl do
		if callback(v, k, tbl) then
			return v, k
		end
	end
	return nil, nil
end

--[=[
	@within TableUtil
	@function Every
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _every_
	item in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local allAboveZero = TableUtil.Every(t, function(value)
		return value > 0
	end)

	print("All above zero:", allAboveZero) --> All above zero: true
	```
]=]
local function Every<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): boolean
	for k, v in tbl do
		if not callback(v, k, tbl) then
			return false
		end
	end
	return true
end

--[=[
	@within TableUtil
	@function Some
	@param tbl table
	@param callback (value: any, index: any, tbl: table) -> boolean
	@return boolean

	Returns `true` if the `callback` also returns `true` for _at least
	one_ of the items in the table.

	```lua
	local t = {10, 20, 40, 50, 60}

	local someBelowTwenty = TableUtil.Some(t, function(value)
		return value < 20
	end)

	print("Some below twenty:", someBelowTwenty) --> Some below twenty: true
	```
]=]
local function Some<K, V>(tbl: { [K]: V }, callback: (V, K, { [K]: V }) -> boolean): boolean
	for k, v in tbl do
		if callback(v, k, tbl) then
			return true
		end
	end
	return false
end

--[=[
	@within TableUtil
	@function Truncate
	@param tbl table
	@param length number
	@return table

	Returns a new table truncated to the length of `length`. Any length
	equal or greater than the current length will simply return a
	shallow copy of the table.

	```lua
	local t = {10, 20, 30, 40, 50, 60, 70, 80}
	local tTruncated = TableUtil.Truncate(t, 3)
	print(tTruncated) --> {10, 20, 30}
	```
]=]
local function Truncate<T>(tbl: { T }, len: number): { T }
	local n = #tbl
	len = math.clamp(len, 1, n)
	return if len == n then table.clone(tbl) else table.move(tbl, 1, len, 1, table.create(len))
end

--[=[
	@within TableUtil
	@function Zip
	@param ... table
	@return (iter: (t: table, k: any) -> (key: any?, values: table?), tbl: table, startIndex: any?)

	Returns an iterator that can scan through multiple tables at the same time side-by-side, matching
	against shared keys/indices.

	```lua
	local t1 = {10, 20, 30, 40, 50}
	local t2 = {60, 70, 80, 90, 100}

	for key,values in TableUtil.Zip(t1, t2) do
		print(key, values)
	end

	--[[
		Outputs:
		1 {10, 60}
		2 {20, 70}
		3 {30, 80}
		4 {40, 90}
		5 {50, 100}
	--]]
	```
]=]
local function Zip(...: { [any]: any }): ((t: { any }, k: any) -> (any, any), { any }, any)
	assert(select("#", ...) > 0, "Must supply at least 1 table")
	local function ZipIteratorArray(all: { any }, k: number): (number?, { any }?)
		k += 1
		local values = {}
		for i, t in all do
			local v = t[k]
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local function ZipIteratorMap(all: { [any]: any }, k: any): (number?, { any }?)
		local values = {}
		for i, t in all do
			local v = next(t, k)
			if v ~= nil then
				values[i] = v
			else
				return nil, nil
			end
		end
		return k, values
	end
	local all = { ... }
	if #all[1] > 0 then
		return ZipIteratorArray, all, 0
	else
		return ZipIteratorMap, all, nil
	end
end

--[=[
	@within TableUtil
	@function Lock
	@param tbl table
	@return table

	Locks the table using `table.freeze`, as well as any
	nested tables within the given table. This will lock
	the whole deep structure of the table, disallowing any
	further modifications.

	```lua
	local tbl = {xyz = {abc = 32}}
	tbl.xyz.abc = 28 -- Works fine
	TableUtil.Lock(tbl)
	tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)
	```
]=]
local function Lock<T>(tbl: T): T
	local function Freeze(t: { [any]: any })
		for k, v in pairs(t) do
			if type(v) == "table" then
				t[k] = Freeze(v)
			end
		end
		return table.freeze(t)
	end
	return Freeze(tbl :: any)
end

--[=[
	@within TableUtil
	@function IsEmpty
	@param tbl table
	@return boolean

	Returns `true` if the given table is empty. This is
	simply performed by checking if `next(tbl)` is `nil`
	and works for both arrays and dictionaries. This is
	useful when needing to check if a table is empty but
	not knowing if it is an array or dictionary.

	```lua
	TableUtil.IsEmpty({}) -- true
	TableUtil.IsEmpty({"abc"}) -- false
	TableUtil.IsEmpty({abc = 32}) -- false
	```
]=]
local function IsEmpty(tbl: { any }): boolean
	return next(tbl) == nil
end

--[=[
	@within TableUtil
	@function EncodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONEncode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONEncode).
]=]
local function EncodeJSON(value: any): string
	return HttpService:JSONEncode(value)
end

--[=[
	@within TableUtil
	@function DecodeJSON
	@param value any
	@return string

	Proxy for [`HttpService:JSONDecode`](https://developer.roblox.com/en-us/api-reference/function/HttpService/JSONDecode).
]=]
local function DecodeJSON(str: string): any
	return HttpService:JSONDecode(str)
end

TableUtil.Copy = Copy
TableUtil.Sync = Sync
TableUtil.Reconcile = Reconcile
TableUtil.SwapRemove = SwapRemove
TableUtil.SwapRemoveFirstValue = SwapRemoveFirstValue
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.Assign = Assign
TableUtil.Extend = Extend
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.Sample = Sample
TableUtil.Flat = Flat
TableUtil.FlatMap = FlatMap
TableUtil.Keys = Keys
TableUtil.Values = Values
TableUtil.Find = Find
TableUtil.Every = Every
TableUtil.Some = Some
TableUtil.Truncate = Truncate
TableUtil.Zip = Zip
TableUtil.Lock = Lock
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON

return TableUtil
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004be</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="300">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">init.spec</string>
								<string name="ScriptGuid">{138A011B-5729-4D2A-A60A-6C70AC75AA5A}</string>
								<ProtectedString name="Source"><![CDATA[return function()
	local TableUtil = require(script.Parent)

	describe("Copy (Deep)", function()
		it("should create a deep table copy", function()
			local tbl = { a = { b = { c = { d = 32 } } } }
			local tblCopy = TableUtil.Copy(tbl, true)
			expect(tbl).never.to.equal(tblCopy)
			expect(tbl.a).never.to.equal(tblCopy.a)
			expect(tblCopy.a.b.c.d).to.equal(tbl.a.b.c.d)
		end)
	end)

	describe("Copy (Shallow)", function()
		it("should create a shallow dictionary copy", function()
			local tbl = { a = { b = { c = { d = 32 } } } }
			local tblCopy = TableUtil.Copy(tbl)
			expect(tblCopy).never.to.equal(tbl)
			expect(tblCopy.a).to.equal(tbl.a)
			expect(tblCopy.a.b.c.d).to.equal(tbl.a.b.c.d)
		end)

		it("should create a shallow array copy", function()
			local tbl = { 10, 20, 30, 40 }
			local tblCopy = TableUtil.Copy(tbl)
			expect(tblCopy).never.to.equal(tbl)
			for i, v in ipairs(tbl) do
				expect(tblCopy[i]).to.equal(v)
			end
		end)
	end)

	describe("Sync", function()
		it("should sync tables", function()
			local template = { a = 32, b = 64, c = 128, e = { h = 1 } }
			local tblSrc = { a = 32, b = 10, d = 1, e = { h = 2, n = 2 }, f = { x = 10 } }
			local tbl = TableUtil.Sync(tblSrc, template)
			expect(tbl.a).to.equal(template.a)
			expect(tbl.b).to.equal(10)
			expect(tbl.c).to.equal(template.c)
			expect(tbl.d).never.to.be.ok()
			expect(tbl.e.h).to.equal(2)
			expect(tbl.e.n).never.to.be.ok()
			expect(tbl.f).never.to.be.ok()
		end)
	end)

	describe("Reconcile", function()
		it("should reconcile table", function()
			local template = { kills = 0, deaths = 0, xp = 10, stuff = {}, stuff2 = "abc", stuff3 = { "data" } }
			local data =
				{ kills = 10, deaths = 4, stuff = { "abc", "xyz" }, extra = 5, stuff2 = { abc = 10 }, stuff3 = true }
			local reconciled = TableUtil.Reconcile(data, template)
			expect(reconciled).never.to.equal(data)
			expect(reconciled).never.to.equal(template)
			expect(reconciled.kills).to.equal(10)
			expect(reconciled.deaths).to.equal(4)
			expect(reconciled.xp).to.equal(10)
			expect(reconciled.stuff[1]).to.equal("abc")
			expect(reconciled.stuff[2]).to.equal("xyz")
			expect(reconciled.extra).to.equal(5)
			expect(type(reconciled.stuff2)).to.equal("table")
			expect(reconciled.stuff2).never.to.equal(data.stuff2)
			expect(reconciled.stuff2.abc).to.equal(10)
			expect(type(reconciled.stuff3)).to.equal("boolean")
			expect(reconciled.stuff3).to.equal(true)
		end)
	end)

	describe("SwapRemove", function()
		it("should swap remove index", function()
			local tbl = { 1, 2, 3, 4, 5 }
			TableUtil.SwapRemove(tbl, 3)
			expect(#tbl).to.equal(4)
			expect(tbl[3]).to.equal(5)
		end)
	end)

	describe("SwapRemoveFirstValue", function()
		it("should swap remove first value given", function()
			local tbl = { "hello", "world", "goodbye", "planet" }
			TableUtil.SwapRemoveFirstValue(tbl, "world")
			expect(#tbl).to.equal(3)
			expect(tbl[2]).to.equal("planet")
		end)
	end)

	describe("Map", function()
		it("should map table", function()
			local tbl = {
				{ FirstName = "John", LastName = "Doe" },
				{ FirstName = "Jane", LastName = "Smith" },
			}
			local tblMapped = TableUtil.Map(tbl, function(person)
				return person.FirstName .. " " .. person.LastName
			end)
			expect(tblMapped[1]).to.equal("John Doe")
			expect(tblMapped[2]).to.equal("Jane Smith")
		end)
	end)

	describe("Filter", function()
		it("should filter table", function()
			local tbl = { 10, 20, 30, 40, 50, 60, 70, 80, 90 }
			local tblFiltered = TableUtil.Filter(tbl, function(n)
				return (n >= 30 and n <= 60)
			end)
			expect(#tblFiltered).to.equal(4)
			expect(tblFiltered[1]).to.equal(30)
			expect(tblFiltered[#tblFiltered]).to.equal(60)
		end)
	end)

	describe("Reduce", function()
		it("should reduce table with numbers", function()
			local tbl = { 1, 2, 3, 4, 5 }
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + value
			end)
			expect(reduced).to.equal(15)
		end)

		it("should reduce table", function()
			local tbl = { { Score = 10 }, { Score = 20 }, { Score = 30 } }
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + value.Score
			end, 0)
			expect(reduced).to.equal(60)
		end)

		it("should reduce table with initial value", function()
			local tbl = { { Score = 10 }, { Score = 20 }, { Score = 30 } }
			local reduced = TableUtil.Reduce(tbl, function(accum, value)
				return accum + value.Score
			end, 40)
			expect(reduced).to.equal(100)
		end)

		it("should reduce functions", function()
			local function Square(x)
				return x * x
			end
			local function Double(x)
				return x * 2
			end
			local Func = TableUtil.Reduce({ Square, Double }, function(a, b)
				return function(x)
					return a(b(x))
				end
			end)
			local result = Func(10)
			expect(result).to.equal(400)
		end)
	end)

	describe("Assign", function()
		it("should assign tables", function()
			local target = { a = 32, x = 100 }
			local t1 = { b = 64, c = 128 }
			local t2 = { a = 10, c = 100, d = 200 }
			local tbl = TableUtil.Assign(target, t1, t2)
			expect(tbl.a).to.equal(10)
			expect(tbl.b).to.equal(64)
			expect(tbl.c).to.equal(100)
			expect(tbl.d).to.equal(200)
			expect(tbl.x).to.equal(100)
		end)
	end)

	describe("Extend", function()
		it("should extend tables", function()
			local tbl = { "a", "b", "c" }
			local extension = { "d", "e", "f" }
			local extended = TableUtil.Extend(tbl, extension)
			expect(table.concat(extended)).to.equal("abcdef")
		end)
	end)

	describe("Reverse", function()
		it("should create a table in reverse", function()
			local tbl = { 1, 2, 3 }
			local tblRev = TableUtil.Reverse(tbl)
			expect(table.concat(tblRev)).to.equal("321")
		end)
	end)

	describe("Shuffle", function()
		it("should shuffle a table", function()
			local tbl = { 1, 2, 3, 4, 5 }
			expect(function()
				TableUtil.Shuffle(tbl)
			end).never.to.throw()
		end)
	end)

	describe("Sample", function()
		it("should sample a table", function()
			local tbl = { 1, 2, 3, 4, 5 }
			local sample = TableUtil.Sample(tbl, 3)
			expect(#sample).to.equal(3)
		end)
	end)

	describe("Flat", function()
		it("should flatten table", function()
			local tbl = { 1, 2, 3, { 4, 5, { 6, 7 } } }
			local tblFlat = TableUtil.Flat(tbl, 3)
			expect(table.concat(tblFlat)).to.equal("1234567")
		end)
	end)

	describe("FlatMap", function()
		it("should map and flatten table", function()
			local tbl = { 1, 2, 3, 4, 5, 6, 7 }
			local tblFlat = TableUtil.FlatMap(tbl, function(n)
				return { n, n * 2 }
			end)
			expect(table.concat(tblFlat)).to.equal("12243648510612714")
		end)
	end)

	describe("Keys", function()
		it("should give all keys of table", function()
			local tbl = { a = 1, b = 2, c = 3 }
			local keys = TableUtil.Keys(tbl)
			expect(#keys).to.equal(3)
			expect(table.find(keys, "a")).to.be.ok()
			expect(table.find(keys, "b")).to.be.ok()
			expect(table.find(keys, "c")).to.be.ok()
		end)
	end)

	describe("Values", function()
		it("should give all values of table", function()
			local tbl = { a = 1, b = 2, c = 3 }
			local values = TableUtil.Values(tbl)
			expect(#values).to.equal(3)
			expect(table.find(values, 1)).to.be.ok()
			expect(table.find(values, 2)).to.be.ok()
			expect(table.find(values, 3)).to.be.ok()
		end)
	end)

	describe("Find", function()
		it("should find item in array", function()
			local tbl = { 10, 20, 30 }
			local item, index = TableUtil.Find(tbl, function(value)
				return (value == 20)
			end)
			expect(item).to.be.ok()
			expect(index).to.equal(2)
			expect(item).to.equal(20)
		end)

		it("should find item in dictionary", function()
			local tbl = { { Score = 10 }, { Score = 20 }, { Score = 30 } }
			local item, index = TableUtil.Find(tbl, function(value)
				return (value.Score == 20)
			end)
			expect(item).to.be.ok()
			expect(index).to.equal(2)
			expect(item.Score).to.equal(20)
		end)
	end)

	describe("Every", function()
		it("should see every value is above 20", function()
			local tbl = { 21, 40, 200 }
			local every = TableUtil.Every(tbl, function(n)
				return (n > 20)
			end)
			expect(every).to.equal(true)
		end)

		it("should see every value is not above 20", function()
			local tbl = { 20, 40, 200 }
			local every = TableUtil.Every(tbl, function(n)
				return (n > 20)
			end)
			expect(every).never.to.equal(true)
		end)
	end)

	describe("Some", function()
		it("should see some value is above 20", function()
			local tbl = { 5, 40, 1 }
			local every = TableUtil.Some(tbl, function(n)
				return (n > 20)
			end)
			expect(every).to.equal(true)
		end)

		it("should see some value is not above 20", function()
			local tbl = { 5, 15, 1 }
			local every = TableUtil.Some(tbl, function(n)
				return (n > 20)
			end)
			expect(every).never.to.equal(true)
		end)
	end)

	describe("Truncate", function()
		it("should truncate an array", function()
			local t1 = { 1, 2, 3, 4, 5 }
			local t2 = TableUtil.Truncate(t1, 3)
			expect(#t2).to.equal(3)
			expect(t2[1]).to.equal(t1[1])
			expect(t2[2]).to.equal(t1[2])
			expect(t2[3]).to.equal(t1[3])
		end)

		it("should truncate an array with out of bounds sizes", function()
			local t1 = { 1, 2, 3, 4, 5 }
			expect(function()
				TableUtil.Truncate(t1, -1)
			end).to.never.throw()
			expect(function()
				TableUtil.Truncate(t1, #t1 + 1)
			end).to.never.throw()
			local t2 = TableUtil.Truncate(t1, #t1 + 10)
			expect(#t2).to.equal(#t1)
			expect(t2).to.never.equal(t1)
		end)
	end)

	describe("Lock", function()
		it("should lock a table", function()
			local t = { abc = { xyz = { num = 32 } } }
			expect(function()
				t.abc.xyz.num = 64
			end).never.to.throw()
			local t2 = TableUtil.Lock(t)
			expect(t.abc.xyz.num).to.equal(64)
			expect(t).to.equal(t2)
			expect(function()
				t.abc.xyz.num = 10
			end).to.throw()
		end)
	end)

	describe("Zip", function()
		it("should zip arrays together", function()
			local t1 = { 1, 2, 3, 4, 5 }
			local t2 = { 9, 8, 7, 6, 5 }
			local t3 = { 1, 1, 1, 1, 1 }
			local lastIndex = 0
			for i, v in TableUtil.Zip(t1, t2, t3) do
				lastIndex = i
				expect(v[1]).to.equal(t1[i])
				expect(v[2]).to.equal(t2[i])
				expect(v[3]).to.equal(t3[i])
			end
			expect(lastIndex).to.equal(math.min(#t1, #t2, #t3))
		end)

		it("should zip arrays of different lengths together", function()
			local t1 = { 1, 2, 3, 4, 5 }
			local t2 = { 9, 8, 7, 6 }
			local t3 = { 1, 1, 1 }
			local lastIndex = 0
			for i, v in TableUtil.Zip(t1, t2, t3) do
				lastIndex = i
				expect(v[1]).to.equal(t1[i])
				expect(v[2]).to.equal(t2[i])
				expect(v[3]).to.equal(t3[i])
			end
			expect(lastIndex).to.equal(math.min(#t1, #t2, #t3))
		end)

		it("should zip maps together", function()
			local t1 = { a = 10, b = 20, c = 30 }
			local t2 = { a = 100, b = 200, c = 300 }
			local t3 = { a = 3000, b = 2000, c = 3000 }
			for k, v in TableUtil.Zip(t1, t2, t3) do
				expect(v[1]).to.equal(t1[k])
				expect(v[2]).to.equal(t2[k])
				expect(v[3]).to.equal(t3[k])
			end
		end)

		it("should zip maps of different keys together", function()
			local t1 = { a = 10, b = 20, c = 30, d = 40 }
			local t2 = { a = 100, b = 200, c = 300, z = 10 }
			local t3 = { a = 3000, b = 2000, c = 3000, x = 0 }
			for k, v in TableUtil.Zip(t1, t2, t3) do
				expect(v[1]).to.equal(t1[k])
				expect(v[2]).to.equal(t2[k])
				expect(v[3]).to.equal(t3[k])
			end
		end)
	end)

	describe("IsEmpty", function()
		it("should detect that table is empty", function()
			local tbl = {}
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(true)
		end)

		it("should detect that array is not empty", function()
			local tbl = { 10, 20, 30 }
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(false)
		end)

		it("should detect that dictionary is not empty", function()
			local tbl = { a = 10, b = 20, c = 30 }
			local isEmpty = TableUtil.IsEmpty(tbl)
			expect(isEmpty).to.equal(false)
		end)
	end)

	describe("JSON", function()
		it("should encode json", function()
			local tbl = { hello = "world" }
			local json = TableUtil.EncodeJSON(tbl)
			expect(json).to.equal('{"hello":"world"}')
		end)

		it("should decode json", function()
			local json = '{"hello":"world"}'
			local tbl = TableUtil.DecodeJSON(json)
			expect(tbl).to.be.a("table")
			expect(tbl.hello).to.equal("world")
		end)
	end)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004bf</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="301">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{F4240141-79A3-4C80-8A7D-FA72AC4A8201}</string>
								<ProtectedString name="Source"><![CDATA[return {
	package = {
		authors = {"Stephen Leitnick"},
		description = "Table utility functions",
		license = "MIT",
		name = "sleitnick/table-util",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "1.2.1",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c0</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF75671F9B1C84D7FABEBFA6D4B42030F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">ukendio_jecs@0.9.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002540</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXBD69D197D8CB40CABE466A7AEA1B88A7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">jecs</string>
							<string name="ScriptGuid">{6435F2E9-60FC-4F67-94BA-B58ADA74AA5D}</string>
							<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict
--draft 4

type i53 = number
type i24 = number

type Ty = { Entity }
type ArchetypeId = number

type Column = { any }

type Map<K, V> = { [K]: V }

export type Archetype = {
	id: number,
	types: Ty,
	type: string,
	entities: { Entity },
	columns: { Column },
	columns_map: { [Id]: Column }
}

export type QueryInner = {
	compatible_archetypes: { Archetype },
	ids: { Id },
	filter_with: { Id },
	filter_without: { Id },
	next: () -> (Entity, ...any),
	world: World,
}

export type Entity<T = any> ={ __T: T }
export type Id<T = any> = { __T: T }
export type Pair<P, O> = Id<P>
type ecs_id_t<T = unknown> = Id<T> | Pair<T, "Tag"> | Pair<"Tag", T>
export type Item<T...> = (self: Query<T...>) -> (Entity, T...)
export type Iter<T...> = (query: Query<T...>) -> () -> (Entity, T...)

export type Query<T...> = typeof(setmetatable(
	{} :: {
		iter: Iter<T...>,
		with: ((Query<T...>, ...Id) -> Query<T...>),
		without: ((Query<T...>, ...Id) -> Query<T...>),
		archetypes: (self: Query<T...>) -> { Archetype },
		cached: (self: Query<T...>) -> Query<T...>,
		ids: { Id<any> },
		filter_with: { Id<any> }?,
		filter_without: { Id<any> }?
		-- world: World
	},
	{} :: {
		__iter: Iter<T...>,
	}
))

type QueryArm<T...> = () -> ()

export type Observer = {
	callback: (archetype: Archetype) -> (),
	query: QueryInner,
}

type query = {
	compatible_archetypes: { archetype },
	ids: { i53 },
	filter_with: { i53 },
	filter_without: { i53 },
	next: () -> (i53, ...any),
	world: world,
}

export type observer = {
	callback: (archetype: archetype) -> (),
	query: query,
}

type archetype = {
	id: number,
	types: { i53 },
	type: string,
	entities: { i53 },
	columns: { Column },
	columns_map: { [i53]: Column }
}

type componentrecord = {
	component: i53,
	records: { [number]: number },
	counts: { [i53]: number },
	flags: number,
	size: number,

	on_add: ((entity: i53, id: i53, value: any, oldarchetype: archetype) -> ())?,
	on_change: ((entity: i53, id: i53, value: any, oldarchetype: archetype) -> ())?,
	on_remove: ((entity: i53, id: i53) -> ())?,

	wildcard_pairs: { [number]: componentrecord },
}
type record = {
	archetype: archetype,
	row: number,
	dense: i24,
}
type entityindex = {
	dense_array: Map<number, i53>,
	sparse_array: Map<i24, record>,
	alive_count: number,
	max_id: number,
	range_begin: number?,
	range_end: number?,
}
type world = {
	archetype_edges: Map<i53, Map<i53, archetype>>,
	archetype_index: { [string]: archetype },
	archetypes: { [i53]: archetype },
	component_index: Map<i53, componentrecord>,
	entity_index: entityindex,
	ROOT_ARCHETYPE: archetype,

	max_component_id: number,
	max_archetype_id: number,

	observable: Map<i53, Map<i53, { Observer }>>,

	range: (self: world, range_begin: number, range_end: number?) -> (),
	entity: (self: world, id: i53?) -> i53,
	component: (self: world) -> i53,
	target: (self: world, id: i53, relation: i53, index: number?) -> i53?,
	delete: (self: world, id: i53) -> (),
	add: (self: world, id: i53, component: i53) -> (),
	set: (self: world, id: i53, component: i53, data: any) -> (),
	cleanup: (self: world) -> (),
	clear: (self: world, entity: i53) -> (),
	remove: (self: world, id: i53, component: i53) -> (),
	get: (world, ...i53) -> (),
	has: (world, ...i53) -> boolean,
	parent: (self: world, entity: i53) -> i53?,
	contains: (self: world, entity: i53) -> boolean,
	exists: (self: world, entity: i53) -> boolean,
	each: (self: world, id: i53) -> () -> i53,
	children: (self: world, id: i53) -> () -> i53,
	query: (world, ...i53) -> Query<...any>,

	added: (world, i53, (e: i53, id: i53, value: any?) -> ()) -> () -> (),
	changed: (world, i53, (e: i53, id: i53, value: any?) -> ()) -> () -> (),
	removed: (world, i53, (e: i53, id: i53) -> ()) -> () -> (),
}

export type World = {
	archetype_edges: Map<number, Map<Entity, Archetype>>,
	archetype_index: { [string]: Archetype },
	archetypes: Archetypes,
	component_index: ComponentIndex,
	entity_index: EntityIndex,
	ROOT_ARCHETYPE: Archetype,

	max_component_id: number,
	max_archetype_id: number,

	observable: Map<Id, Map<Id, { Observer }>>,

	added: <T>(World, Entity<T>, (e: Entity, id: Id<T>, value: T, oldarchetype: Archetype) -> ()) -> () -> (),
	removed: <T>(World, Entity<T>, (e: Entity, id: Id<T>) -> ()) -> () -> (),
	changed:  <T>(World, Entity<T>, (e: Entity, id: Id<T>, value: T, oldarchetype: Archetype) -> ()) -> () -> (),

	--- Enforce a check on entities to be created within desired range
	range: (self: World, range_begin: number, range_end: number?) -> (),

	--- Creates a new entity
	entity: <T>(self: World, id: (number | Entity<T>)?) -> Entity<T>,
	--- Creates a new entity located in the first 256 ids.
	--- These should be used for static components for fast access.
	component: <T>(self: World) -> Entity<T>,
	--- Gets the target of an relationship. For example, when a user calls
	--- `world:target(id, ChildOf(parent), 0)`, you will obtain the parent entity.
	target: <T, a>(self: World, id: Entity<T>, relation: Id<a>, index: number?) -> Entity?,
	--- Deletes an entity and all it's related components and relationships.
	delete: <T>(self: World, id: Entity<T>) -> (),

	--- Adds a component to the entity with no value
	add: <T, a>(self: World, id: Entity<T>, component: Id<a>) -> (),
	--- Assigns a value to a component on the given entity
	set: <T, a>(self: World, id: Entity<T>, component: Id<a>, data: a) -> (),

	cleanup: (self: World) -> (),

	-- Removes all components from the entity
	clear: (self: World, entity: Entity) -> (),
	--- Removes a component from the given entity
	remove: <T, a>(self: World, id: Entity<T>, component: Id<a>) -> (),
	--- Retrieves the value of up to 4 components. These values may be nil.
	get: & (<T, a>(World, Entity<T>, Id<a>) -> a?)
		& (<T, a, b>(World, Entity<T>, Id<a>, Id<b>) -> (a?, b?))
		& (<T, a, b, c>(World, Entity<T>, Id<a>, Id<b>, Id<c>) -> (a?, b?, c?))
		& (<T, a, b, c, d>(World, Entity<T>, Id<a>, Id<b>, Id<c>, Id<d>) -> (a?, b?, c?, d?)),

	--- Returns whether the entity has the ID.
	has: (<T, a>(World, Entity<T>, Id<a>) -> boolean)
		& (<T, a, b>(World, Entity<T>, Id<a>, Id<a>) -> boolean)
		& (<T, a, b, c>(World, Entity<T>, Id<a>, Id<b>, Id<c>) -> boolean)
		& <T, a, b, c, d>(World, Entity<T>, Id<a>, Id<b>, Id<c>, Id<d>) -> boolean,

	--- Get parent (target of ChildOf relationship) for entity. If there is no ChildOf relationship pair, it will return nil.
	parent: <T>(self: World, entity: Entity<T>) -> Entity?,

	--- Checks if the world contains the given entity
	contains: <T>(self: World, entity: Entity<T>) -> boolean,

	--- Checks if the entity exists
	exists: <T>(self: World, entity: Entity<T>) -> boolean,

	each: <T>(self: World, id: Id<T>) -> () -> Entity,

	children: <T>(self: World, id: Id<T>) -> () -> Entity,

	--- Searches the world for entities that match a given query
	query: ((World) -> Query<nil>)
		& (<A>(World, Id<A>) -> Query<A>)
		& (<A, B>(World, Id<A>, Id<B>) -> Query<A, B>)
		& (<A, B, C>(World, Id<A>, Id<B>, Id<C>) -> Query<A, B, C>)
		& (<A, B, C, D>(World, Id<A>, Id<B>, Id<C>, Id<D>) -> Query<A, B, C, D>)
		& (<A, B, C, D, E>(World, Id<A>, Id<B>, Id<C>, Id<D>, Id<E>) -> Query<A, B, C, D, E>)
		& (<A, B, C, D, E, F>(World, Id<A>, Id<B>, Id<C>, Id<D>, Id<E>, Id<F>) -> Query<A, B, C, D, E, F>)
		& (<A, B, C, D, E, F, G>(
			World,
			Id<A>,
			Id<B>,
			Id<C>,
			Id<D>,
			Id<E>,
			Id<F>,
			Id<G>
		) -> Query<A, B, C, D, E, F, G>)
		& (<A, B, C, D, E, F, G, H>(
			World,
			Id<A>,
			Id<B>,
			Id<C>,
			Id<D>,
			Id<E>,
			Id<F>,
			Id<G>,
			Id<H>,
			...Id<any>
		) -> Query<A, B, C, D, E, F, G, H>),
}

export type Record = {
	archetype: Archetype,
	row: number,
	dense: i24,
}
export type ComponentRecord = {
	records: { [i24]: number },
	counts: { [i24]: number },
	flags: number,
	size: number,

	on_add: (<T>(entity: Entity, id: Entity<T>, value: T, oldarchetype: Archetype) -> ())?,
	on_change: (<T>(entity: Entity, id: Entity<T>, value: T, oldArchetype: Archetype) -> ())?,
	on_remove: ((entity: Entity, id: Entity) -> ())?,
}
export type ComponentIndex = Map<Id, ComponentRecord>
export type Archetypes = { [i24]: Archetype }

export type EntityIndex = {
	dense_array: Map<number, Entity>,
	sparse_array: Map<i24, Record>,
	alive_count: number,
	max_id: number,
	range_begin: number?,
	range_end: number?,
}

-- stylua: ignore start

local ECS_ENTITY_MASK =       bit32.lshift(1, 24)
local ECS_GENERATION_MASK =   bit32.lshift(1, 16)
local ECS_PAIR_OFFSET = 	                 2^48

local ECS_ID_DELETE =                 	   0b0001
local ECS_ID_IS_TAG =                 	   0b0010
local ECS_ID_IS_EXCLUSIVE =                0b0100
local ECS_ID_MASK =                   	   0b0000

local HI_COMPONENT_ID =                       256
local EcsOnAdd =             HI_COMPONENT_ID +  1
local EcsOnRemove =          HI_COMPONENT_ID +  2
local EcsOnChange =          HI_COMPONENT_ID +  3
local EcsWildcard =          HI_COMPONENT_ID +  4
local EcsChildOf =           HI_COMPONENT_ID +  5
local EcsComponent =         HI_COMPONENT_ID +  6
local EcsOnDelete =          HI_COMPONENT_ID +  7
local EcsOnDeleteTarget =    HI_COMPONENT_ID +  8
local EcsDelete =            HI_COMPONENT_ID +  9
local EcsRemove =            HI_COMPONENT_ID + 10
local EcsName =              HI_COMPONENT_ID + 11
local EcsOnArchetypeCreate = HI_COMPONENT_ID + 12
local EcsOnArchetypeDelete = HI_COMPONENT_ID + 13
local EcsExclusive =         HI_COMPONENT_ID + 14
local EcsRest =              HI_COMPONENT_ID + 15

local NULL_ARRAY = table.freeze({}) :: Column
local NULL = newproxy(false)

local ECS_INTERNAL_ERROR = [[
	This is an internal error, please file a bug report via the following link:

	https://github.com/Ukendio/jecs/issues/new?template=BUG-REPORT.md
]]

local function ecs_assert(condition, msg: string?)
	if not condition then
		error(msg)
	end
end

local ecs_metadata: Map<i53, Map<i53, any>> = {}
local ecs_max_component_id = 0
local ecs_max_tag_id = EcsRest

local function ECS_COMPONENT()
	ecs_max_component_id += 1
	if ecs_max_component_id > HI_COMPONENT_ID then
		error("Too many components")
	end
	return ecs_max_component_id
end

local function ECS_TAG()
	ecs_max_tag_id += 1
	return ecs_max_tag_id
end

local function ECS_META(id: i53, ty: i53, value: any?)
	local bundle = ecs_metadata[id]
	if bundle == nil then
		bundle = {} :: Map<i53, any>
		ecs_metadata[id] = bundle
	end
	bundle[ty] = if value == nil then NULL else value
end

local function ECS_META_RESET()
	ecs_metadata = {}
	ecs_max_component_id = 0
	ecs_max_tag_id = EcsRest
end

local function ECS_COMBINE(id: number, generation: number): i53
	return id + (generation * ECS_ENTITY_MASK)
end

local function ECS_IS_PAIR(e: number): boolean
	return e > ECS_PAIR_OFFSET
end

local function ECS_GENERATION_INC(e: i53): i53
	if e > ECS_ENTITY_MASK then
		local id = e % ECS_ENTITY_MASK
		local generation = e // ECS_ENTITY_MASK

		local next_gen = generation + 1
		if next_gen >= ECS_GENERATION_MASK then
			return id
		end

		return ECS_COMBINE(id, next_gen)
	end
	return ECS_COMBINE(e, 1)
end

local function ECS_ENTITY_T_LO(e: i53): i24
	return e % ECS_ENTITY_MASK
end

local function ECS_ID(e: i53)
	return e % ECS_ENTITY_MASK
end

local function ECS_GENERATION(e: i53)
	return e // ECS_ENTITY_MASK
end

local function ECS_ENTITY_T_HI(e: i53): i24
	return e // ECS_ENTITY_MASK
end

local function ECS_PAIR(pred: i53, obj: i53): i53
	pred %= ECS_ENTITY_MASK
	obj %= ECS_ENTITY_MASK

	return obj + (pred * ECS_ENTITY_MASK) + ECS_PAIR_OFFSET
end

local function ECS_PAIR_FIRST(e: i53): i24
	return (e - ECS_PAIR_OFFSET) // ECS_ENTITY_MASK
end

local function ECS_PAIR_SECOND(e: i53): i24
	return (e - ECS_PAIR_OFFSET) % ECS_ENTITY_MASK
end

local function entity_index_try_get_any(
	entity_index: entityindex,
	entity: i53
): record?
	local r = entity_index.sparse_array[ECS_ID(entity)]

	if not r or r.dense == 0 then
		return nil
	end

	return r
end

local function entity_index_try_get(entity_index: entityindex, entity: i53): record?
	local r = entity_index_try_get_any(entity_index, entity)
	if r then
		local r_dense = r.dense
		if r_dense > entity_index.alive_count then
			return nil
		end
		if entity_index.dense_array[r_dense] ~= entity then
			return nil
		end
	end
	return r
end

local function entity_index_try_get_fast(entity_index: entityindex, entity: i53): record?
	local r = entity_index_try_get_any(entity_index, entity)
	if r then
		local r_dense = r.dense
		-- if r_dense > entity_index.alive_count then
		-- 	return nil
		-- end
		if entity_index.dense_array[r_dense] ~= entity then
			return nil
		end
	end
	return r
end

local function entity_index_is_alive(entity_index: entityindex, entity: i53): boolean
	return entity_index_try_get(entity_index, entity) ~= nil
end

local function entity_index_get_alive(entity_index: entityindex, entity: i53): i53?
	local r = entity_index_try_get_any(entity_index, entity :: number)
	if r then
		return entity_index.dense_array[r.dense]
	end
	return nil
end

local function ecs_get_alive(world: world, entity: i53): i53
	if entity == 0 then
		return 0
	end

	local eindex = world.entity_index

	if entity_index_is_alive(eindex, entity) then
		return entity
	end

	if (entity :: number) > ECS_ENTITY_MASK then
		return 0
	end

	local current = entity_index_get_alive(eindex, entity)
	if not current or not entity_index_is_alive(eindex, current) then
		return 0
	end

	return current
end

local ECS_INTERNAL_ERROR_INCOMPATIBLE_ENTITY = "Entity is outside range"

local function ENTITY_INDEX_NEW_ID(entity_index: entityindex): i53
	local dense_array = entity_index.dense_array
	local alive_count = entity_index.alive_count
	local sparse_array = entity_index.sparse_array
	local max_id = entity_index.max_id

	if alive_count < max_id then
		alive_count += 1
		entity_index.alive_count = alive_count
		local id = dense_array[alive_count]
		return id
	end

	local id = max_id + 1
	local range_end = entity_index.range_end
	ecs_assert(range_end == nil or id < range_end, ECS_INTERNAL_ERROR_INCOMPATIBLE_ENTITY)

	entity_index.max_id = id
	alive_count += 1
	entity_index.alive_count = alive_count
	dense_array[alive_count] = id
	sparse_array[id] = { dense = alive_count } :: record

	return id
end

local function ecs_pair_first(world: world, e: i53)
	local pred = ECS_PAIR_FIRST(e)
	return ecs_get_alive(world, pred)
end

local function ecs_pair_second(world: world, e: i53)
	local obj = ECS_PAIR_SECOND(e)
	return ecs_get_alive(world, obj)
end

local function query_match(query: query, archetype: archetype)
	local columns_map = archetype.columns_map
	local with = query.filter_with

	for _, id in with do
		if not columns_map[id] then
			return false
		end
	end

	local without = query.filter_without
	if without then
		for _, id in without do
			if columns_map[id] then
				return false
			end
		end
	end

	return true
end

local function find_observers(world: world, event: i53, component: i53): { observer }?
	local cache = world.observable[event]
	if not cache then
		return nil
	end
	return cache[component] :: any
end

local function archetype_move(
	entity_index: entityindex,
	entity: i53,
	to: archetype,
	dst_row: i24,
	from: archetype,
	src_row: i24
)
	local src_columns = from.columns
	local dst_entities = to.entities
	local src_entities = from.entities

	local last = #src_entities
	local id_types = from.types
	local columns_map = to.columns_map

	if src_row ~= last then
		-- If the entity is the last row in the archetype then swapping it would be meaningless.

		for i, column in src_columns do
			if column == NULL_ARRAY then
				continue
			end
			-- Retrieves the new column index from the source archetype's record from each component
			-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
			local dst_column = columns_map[id_types[i]]

			-- Sometimes target column may not exist, e.g. when you remove a component.
			if dst_column then
				dst_column[dst_row] = column[src_row]
			end

			-- Swap rempves columns to ensure there are no holes in the archetype.
			column[src_row] = column[last]
			column[last] = nil
		end


		-- Move the entity from the source to the destination archetype.
		-- Because we have swapped columns we now have to update the records
		-- corresponding to the entities' rows that were swapped.

		local e2 = src_entities[last]
		src_entities[src_row] = e2

		local sparse_array = entity_index.sparse_array
		local record2 = sparse_array[ECS_ID(e2)]
		record2.row = src_row
	else
		for i, column in src_columns do
			if column == NULL_ARRAY then
				continue
			end
			-- Retrieves the new column index from the source archetype's record from each component
			-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
			local dst_column = columns_map[id_types[i]]

			-- Sometimes target column may not exist, e.g. when you remove a component.
			if dst_column then
				dst_column[dst_row] = column[src_row]
			end

			column[last] = nil
		end
	end

	src_entities[last] = nil
	dst_entities[dst_row] = entity
end

local function archetype_append(
	entity: i53,
	archetype: archetype
): number
	local entities = archetype.entities
	local length = #entities + 1
	entities[length] = entity
	return length
end

local function new_entity(
	entity: i53,
	record: record,
	archetype: archetype
): record
	local row = archetype_append(entity, archetype)
	record.archetype = archetype
	record.row = row
	return record
end

local function entity_move(
	entity_index: entityindex,
	entity: i53,
	record: record,
	to: archetype
)
	local sourceRow = record.row
	local from = record.archetype
	local dst_row = archetype_append(entity, to)
	archetype_move(entity_index, entity, to, dst_row, from, sourceRow)
	record.archetype = to
	record.row = dst_row
end

local function hash(arr: { i53 }): string
	return table.concat(arr, "_")
end

local function fetch(id: i53, columns_map: { [i53]: Column }, row: number): any
	local column = columns_map[id]

	if not column then
		return nil
	end

	return column[row]
end

local function WORLD_GET(world: world, entity: i53,
	a: i53, b: i53?, c: i53?, d: i53?, e: i53?): ...any
	local record = entity_index_try_get(world.entity_index, entity)
	if not record then
		return nil
	end

	local archetype = record.archetype
	if not archetype then
		return nil
	end

	local columns_map = archetype.columns_map
	local row = record.row

	local va = fetch(a, columns_map, row)

	if not b then
		return va
	elseif not c then
		return va, fetch(b, columns_map, row)
	elseif not d then
		return va, fetch(b, columns_map, row), fetch(c, columns_map, row)
	elseif not e then
		return va, fetch(b, columns_map, row), fetch(c, columns_map, row), fetch(d, columns_map, row)
	else
		error("args exceeded")
	end
end

local function WORLD_HAS(world: world, entity: i53, id: i53): boolean
	local record = entity_index_try_get(world.entity_index, entity)
	if not record then
		return false
	end

	local archetype = record.archetype
	if not archetype then
		return false
	end

	return archetype.columns_map[id] ~= nil
end

local function WORLD_TARGET(world: world, entity: i53, relation: i53, index: number?): i53?
	local entity_index = world.entity_index
	local record = entity_index_try_get(entity_index, entity)
	if not record then
		return nil
	end

	local archetype = record.archetype
	if not archetype then
		return nil
	end

	local r = ECS_PAIR(relation, EcsWildcard)
	local idr = world.component_index[r]

	if not idr then
		return nil
	end

	local archetype_id = archetype.id
	local count = idr.counts[archetype_id]
	if not count then
		return nil
	end

	local nth = index or 0

	if nth >= count then
		return nil
	end

	nth = archetype.types[nth + idr.records[archetype_id]]

	if not nth then
		return nil
	end

	return entity_index_get_alive(entity_index,
	    ECS_PAIR_SECOND(nth :: number))
end

local function ECS_ID_IS_WILDCARD(e: i53): boolean
	local first = ECS_ENTITY_T_HI(e)
	local second = ECS_ENTITY_T_LO(e)
	return first == EcsWildcard or second == EcsWildcard
end

local function id_record_get(world: World, id: Entity): ComponentRecord?
	local component_index = world.component_index
	local idr: ComponentRecord = component_index[id]

	if idr then
		return idr
	end

	return nil
end

local function id_record_create(
	world: world,
	component_index: Map<i53, componentrecord>,
	id: i53
): componentrecord
	local entity_index = world.entity_index
	local flags = ECS_ID_MASK
	local relation = id
	local target = 0
	local is_pair = ECS_IS_PAIR(id :: number)

	local has_delete = false
	local is_exclusive = false

	if is_pair then
		relation = entity_index_get_alive(entity_index, ECS_PAIR_FIRST(id)) :: i53
		ecs_assert(relation and entity_index_is_alive(
			entity_index, relation), ECS_INTERNAL_ERROR)
		target = entity_index_get_alive(entity_index, ECS_PAIR_SECOND(id)) :: i53
		ecs_assert(target and entity_index_is_alive(
			entity_index, target), ECS_INTERNAL_ERROR)

		local cleanup_policy_target = WORLD_TARGET(world, relation, EcsOnDeleteTarget, 0)

		if cleanup_policy_target == EcsDelete then
			has_delete = true
		end

		if WORLD_HAS(world, relation, EcsExclusive) then
			is_exclusive = true
		end
	end

	local cleanup_policy = WORLD_TARGET(world, relation, EcsOnDelete, 0)

	if cleanup_policy == EcsDelete then
		has_delete = true
	end

	local on_add, on_change, on_remove = WORLD_GET(world,
		relation, EcsOnAdd, EcsOnChange, EcsOnRemove)

	local is_tag = not WORLD_HAS(world,
		relation, EcsComponent)

	if is_tag and is_pair then
		is_tag = not WORLD_HAS(world, target, EcsComponent)
	end

	flags = bit32.bor(
		flags,
		if has_delete then ECS_ID_DELETE else 0,
		if is_tag then ECS_ID_IS_TAG else 0,
		if is_exclusive then ECS_ID_IS_EXCLUSIVE else 0
	)

	local idr = {
		size = 0,
		records = {},
		counts = {},
		flags = flags,

		on_add = on_add,
		on_change = on_change,
		on_remove = on_remove,
	} :: componentrecord

	component_index[id] = idr

	return idr
end

local function id_record_ensure(world: world, id: i53): componentrecord
	local component_index = world.component_index
	local idr: componentrecord? = component_index[id]

	if idr then
		return idr
	end

	return id_record_create(world, component_index, id)
end

local function archetype_append_to_records(
	idr: componentrecord,
	archetype_id: number,
	columns_map: { [i53]: Column },
	id: i53,
	index: number,
	column: Column
)
	local idr_records = idr.records
	local idr_counts = idr.counts
	local tr = idr_records[archetype_id]
	if not tr then
		idr_records[archetype_id] = index
		idr_counts[archetype_id] = 1
		columns_map[id] = column
	else
		local max_count = idr_counts[archetype_id] + 1
		idr_counts[archetype_id] = max_count
	end
end

local function archetype_create(world: world, id_types: { i53 }, ty, prev: i53?): archetype
	local archetype_id = (world.max_archetype_id :: number) + 1
	world.max_archetype_id = archetype_id

	local length = #id_types
	local columns = (table.create(length) :: any) :: { Column }

	local columns_map: { [i53]: Column } = {}

	local archetype: archetype = {
		columns = columns,
		columns_map = columns_map,
		entities = {},
		id = archetype_id,
		type = ty,
		types = id_types
	}

	for i, component_id in archetype.types do
		local idr = id_record_ensure(world, component_id)
		idr.size += 1
		local is_tag = bit32.btest(idr.flags, ECS_ID_IS_TAG)
		local column = if is_tag then NULL_ARRAY else {}
		columns[i] = column

		archetype_append_to_records(idr, archetype_id, columns_map, component_id :: number, i, column)

		if ECS_IS_PAIR(component_id) then
			local relation = ECS_PAIR_FIRST(component_id)
			local object = ECS_PAIR_SECOND(component_id)

			local r = ECS_PAIR(relation, EcsWildcard)
			local idr_r = id_record_ensure(world, r)

			idr_r.size += 1
			archetype_append_to_records(idr_r, archetype_id, columns_map, r, i, column)
			local idr_r_wc_pairs = idr_r.wildcard_pairs
			if not idr_r_wc_pairs then
				idr_r_wc_pairs = {} :: {[i53]: componentrecord }
				idr_r.wildcard_pairs = idr_r_wc_pairs
			end
			idr_r_wc_pairs[component_id] = idr

			local t = ECS_PAIR(EcsWildcard, object)
			local idr_t = id_record_ensure(world, t)

			idr_t.size += 1
			archetype_append_to_records(idr_t, archetype_id, columns_map, t, i, column)
		end
	end

	world.archetype_index[ty] = archetype
	world.archetypes[archetype_id] = archetype
	world.archetype_edges[archetype_id] = {} :: Map<i53, archetype>

	for id in columns_map do
		local observer_list = find_observers(world, EcsOnArchetypeCreate, id)
		if not observer_list then
			continue
		end
		for _, observer in observer_list do
			if query_match(observer.query, archetype) then
				observer.callback(archetype::any)
			end
		end
	end

	return archetype
end

local function world_range(world: world, range_begin: number, range_end: number?)
	local entity_index = world.entity_index

	entity_index.range_begin = range_begin
	entity_index.range_end = range_end

	local max_id = entity_index.max_id

	if range_begin > max_id then
		local dense_array = entity_index.dense_array
		local sparse_array = entity_index.sparse_array

		for i = max_id + 1, range_begin do
			dense_array[i] = i
			sparse_array[i] = {
				dense = 0
			} :: record
		end
		entity_index.max_id = range_begin - 1
		entity_index.alive_count = range_begin - 1
	end
end

local function archetype_ensure(world: world, id_types: { i53 }): archetype
	if #id_types < 1 then
		return world.ROOT_ARCHETYPE
	end

	local ty = hash(id_types)
	local archetype = world.archetype_index[ty]
	if archetype then
		return archetype
	end

	return archetype_create(world, id_types, ty)
end

local function find_insert(id_types: { i53 }, toAdd: i53): number
	for i, id in id_types do
		if id == toAdd then
			return -1
		end
		if id > toAdd then
			return i
		end
	end
	return #id_types + 1
end

local function find_archetype_without(
	world: world,
	node: archetype,
	id: i53
): archetype
	local id_types = node.types
	local at = table.find(id_types, id)

	local dst = table.clone(id_types)
	table.remove(dst, at)

	return archetype_ensure(world, dst)
end


local function create_edge_for_remove(
	world: world,
	node: archetype,
	edge: Map<i53, archetype>,
	id: i53
): archetype
	local to = find_archetype_without(world, node, id)
	local edges = world.archetype_edges
	local archetype_id = node.id
	edges[archetype_id][id] = to
	edges[to.id][id] = node
	return to
end

local function archetype_traverse_remove(
	world: world,
	id: i53,
	from: archetype
): archetype
	local edges = world.archetype_edges
	local edge = edges[from.id]

	local to: archetype = edge[id]
	if to == nil then
		to = find_archetype_without(world, from, id)
		edge[id] = to
		edges[to.id][id] = from
	end

	return to
end

local function find_archetype_with(
	world: world,
	id: i53,
	from: archetype
): archetype
	local id_types = from.types
	local dst = table.clone(id_types)

	local at = find_insert(id_types :: { number } , id :: number)

	table.insert(dst, at, id)

	return archetype_ensure(world, dst)
end

local function archetype_traverse_add(
	world: world,
	id: i53,
	from: archetype
): archetype
	from = from or world.ROOT_ARCHETYPE
	if from.columns_map[id] then
		return from
	end
	local edges = world.archetype_edges
	local edge = edges[from.id]

	local to = edge[id]
	if not to then
		to = find_archetype_with(world, id, from)
		edge[id] = to
		edges[to.id][id] = from
	end

	return to
end

local function archetype_fast_delete_last(columns: { Column }, column_count: number)
	for i, column in columns do
		if column ~= NULL_ARRAY then
			column[column_count] = nil
		end
	end
end

local function archetype_fast_delete(columns: { Column }, column_count: number, row: number)
	for i, column in columns do
		if column ~= NULL_ARRAY then
			column[row] = column[column_count]
			column[column_count] = nil
		end
	end
end

local function archetype_delete(world: world, archetype: archetype, row: number)
	local entity_index = world.entity_index
	local columns = archetype.columns
	local entities = archetype.entities
	local column_count = #entities
	local last = #entities
	local move = entities[last]
	-- We assume first that the entity is the last in the archetype

	if row ~= last then
		local record_to_move = entity_index_try_get_any(entity_index, move)
		if record_to_move then
			record_to_move.row = row
		end

		entities[row] = move
	end

	entities[last] = nil :: any

	if row == last then
		archetype_fast_delete_last(columns, column_count)
	else
		archetype_fast_delete(columns, column_count, row)
	end
end


local function archetype_destroy(world: world, archetype: archetype)
	if archetype == world.ROOT_ARCHETYPE then
		return
	end

	local component_index = world.component_index
	local archetype_edges = world.archetype_edges
	local edges = archetype_edges[archetype.id]
	for id, node in edges do
		archetype_edges[node.id][id] = nil
		edges[id] = nil
	end

	local archetype_id = archetype.id
	world.archetypes[archetype_id] = nil :: any
	world.archetype_index[archetype.type] = nil :: any
	local columns_map = archetype.columns_map

	for id in columns_map do
		local idr = component_index[id]
		idr.records[archetype_id] = nil :: any
		idr.counts[archetype_id] = nil
		idr.size -= 1
		if idr.size == 0 then
			component_index[id] = nil :: any
		end
		local observer_list = find_observers(world, EcsOnArchetypeDelete, id)
		if not observer_list then
			continue
		end
		for _, observer in observer_list do
			if query_match(observer.query, archetype) then
				observer.callback(archetype::any)
			end
		end
	end
end

local function NOOP() end

local function query_archetypes(query: query)
	local compatible_archetypes = query.compatible_archetypes
	if not compatible_archetypes then
		compatible_archetypes = {}
		query.compatible_archetypes = compatible_archetypes

		local world = query.world
		local archetypes = world.archetypes

		local component_index = world.component_index

		local idr: componentrecord?
		local with = query.filter_with
		for _, id in with do
			local map = component_index[id]
			if not map then
				continue
			end

			if idr == nil or (map.size :: number) < (idr.size :: number) then
				idr = map
			end
		end

		if idr == nil then
			return compatible_archetypes
		end

		local without = query.filter_without

		for archetype_id in idr.records do
			local archetype = archetypes[archetype_id]
			local columns_map = archetype.columns_map
			local skip = false
			for _, component in with do
				if not columns_map[component] then
					skip = true
					break
				end
			end
			if skip then
				continue
			end
			if without then
				for _, component in without do
					if columns_map[component] then
						skip = true
						break
					end
				end
			end

			if skip then
				continue
			end

			table.insert(compatible_archetypes, archetype)
		end
	end
	return compatible_archetypes
end

local function query_with(query: query, ...: i53)
	local ids = query.ids
	local with = { ... }
	table.move(ids, 1, #ids, #with + 1, with)
	query.filter_with = with
	return query
end

local function query_without(query: query, ...: i53)
	local without = { ... }
	query.filter_without = without
	return query
end

local function query_iter_init(query: QueryInner): () -> (number, ...any)
	local world_query_iter_next

	local compatible_archetypes = query_archetypes(query::any) :: { Archetype }
	local lastArchetype = 1
	local archetype = compatible_archetypes[1]
	if not archetype then
		return NOOP :: () -> (number, ...any)
	end
	local entities = archetype.entities
	local i = #entities
	local columns_map = archetype.columns_map

	local ids = query.ids
	local A, B, C, D, E, F, G, H, I = unpack(ids :: { Id })
	local a: Column, b: Column, c: Column, d: Column
	local e: Column, f: Column, g: Column, h: Column

	if not A then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
			end
			i -= 1
			return entity
		end
		query.next = world_query_iter_next
		return world_query_iter_next
	elseif not B then
		a = columns_map[A]
	elseif not C then
		a = columns_map[A]
		b = columns_map[B]
	elseif not D then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
	elseif not E then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
	elseif not F then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
	elseif not G then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
	elseif not H then
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
		g = columns_map[G]
	else
		a = columns_map[A]
		b = columns_map[B]
		c = columns_map[C]
		d = columns_map[D]
		e = columns_map[E]
		f = columns_map[F]
		g = columns_map[G]
		h = columns_map[H]
	end

	if not B then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
			end

			local row = i
			i -= 1

			return entity, a[row]
		end
	elseif not C then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row]
		end
	elseif not D then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row]
		end
	elseif not E then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row]
		end
	elseif not F then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row]
		end
	elseif not G then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row]
		end
	elseif not H then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row]
		end
	elseif not I then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row]
		end
	else
		local output = {}
		local ids_len = #ids
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			for i = 9, ids_len do
				output[i - 8] = columns_map[ids[i]::any][row]
			end

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row], unpack(output)
		end
	end

	query.next = world_query_iter_next
	return world_query_iter_next
end

local function query_iter(query): () -> (number, ...any)
	local query_next = query.next
	if not query_next then
		query_next = query_iter_init(query)
	end
	return query_next
end

local function query_cached(query: QueryInner)
	local ids = query.ids
	local lastArchetype = 1

	local A, B, C, D, E, F, G, H, I = unpack(ids :: { Id })
	local a: Column, b: Column, c: Column, d: Column
	local e: Column, f: Column, g: Column, h: Column

	local world_query_iter_next
	local entities: { Entity }
	local i: number
	local archetype: Archetype
	local columns_map: { [Id]: Column }
	local archetypes = query_archetypes(query :: any)
	local compatible_archetypes = archetypes :: { Archetype }

	local world = query.world
	-- Only need one observer for EcsArchetypeCreate and EcsArchetypeDelete respectively
	-- because the event will be emitted for all components of that Archetype.
	local observable = world.observable
	local on_create_action = observable[EcsOnArchetypeCreate::any]
	if not on_create_action then
		on_create_action = {} :: Map<Id, { Observer }>
		observable[EcsOnArchetypeCreate::any] = on_create_action
	end
	local query_cache_on_create = on_create_action[A]
	if not query_cache_on_create then
		query_cache_on_create = {}
		on_create_action[A] = query_cache_on_create
	end

	local on_delete_action = observable[EcsOnArchetypeDelete::any]
	if not on_delete_action then
		on_delete_action = {} :: Map<Id, { Observer }>
		observable[EcsOnArchetypeDelete::any] = on_delete_action
	end
	local query_cache_on_delete = on_delete_action[A]
	if not query_cache_on_delete then
		query_cache_on_delete = {}
		on_delete_action[A] = query_cache_on_delete
	end

	local function on_create_callback(archetype)
		table.insert(archetypes, archetype)
	end

	local function on_delete_callback(archetype)
		local i = table.find(archetypes, archetype) :: number
		if i == nil then
			return
		end
		local n = #archetypes
		archetypes[i] = archetypes[n]
		archetypes[n] = nil
	end

	local observer_for_create = { query = query, callback = on_create_callback }
	local observer_for_delete = { query = query, callback = on_delete_callback }

	table.insert(query_cache_on_create, observer_for_create)
	table.insert(query_cache_on_delete, observer_for_delete)

	local function cached_query_iter()
		lastArchetype = 1
		archetype = compatible_archetypes[lastArchetype]
		if not archetype then
			return NOOP
		end
		entities = archetype.entities
		i = #entities
		columns_map = archetype.columns_map
		if not A then
		elseif not B then
			a = columns_map[A]
		elseif not C then
			a = columns_map[A]
			b = columns_map[B]
		elseif not D then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
		elseif not E then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
		elseif not F then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
		elseif not G then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
		elseif not H then
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
			g = columns_map[G]
		else
			a = columns_map[A]
			b = columns_map[B]
			c = columns_map[C]
			d = columns_map[D]
			e = columns_map[E]
			f = columns_map[F]
			g = columns_map[G]
			h = columns_map[H]
		end

		return world_query_iter_next
	end

	if not A then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
			end
			i -= 1
			return entity
		end
	elseif not B then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
			end

			local row = i
			i -= 1

			return entity, a[row]
		end
	elseif not C then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row]
		end
	elseif not D then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row]
		end
	elseif not E then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row]
		end
	elseif not F then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row]
		end
	elseif not G then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row]
		end
	elseif not H then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row]
		end
	elseif not I then
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row]
		end
	else
		local output = {}
		local ids_len = #ids
		function world_query_iter_next(): any
			local entity = entities[i]
			while entity == nil do
				lastArchetype += 1
				archetype = compatible_archetypes[lastArchetype]
				if not archetype then
					return nil
				end

				entities = archetype.entities
				i = #entities
				if i == 0 then
					continue
				end
				entity = entities[i]
				columns_map = archetype.columns_map
				a = columns_map[A]
				b = columns_map[B]
				c = columns_map[C]
				d = columns_map[D]
				e = columns_map[E]
				f = columns_map[F]
				g = columns_map[G]
				h = columns_map[H]
			end

			local row = i
			i -= 1

			for i = 9, ids_len do
				output[i - 8] = columns_map[ids[i]::any][row]
			end

			return entity, a[row], b[row], c[row], d[row], e[row], f[row], g[row], h[row], unpack(output)
		end
	end

	local cached_query = query :: any
	cached_query.archetypes = query_archetypes
	cached_query.__iter = cached_query_iter
	cached_query.iter = cached_query_iter
	setmetatable(cached_query, cached_query)
	return cached_query
end

local Query = {}
Query.__index = Query
Query.__iter = query_iter
Query.iter = query_iter_init
Query.without = query_without
Query.with = query_with
Query.archetypes = query_archetypes
Query.cached = query_cached

local function world_query(world: World, ...)
	local ids = { ... }

	local q = setmetatable({
		ids = ids,
		filter_with = ids,
		world = world,
	}, Query)

	return q
end
local function world_each(world: world, id: i53): () -> i53
	local idr = world.component_index[id]
	if not idr then
		return NOOP :: () -> i53
	end

	local records = idr.records
	local archetypes = world.archetypes
	local archetype_id = next(records, nil) :: number
	local archetype = archetypes[archetype_id]
	if not archetype then
		return NOOP :: () -> i53
	end

	local entities = archetype.entities
	local row = #entities

	return function()
		local entity = entities[row]
		while not entity do
			archetype_id = next(records, archetype_id) :: number
			if not archetype_id then
				return nil :: any
			end
			archetype = archetypes[archetype_id]
			entities = archetype.entities
			row = #entities
			entity = entities[row]
		end
		row -= 1
		return entity
	end
end

local function world_children(world: world, parent: i53)
	return world_each(world, ECS_PAIR(EcsChildOf, parent))
end

local function ecs_bulk_insert(world: world, entity: i53, ids: { i53 }, values: { any })
	local entity_index = world.entity_index
	local r = entity_index_try_get(entity_index, entity)
	if not r then
		return
	end
	local from = r.archetype
	local component_index = world.component_index
	if not from then
		local dst_types = table.clone(ids)
		table.sort(dst_types)

		local to = archetype_ensure(world, dst_types)
		new_entity(entity, r, to)
		local ROOT_ARCHETYPE = world.ROOT_ARCHETYPE
		for i, id in ids do
			local value = values[i]
			local cdr = component_index[id]

			local on_add = cdr.on_add
			if value then
				r.archetype.columns_map[id][r.row] = value
				if on_add then
					on_add(entity, id, value, ROOT_ARCHETYPE)
				end
			else
				if on_add then
					on_add(entity, id, nil, ROOT_ARCHETYPE)
				end
			end
		end
		return
	end

	local dst_types = table.clone(from.types)

	local emplaced: { [number]: boolean } = {}

	for i, id in ids do
	    local at = find_insert(dst_types :: { number }, id :: number)
	    if at == -1 then
			emplaced[i] = true
			continue
	    end

		emplaced[i] = false

	    table.insert(dst_types, at, id)
	end

	local to = archetype_ensure(world, dst_types)

	if from ~= to then
		entity_move(entity_index, entity, r, to)
	end

	for i, set in emplaced do
		local id = ids[i]
		local idr = component_index[id]

		local value = values[i] :: any

		local on_add = idr.on_add

		if value ~= nil then
			r.archetype.columns_map[id][r.row] = value
			local on_change = idr.on_change
			local hook = if set then on_change else on_add
			if hook then
				hook(entity, id, value :: any, from)
			end
		elseif on_add then
			on_add(entity, id, nil, from)
		end
	end
end

local function ecs_bulk_remove(world: world, entity: i53, ids: { i53 })
	local entity_index = world.entity_index
	local r = entity_index_try_get(entity_index, entity)
	if not r then
		return
	end
	local from = r.archetype
	local component_index = world.component_index
	if not from then
		return
	end

	local remove: { [i53]: boolean } = {}

	local columns_map = from.columns_map

	for i, id in ids do
		if not columns_map[id] then
			continue
		end

	    remove[id] = true
		local idr = component_index[id]

		local on_remove = idr.on_remove
		if on_remove then
			on_remove(entity, id)
		end
	end

	local to = r.archetype
	if from ~= to then
		from = to
	end

	local dst_types = table.clone(from.types) :: { i53 }

	for id in remove do
		local at = table.find(dst_types, id)
		table.remove(dst_types, at)
	end

	to = archetype_ensure(world, dst_types)

	if from ~= to then
		entity_move(entity_index, entity, r, to)
	end
end

local function world_new()
	local eindex_dense_array = {} :: { i53 }
	local eindex_sparse_array = {} :: { record }

	local entity_index = {
		dense_array = eindex_dense_array,
		sparse_array = eindex_sparse_array,
		alive_count = 0,
		max_id = 0,
	} :: entityindex

	local component_index = {} :: Map<i53, componentrecord>

	local archetype_index = {} :: { [string]: archetype }
	local archetypes = {} :: Map<i53, archetype>
	local archetype_edges = {} :: { [number]: { [i53]: archetype } }

	local observable = {}

	type Signal = { [i53]: { Listener<any> } }

	local signals = {
		added = {} :: Signal,
		changed = {} :: Signal,
		removed = {} :: Signal
	}

	-- We need to cache the moment the world is registered, that way
	-- `world:component` will not pollute the global registration of components.
	local max_component_id = ecs_max_component_id

	local world = {
		archetype_edges = archetype_edges,

		component_index = component_index,
		entity_index = entity_index,
		ROOT_ARCHETYPE = nil :: any,

		archetypes = archetypes,
		archetype_index = archetype_index,
		max_archetype_id = 0,
		max_component_id = ecs_max_component_id,

		observable = observable,
		signals = signals,
	} :: world


	local function entity_index_new_id(entity_index: entityindex): i53
		local alive_count = entity_index.alive_count
		local max_id = entity_index.max_id

		if alive_count < max_id then
			alive_count += 1
			entity_index.alive_count = alive_count
			local id = eindex_dense_array[alive_count]
			return id
		end

		local id = max_id + 1
		local range_end = entity_index.range_end
		ecs_assert(range_end == nil or id < range_end, ECS_INTERNAL_ERROR_INCOMPATIBLE_ENTITY)

		entity_index.max_id = id
		alive_count += 1
		entity_index.alive_count = alive_count
		eindex_dense_array[alive_count] = id
		eindex_sparse_array[id] = { dense = alive_count } :: record

		return id
	end

	local ROOT_ARCHETYPE = archetype_create(world, {}, "")
	world.ROOT_ARCHETYPE = ROOT_ARCHETYPE

	local function entity_index_try_get_any(entity: i53): record?
		local r = eindex_sparse_array[ECS_ENTITY_T_LO(entity)]
		return r
	end

	local function inner_archetype_move(
		entity: i53,
		to: archetype,
		dst_row: i24,
		from: archetype,
		src_row: i24
	)
		local src_columns = from.columns
		local dst_entities = to.entities
		local src_entities = from.entities

		local last = #src_entities
		local id_types = from.types
		local columns_map = to.columns_map

		if src_row ~= last then
			for i, column in src_columns do
				if column == NULL_ARRAY then
					continue
				end
				local dst_column = columns_map[id_types[i]]

				if dst_column then
					dst_column[dst_row] = column[src_row]
				end

				column[src_row] = column[last]
				column[last] = nil
			end

			local e2 = src_entities[last]
			src_entities[src_row] = e2

			local record2 = eindex_sparse_array[ECS_ENTITY_T_LO(e2)]
			record2.row = src_row
		else
			for i, column in src_columns do
				if column == NULL_ARRAY then
					continue
				end
				-- Retrieves the new column index from the source archetype's record from each component
				-- We have to do this because the columns are tightly packed and indexes may not correspond to each other.
				local dst_column = columns_map[id_types[i]]

				-- Sometimes target column may not exist, e.g. when you remove a component.
				if dst_column then
					dst_column[dst_row] = column[src_row]
				end

				column[last] = nil
			end
		end
		src_entities[last] = nil :: any
		dst_entities[dst_row] = entity
	end

	local function inner_entity_move(
		entity: i53,
		record: record,
		to: archetype
	)
		local sourceRow = record.row
		local from = record.archetype
		local dst_row = archetype_append(entity, to)
		inner_archetype_move(entity, to, dst_row, from, sourceRow)
		record.archetype = to
		record.row = dst_row
	end

	-- local function entity_index_try_get(entity: number): Record?
	-- 	local r = entity_index_try_get_any(entity)
	-- 	if r then
	-- 		local r_dense = r.dense
	-- 		if r_dense > entity_index.alive_count then
	-- 			return nil
	-- 		end
	-- 		if eindex_dense_array[r_dense] ~= entity then
	-- 			return nil
	-- 		end
	-- 	end
	-- 	return r
	-- end

	local function entity_index_try_get_unsafe(entity: i53): record?
		local r = eindex_sparse_array[ECS_ENTITY_T_LO(entity)]
		if r then
			local r_dense = r.dense
			-- if r_dense > entity_index.alive_count then
			-- 	return nil
			-- end
			if eindex_dense_array[r_dense] ~= entity then
				return nil
			end
		end
		return r
	end

	local function exclusive_traverse_add(
		archetype: archetype,
		cr: number,
		id: i53
	)
		local edge = archetype_edges[archetype.id]
		local to = edge[id]
		if not to then
			local dst = table.clone(archetype.types)
			dst[cr] = id
			to = archetype_ensure(world, dst)
			edge[id] = to
		end
		return to
	end

	local function world_set(world: world, entity: i53, id: i53, data): ()
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return
		end

		local from: archetype = record.archetype
		local src = from or ROOT_ARCHETYPE
		local column = src.columns_map[id]
		if column then
			local idr = component_index[id]
			column[record.row] = data

			-- If the archetypes are the same it can avoid moving the entity
			-- and just set the data directly.
			local on_change = idr.on_change
			if on_change then
				on_change(entity, id, data, src)
			end
		else
			local to: archetype
			local idr: componentrecord
			if ECS_IS_PAIR(id) then
				local first = ECS_PAIR_FIRST(id)
				local wc = ECS_PAIR(first, EcsWildcard)
				idr = component_index[wc]

				local edge = archetype_edges[src.id]
				to = edge[id]
				if to == nil then
					if idr and (bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) == true) then
						local cr = idr.records[src.id]
						if cr then
							local on_remove = idr.on_remove
							local id_types = src.types
							if on_remove then
								on_remove(entity, id_types[cr])
								src = record.archetype
								id_types = src.types
								cr = idr.records[src.id]
							end

							to = exclusive_traverse_add(src, cr, id)
						end
					end

					if not to then
						to = find_archetype_with(world, id, src)
						if not idr then
							idr = component_index[wc]
						end
						edge[id] = to
						archetype_edges[(to :: Archetype).id][id] = src
					end
				else
					if bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) then
						local on_remove = idr.on_remove
						if on_remove then
							local cr = idr.records[src.id]
							if cr then
								local id_types = src.types
								on_remove(entity, id_types[cr])
								local arche = record.archetype
								if src ~= arche then
									id_types = arche.types
									cr = idr.records[arche.id]
									to = exclusive_traverse_add(arche, cr, id)
								end
							end
						end
					end
				end
			else
				local edges = archetype_edges
				local edge = edges[src.id]

				to = edge[id]
				if not to then
					to = find_archetype_with(world, id, src)
					edge[id] = to
					edges[to.id][id] = src
				end
				idr = component_index[id]
			end

			if from then
				-- If there was a previous archetype, then the entity needs to move the archetype
				inner_entity_move(entity, record, to)
			else
				new_entity(entity, record, to)
			end

			column = to.columns_map[id]
			column[record.row] = data

			local on_add = idr.on_add
			if on_add then
				on_add(entity, id, data, src)
			end
		end
	end

	local function world_add(
		world: world,
		entity: i53,
		id: i53
	): ()
		local record = entity_index_try_get_unsafe(entity :: number)
		if not record then
			return
		end

		local from = record.archetype
		local src = from or ROOT_ARCHETYPE
		if src.columns_map[id] then
			return
		end
		local to: archetype
		local idr: componentrecord

		if ECS_IS_PAIR(id) then
			local first = ECS_PAIR_FIRST(id)
			local wc = ECS_PAIR(first, EcsWildcard)
			idr = component_index[wc]

			local edge = archetype_edges[src.id]
			to = edge[id]
			if to == nil then
				if idr and (bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) == true) then
					local cr = idr.records[src.id]
					if cr then
						local on_remove = idr.on_remove
						local id_types = src.types
						if on_remove then
							on_remove(entity, id_types[cr])

							src = record.archetype
							id_types = src.types
							cr = idr.records[src.id]
						end

						to = exclusive_traverse_add(src, cr, id)
					end
				end

				if not to then
					to = find_archetype_with(world, id, src)
					if not idr then
						idr = component_index[wc]
					end
					edge[id] = to
					archetype_edges[(to :: Archetype).id][id] = src
				end
			else
				if bit32.btest(idr.flags, ECS_ID_IS_EXCLUSIVE) then
					local on_remove = idr.on_remove
					if on_remove then
						local cr = idr.records[src.id]
						if cr then
							local id_types = src.types
							on_remove(entity, id_types[cr])
							local arche = record.archetype
							if src ~= arche then
								id_types = arche.types
								cr = idr.records[arche.id]
								to = exclusive_traverse_add(arche, cr, id)
							end
						end
					end
				end
			end
		else
			local edges = archetype_edges
			local edge = edges[src.id]

			to = edge[id]
			if not to then
				to = find_archetype_with(world, id, src)
				edge[id] = to
				edges[to.id][id] = src
			end
			idr = component_index[id]
		end

		if from then
			inner_entity_move(entity, record, to)
		else
			if #to.types > 0 then
				new_entity(entity, record, to)
			end
		end

		local on_add = idr.on_add

		if on_add then
			on_add(entity, id, nil, src)
		end
	end

	local function world_get(world: world, entity: i53,
		a: i53, b: i53?, c: i53?, d: i53?, e: i53?): ...any
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return nil
		end

		local archetype = record.archetype
		if not archetype then
			return nil
		end

		local columns_map = archetype.columns_map
		local row = record.row

		local va = fetch(a, columns_map, row)

		if not b then
			return va
		elseif not c then
			return va, fetch(b, columns_map, row)
		elseif not d then
			return va, fetch(b, columns_map, row), fetch(c, columns_map, row)
		elseif not e then
			return va, fetch(b, columns_map, row), fetch(c, columns_map, row), fetch(d, columns_map, row)
		else
			error("args exceeded")
		end
	end

	type Listener<T> = (e: i53, id: i53, value: T, oldarchetype: archetype) -> ()

	world.added = function<T>(_: world, component: i53, fn: Listener<T>)
		local listeners = signals.added[component]
		if not listeners then
			listeners = {}
			signals.added[component] = listeners

			local function on_add(entity, id, value, oldarchetype)
				for _, listener in listeners :: { Listener<T> } do
					listener(entity, id, value, oldarchetype)
				end
			end
			local existing_hook = world_get(world, component, EcsOnAdd) :: Listener<T>
			if existing_hook then
				table.insert(listeners, existing_hook)
			end

			local idr_pair = component_index[ECS_PAIR(component, EcsWildcard)]

			if idr_pair then
				for id, cr in idr_pair.wildcard_pairs do
					cr.on_add = on_add
				end
				idr_pair.on_add = on_add
			else
				local idr = component_index[component]
				if idr then
					idr.on_add = on_add
				end
			end
			world_set(world, component, EcsOnAdd, on_add)
		end
		table.insert(listeners, fn)
		return function()
			local n = #listeners
			local i = table.find(listeners, fn)
			listeners[i] = listeners[n]
			listeners[n] = nil
		end
	end

	world.changed = function<T>(
		_: world,
		component: i53,
		fn: Listener<T>
	)
		local listeners = signals.changed[component]
		if not listeners then
			listeners = {}
			signals.changed[component] = listeners
			local function on_change(entity, id, value, oldarchetype)
				for _, listener in listeners :: { Listener<T> }  do
					listener(entity, id, value, oldarchetype)
				end
			end
			local existing_hook = world_get(world, component, EcsOnChange) :: Listener<T>
			if existing_hook then
				table.insert(listeners, existing_hook)
			end

			local idr_pair = component_index[ECS_PAIR(component, EcsWildcard)]

			if idr_pair then
				for _, cr in idr_pair.wildcard_pairs do
					cr.on_change = on_change
				end

				idr_pair.on_change = on_change
			else
				local idr = component_index[component]
				if idr then
					idr.on_change = on_change
				end
			end

			world_set(world, component, EcsOnChange, on_change)
		end
		table.insert(listeners, fn)
		return function()
			local n = #listeners
			local i = table.find(listeners, fn)
			listeners[i] = listeners[n]
			listeners[n] = nil
		end
	end

	world.removed = function<T>(_: world, component: i53, fn: (i53, i53) -> ())
		local listeners = signals.removed[component]
		if not listeners then
			listeners = {}
			signals.removed[component] = listeners
			local function on_remove(entity, id)
				for _, listener in listeners :: { (...any) -> () } do
					listener(entity, id)
				end
			end

			local existing_hook = world_get(world, component, EcsOnRemove) :: Listener<T>
			if existing_hook then
				table.insert(listeners, existing_hook)
			end

			local idr_pair = component_index[ECS_PAIR(component, EcsWildcard)]

			if idr_pair then
				for _, cr in idr_pair.wildcard_pairs do
					cr.on_remove = on_remove
				end

				idr_pair.on_remove = on_remove
			else
				local idr = component_index[component]
				if idr then
					idr.on_remove = on_remove
				end
			end

			world_set(world, component, EcsOnRemove, on_remove)
		end

		table.insert(listeners, fn)

		return function()
			local n = #listeners
			local i = table.find(listeners, fn)
			listeners[i] = listeners[n]
			listeners[n] = nil
		end
	end

	local function world_has(world: World, entity: i53,
		a: i53, b: i53?, c: i53?, d: i53?, e: i53?): boolean

		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return false
		end

		local archetype = record.archetype
		if not archetype then
			return false
		end

		local columns_map = archetype.columns_map

		return columns_map[a] ~= nil and
			(b == nil or columns_map[b] ~= nil) and
			(c == nil or columns_map[c] ~= nil) and
			(d == nil or columns_map[d] ~= nil) and
			(e == nil or error("args exceeded"))
	end

	local function world_target(world: world, entity: i53, relation: i53, index: number?): i53?
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return nil
		end

		local archetype = record.archetype
		if not archetype then
			return nil
		end

		local r = ECS_PAIR(relation, EcsWildcard)
		local idr = world.component_index[r]

		if not idr then
			return nil
		end

		local archetype_id = archetype.id
		local count = idr.counts[archetype_id]
		if not count then
			return nil
		end

		local nth = index or 0

		if nth >= count then
			return nil
		end

		nth = archetype.types[nth + idr.records[archetype_id]]

		if not nth then
			return nil
		end

		return entity_index_get_alive(world.entity_index,
		    ECS_PAIR_SECOND(nth))
	end

	local function world_parent(world: world, entity: i53): i53?
		return world_target(world, entity, EcsChildOf, 0)
	end

	local function world_entity(world: world, entity: i53?): i53
		if entity then
			local index = ECS_ID(entity)
			local alive_count = entity_index.alive_count
			local r = eindex_sparse_array[index]
			if r then
				local dense = r.dense

				if not dense or r.dense == 0 then
					r.dense = index
					dense = index
					local e_swap = eindex_dense_array[dense]
					local r_swap = entity_index_try_get_any(e_swap) :: record

					r_swap.dense = dense
					alive_count += 1
					entity_index.alive_count = alive_count
					r.dense = alive_count

					eindex_dense_array[dense] = e_swap
					eindex_dense_array[alive_count] = entity
					return entity
				end

				local any = eindex_dense_array[dense]
				if any ~= entity then
					if alive_count <= dense then
						local e_swap = eindex_dense_array[dense]
						local r_swap = entity_index_try_get_any(e_swap) :: record

						r_swap.dense = dense
						alive_count += 1
						entity_index.alive_count = alive_count
						r.dense = alive_count

						eindex_dense_array[dense] = e_swap
						eindex_dense_array[alive_count] = entity
					end
				end

				return entity
			else
				for i = entity_index.max_id + 1, index do
					eindex_sparse_array[i] = { dense = i } :: record
					eindex_dense_array[i] = i
				end
				entity_index.max_id = index

				local e_swap = eindex_dense_array[alive_count]
				local r_swap = eindex_sparse_array[alive_count]
				r_swap.dense = index

				alive_count += 1
				entity_index.alive_count = alive_count

				r = eindex_sparse_array[index]

				r.dense = alive_count

				eindex_sparse_array[index] = r

				eindex_dense_array[index] = e_swap
				eindex_dense_array[alive_count] = entity

				return entity
			end
		end
		return entity_index_new_id(entity_index)
	end

	local function world_remove(world: world, entity: i53, id: i53)
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return
		end
		local from = record.archetype

		if not from then
			return
		end

		if from.columns_map[id] then
			local idr = world.component_index[id]
			local on_remove = idr.on_remove

			if on_remove then
				on_remove(entity, id)
			end

			local to = archetype_traverse_remove(world, id, record.archetype)

			inner_entity_move(entity, record, to)
		end
	end

	local function world_delete(world: world, entity: i53)
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return
		end

		local archetype = record.archetype

		if archetype then
			for _, id in archetype.types do
				local idr = component_index[id]
				local on_remove = idr.on_remove
				if on_remove then
					on_remove(entity, id)
				end
			end
			archetype_delete(world, record.archetype, record.row)
		end

		local component_index = world.component_index
		local archetypes = world.archetypes
		local tgt = ECS_PAIR(EcsWildcard, entity::number)
		local rel = ECS_PAIR(entity::number, EcsWildcard)

		local idr_t = component_index[tgt]
		local idr = component_index[entity::number]
		local idr_r = component_index[rel]

		if idr then
			local flags = idr.flags
			if (bit32.btest(flags, ECS_ID_DELETE) == true) then
				for archetype_id in idr.records do
					local idr_archetype = archetypes[archetype_id]

					local entities = idr_archetype.entities
					local n = #entities
					for i = n, 1, -1 do
						world_delete(world, entities[i])
					end

					archetype_destroy(world, idr_archetype)
				end
			else
				local on_remove = idr.on_remove
				if on_remove then
					for archetype_id in idr.records do
						local idr_archetype = archetypes[archetype_id]
						local to = archetype_traverse_remove(world, entity, idr_archetype)
						local entities = idr_archetype.entities
						local n = #entities
						for i = n, 1, -1 do
							local e = entities[i]
							on_remove(e, entity)
							local r = eindex_sparse_array[ECS_ID(e :: number)]
							local from = r.archetype
							if from ~= idr_archetype then
								-- unfortunately the on_remove hook allows a window where `e` can have changed archetype
								-- this is hypothetically not that expensive of an operation anyways
								to = archetype_traverse_remove(world, entity, from)
							end
							inner_entity_move(e, r, to)
						end

						archetype_destroy(world, idr_archetype)
					end
				else
					for archetype_id in idr.records do
						local idr_archetype = archetypes[archetype_id]
						local to = archetype_traverse_remove(world, entity, idr_archetype)
						local entities = idr_archetype.entities
						local n = #entities
						for i = n, 1, -1 do
							local e = entities[i]
							entity_move(entity_index, e, eindex_sparse_array[ECS_ID(e :: number)], to)
						end

						archetype_destroy(world, idr_archetype)
					end
				end
			end
		end
		if idr_t then
			local archetype_ids = idr_t.records
			for archetype_id in archetype_ids do
				local idr_t_archetype = archetypes[archetype_id]
				local idr_t_types = idr_t_archetype.types
				local entities = idr_t_archetype.entities

				for _, id in idr_t_types do
					if not ECS_IS_PAIR(id) then
						continue
					end
					local object = entity_index_get_alive(
					    entity_index, ECS_PAIR_SECOND(id))
					if object ~= entity then
						continue
					end
					local id_record = component_index[id]
					local flags = id_record.flags
					local flags_delete_mask = bit32.btest(flags, ECS_ID_DELETE)
					if flags_delete_mask then
						for i = #entities, 1, -1 do
							local child = entities[i]
							world_delete(world, child)
						end
						break
					else
						local on_remove = id_record.on_remove

						for i = #entities, 1, -1 do
							local child = entities[i]
							if on_remove then
								on_remove(child, id)
							end

							local r = entity_index_try_get_unsafe(child) :: record
							local to = archetype_traverse_remove(world, id, r.archetype)
							inner_entity_move(child, r, to)
						end
					end
				end
			end

			for archetype_id in archetype_ids do
				archetype_destroy(world, archetypes[archetype_id])
			end
		end

		if idr_r then
			local archetype_ids = idr_r.records
			local flags = idr_r.flags
			local has_delete_policy = bit32.btest(flags, ECS_ID_DELETE)
			if has_delete_policy then
				for archetype_id in archetype_ids do
					local idr_r_archetype = archetypes[archetype_id]
					local entities = idr_r_archetype.entities
					local n = #entities
					for i = n, 1, -1 do
						world_delete(world, entities[i])
					end
					archetype_destroy(world, idr_r_archetype)
				end
			else
				local counts = idr_r.counts
				local records = idr_r.records
				for archetype_id in archetype_ids do
					local idr_r_archetype = archetypes[archetype_id]
					local node = idr_r_archetype
					local entities = idr_r_archetype.entities
					local tr = records[archetype_id]
					local tr_count = counts[archetype_id]
					local types = idr_r_archetype.types
					for i = tr, tr + tr_count - 1 do
						local id = types[i]
						node = archetype_traverse_remove(world, id, node)
						local on_remove = component_index[id].on_remove
						if on_remove then
							for _, entity in entities do
								on_remove(entity, id)
							end
						end
					end

					for i = #entities, 1, -1 do
						local e = entities[i]
						local r = entity_index_try_get_unsafe(e) :: record
						inner_entity_move(e, r, node)
					end
				end

				for archetype_id in archetype_ids do
					archetype_destroy(world, archetypes[archetype_id])
				end
			end
		end


		local dense = record.dense
		local i_swap = entity_index.alive_count
		entity_index.alive_count = i_swap - 1

		local e_swap = eindex_dense_array[i_swap]
		local r_swap = entity_index_try_get_any(e_swap) :: record
		r_swap.dense = dense
		record.archetype = nil :: any
		record.row = nil :: any
		record.dense = i_swap

		eindex_dense_array[dense] = e_swap
		eindex_dense_array[i_swap] = ECS_GENERATION_INC(entity)
	end

	local function world_clear(world: world, entity: i53)
		local record = entity_index_try_get_unsafe(entity)
		if not record then
			return
		end

		local archetype = record.archetype
		for _, id in archetype.types do
			local idr = component_index[id]
			local on_remove = idr.on_remove
			if on_remove then
				on_remove(entity, id)
			end
		end
		archetype_delete(world, record.archetype, record.row)
		record.archetype = nil :: any
		record.row = nil :: any
	end

	local function world_exists(world: world, entity: i53): boolean
		return entity_index_try_get_any(entity) ~= nil
	end

	local function world_contains(world: world, entity: i53): boolean
		return entity_index_is_alive(entity_index, entity)
	end

	local function world_cleanup(world: world)
		for _, archetype in archetypes do
			if #archetype.entities == 0 then
				archetype_destroy(world, archetype)
			end
		end

		local new_archetypes = {}
		local new_archetype_map = {}

		for index, archetype in archetypes do
			new_archetypes[index] = archetype
			new_archetype_map[archetype.type] = archetype
		end

		archetypes = new_archetypes
		archetype_index = new_archetype_map

		world.archetypes = new_archetypes
		world.archetype_index = new_archetype_map
	end

	local function world_component(world: world): i53
		max_component_id += 1
		if max_component_id > HI_COMPONENT_ID then
			-- IDs are partitioned into ranges because component IDs are not nominal,
			-- so it needs to error when IDs intersect into the entity range.
			error("Too many components, consider using world:entity() instead to create components.")
		end
		world.max_component_id = max_component_id
		world_add(world, max_component_id, EcsComponent)

		return max_component_id
	end

	world.entity = world_entity
	world.query = world_query :: any
	world.remove = world_remove
	world.clear = world_clear
	-- world.purge = world_purge
	world.delete = world_delete
	world.component = world_component
	world.add = world_add
	world.set = world_set
	world.get = world_get :: any
	world.has = world_has :: any
	world.target = world_target
	world.parent = world_parent
	world.contains = world_contains
	world.exists = world_exists
	world.cleanup = world_cleanup
	world.each = world_each
	world.children = world_children
	world.range = world_range

	for i = 1, EcsRest do
		entity_index_new_id(entity_index)
	end

	for i = 1, max_component_id do
		world_add(world, i, EcsComponent)
	end

	world_add(world, EcsName, EcsComponent)
	world_add(world, EcsOnChange, EcsComponent)
	world_add(world, EcsOnAdd, EcsComponent)
	world_add(world, EcsOnRemove, EcsComponent)
	world_add(world, EcsWildcard, EcsComponent)
	world_add(world, EcsRest, EcsComponent)

	world_set(world, EcsOnAdd, EcsName, "jecs.OnAdd")
	world_set(world, EcsOnRemove, EcsName, "jecs.OnRemove")
	world_set(world, EcsOnChange, EcsName, "jecs.OnChange")
	world_set(world, EcsWildcard, EcsName, "jecs.Wildcard")
	world_set(world, EcsChildOf, EcsName, "jecs.ChildOf")
	world_set(world, EcsComponent, EcsName, "jecs.Component")

	world_set(world, EcsOnDelete, EcsName, "jecs.OnDelete")
	world_set(world, EcsOnDeleteTarget, EcsName, "jecs.OnDeleteTarget")

	world_set(world, EcsDelete, EcsName, "jecs.Delete")
	world_set(world, EcsRemove, EcsName, "jecs.Remove")
	world_set(world, EcsName, EcsName, "jecs.Name")
	world_set(world, EcsRest, EcsRest, "jecs.Rest")

	world_add(world, EcsChildOf, ECS_PAIR(EcsOnDeleteTarget, EcsDelete))
	world_add(world, EcsChildOf, EcsExclusive)

	world_add(world, EcsOnDelete, EcsExclusive)
	world_add(world, EcsOnDeleteTarget, EcsExclusive)

	for i = EcsRest + 1, ecs_max_tag_id do
		entity_index_new_id(entity_index)
	end

	for i, bundle in ecs_metadata do
		for ty, value in bundle do
			if value == NULL then
				world_add(world, i, ty)
			else
				world_set(world, i, ty, value)
			end
		end
	end

	return world
end

-- type function ecs_id_t(entity)
-- 	local ty = entity:components()[2]
-- 	local __T = ty:readproperty(types.singleton("__T"))
-- 	if not __T then
-- 		return ty:readproperty(types.singleton("__jecs_pair_value"))
-- 	end
-- 	return __T
-- end

-- type function ecs_pair_t(first, second)
-- 	if ecs_id_t(first):is("nil") then
-- 		return second
-- 	else
-- 		return first
-- 	end
-- end
--

local function ecs_is_tag(world: world, entity: i53): boolean
	local idr = world.component_index[entity]
	if idr then
		return bit32.btest(idr.flags, ECS_ID_IS_TAG)
	end
	return not WORLD_HAS(world, entity, EcsComponent)
end

local function ecs_entity_record(world: world, entity: i53)
	return entity_index_try_get(world.entity_index, entity)
end

return {
	world = world_new :: () -> World,
	World = {
		new = world_new
	},
	component = (ECS_COMPONENT :: any) :: <T>() -> Entity<T>,
	tag = (ECS_TAG :: any) :: <T>() -> Entity<T>,
	meta = (ECS_META :: any) :: <T, a>(id: Entity<T>, id: Id<a>, value: a?) -> Entity<T>,
	is_tag = (ecs_is_tag :: any) :: <T>(World, Id<T>) -> boolean,

    OnAdd = (EcsOnAdd :: any) :: Id<<T>(entity: Entity, id: Id<T>, data: T) -> ()>,
	OnRemove = (EcsOnRemove :: any) :: Id<(entity: Entity, id: Id) -> ()>,
	OnChange = (EcsOnChange :: any) :: Id<<T>(entity: Entity, id: Id<T>, data: T) -> ()>,
	ChildOf = (EcsChildOf :: any) :: Entity,
	Component = (EcsComponent :: any) :: Entity,
	Wildcard = (EcsWildcard :: any) :: Id,
	w = (EcsWildcard :: any) :: Id,
	OnDelete = (EcsOnDelete :: any) :: Entity,
	OnDeleteTarget = (EcsOnDeleteTarget :: any) :: Entity,
	Delete = (EcsDelete :: any) :: Entity,
	Remove = (EcsRemove :: any) :: Entity,
	Name = (EcsName :: any) :: Id<string>,
	Exclusive = (EcsExclusive :: any) :: Entity,
	ArchetypeCreate = (EcsOnArchetypeCreate :: any) :: Entity,
	ArchetypeDelete = (EcsOnArchetypeDelete :: any) :: Entity,
	Rest = (EcsRest :: any) :: Entity,

	pair = ECS_PAIR :: <P, O>(first: Id<P>, second: Id<O>) -> Pair<P, O>,

	IS_PAIR = ECS_IS_PAIR :: <P, O>(pair: Pair<P, O>) -> boolean,
	ECS_PAIR_FIRST = ECS_PAIR_FIRST :: <P, O>(pair: Pair<P, O>) -> Id<P>,
	ECS_PAIR_SECOND = ECS_PAIR_SECOND :: <P, O>(pair: Pair<P, O>) -> Id<O>,
	pair_first = ecs_pair_first :: <P, O>(world: World, pair: Pair<P, O>) -> Id<P>,
	pair_second = ecs_pair_second :: <P, O>(world: World, pair: Pair<P, O>) -> Id<O>,
	entity_index_get_alive = entity_index_get_alive,

	archetype_append_to_records = archetype_append_to_records,
	id_record_ensure = id_record_ensure :: (World, Id) -> ComponentRecord,
	component_record = id_record_get :: (World, Id) -> ComponentRecord?,
	record = ecs_entity_record :: (World, Entity) -> Record,

	archetype_create = archetype_create :: (World, { Id }, string) -> Archetype,
	archetype_ensure = archetype_ensure :: (World, { Id }) -> Archetype,
	find_insert = find_insert,
	find_archetype_with = find_archetype_with :: (World, Id, Archetype) -> Archetype,
	find_archetype_without = find_archetype_without :: (World, Id, Archetype) -> Archetype,
	create_edge_for_remove = create_edge_for_remove,
	archetype_traverse_add = archetype_traverse_add :: (World, Id, Archetype) -> Archetype,
	archetype_traverse_remove = archetype_traverse_remove :: (World, Id, Archetype) -> Archetype,
	bulk_insert = ecs_bulk_insert :: (World, Entity, { Id }, { any }) -> (),
	bulk_remove = ecs_bulk_remove :: (World, Entity, { Id }) -> (),

	entity_move = entity_move :: (EntityIndex, Entity, Record, Archetype) -> (),

	entity_index_try_get = entity_index_try_get :: (EntityIndex, Entity) -> Record?,
	entity_index_try_get_fast = entity_index_try_get_fast :: (EntityIndex, Entity) -> Record?,
	entity_index_try_get_any = entity_index_try_get_any :: (EntityIndex, Entity) -> Record,
	entity_index_is_alive = entity_index_is_alive :: (EntityIndex, Entity) -> boolean,
	entity_index_new_id = ENTITY_INDEX_NEW_ID :: (EntityIndex) -> Entity,

	Query = Query,

	query_iter = query_iter,
	query_iter_init = query_iter_init,
	query_with = query_with,
	query_without = query_without,
	query_archetypes = query_archetypes,
	query_match = query_match,

	find_observers = find_observers :: (World, Id, Id) -> { Observer },

	-- Inwards facing API for testing
	ECS_ID = ECS_ENTITY_T_LO :: (Entity) -> number,
	ECS_GENERATION_INC = ECS_GENERATION_INC :: (Entity) -> Entity,
	ECS_GENERATION = ECS_GENERATION :: (Entity) -> number,
	ECS_ID_IS_WILDCARD = ECS_ID_IS_WILDCARD,
	ECS_ID_IS_EXCLUSIVE = ECS_ID_IS_EXCLUSIVE,
	ECS_ID_DELETE = ECS_ID_DELETE,
	ECS_META_RESET = ECS_META_RESET,
	ECS_COMBINE = ECS_COMBINE :: (number, number) -> Entity,
	ECS_ENTITY_MASK = ECS_ENTITY_MASK,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002541</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="304">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">cmdr</string>
					<string name="ScriptGuid">{95E2D61D-E4D4-414C-AF06-69BBCC7FB23F}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["evaera_cmdr@1.12.0"]["cmdr"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c3</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="305">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">jabby</string>
					<string name="ScriptGuid">{F2B4CA54-B8BD-4564-85D3-32452D3D483A}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["alicesaidhi_jabby@0.2.2"]["jabby"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c4</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="306">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">sha256</string>
					<string name="ScriptGuid">{118DA708-1228-4F5D-A89A-40794D281E5E}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["dekkonot_sha256@1.0.1"]["sha256"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c5</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="307">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">vide</string>
					<string name="ScriptGuid">{6886C70F-4E49-47C2-8F51-28A97151D571}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["centau_vide@0.3.1"]["vide"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c6</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="308">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">zoneplus</string>
					<string name="ScriptGuid">{27FFD640-115A-4EF3-9C00-1BFBD74F7D81}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["mattschrubb_zoneplus@3.2.0"]["zoneplus"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c7</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5BC365B61D394E2DA95F517AAABCB950">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">jecs</string>
					<string name="ScriptGuid">{C9E99C3A-C510-4599-89C8-6F12F9AD14AF}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["ukendio_jecs@0.9.0"]["jecs"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002545</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="309">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ecs</string>
				<string name="ScriptGuid">{8D4DE7A5-F374-40B9-8400-94A555CE0CCC}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
return require(ReplicatedStorage.Packages.jecs)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c8</UniqueId>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="310">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">net</string>
				<string name="ScriptGuid">{E400170B-03FA-4051-89F5-1CFFF8B1B772}</string>
				<ProtectedString name="Source"><![CDATA[--!strict
--!native
--!optimize 2
--!nolint LocalShadow
--#selene: allow(shadowing)
-- File generated by Blink v0.18.0 (https://github.com/1Axen/Blink)
-- This file is not meant to be edited

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BASE_EVENT_NAME = "BLINK"
local Invocations = 0

local SendSize = 64
local SendOffset = 0
local SendCursor = 0
local SendBuffer = buffer.create(64)
local SendInstances = {}

local RecieveCursor = 0
local RecieveBuffer = buffer.create(64)

local RecieveInstances = {}
local RecieveInstanceCursor = 0

local Null = newproxy()

type Entry = {
    value: any,
    next: Entry?
}

type Queue = {
    head: Entry?,
    tail: Entry?
}

type BufferSave = {
    Size: number, 
    Cursor: number, 
    Buffer: buffer, 
    Instances: {Instance}
}

local function Read(Bytes: number)
    local Offset = RecieveCursor
    RecieveCursor += Bytes
    return Offset
end

local function Save(): BufferSave
    return {
        Size = SendSize,
        Cursor = SendCursor,
        Buffer = SendBuffer,
        Instances = SendInstances
    }
end

local function Load(Save: BufferSave?)
    if Save then
        SendSize = Save.Size
        SendCursor = Save.Cursor
        SendOffset = Save.Cursor
        SendBuffer = Save.Buffer
        SendInstances = Save.Instances
        return
    end

    SendSize = 64
    SendCursor = 0
    SendOffset = 0
    SendBuffer = buffer.create(64)
    SendInstances = {}
end

local function Invoke()
    if Invocations == 255 then
        Invocations = 0
    end

    local Invocation = Invocations
    Invocations += 1
    return Invocation
end

local function Allocate(Bytes: number)
    local InUse = (SendCursor + Bytes)
    if InUse > SendSize then
        --> Avoid resizing the buffer for every write
        while InUse > SendSize do
            SendSize *= 1.5
        end

        local Buffer = buffer.create(SendSize)
        buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
        SendBuffer = Buffer
    end

    SendOffset = SendCursor
    SendCursor += Bytes
    
    return SendOffset
end

local function CreateQueue(): Queue
    return {
        head = nil,
        tail = nil
    }
end

local function Pop(queue: Queue): any
    local head = queue.head
    if head == nil then
        return
    end

    queue.head = head.next
    return head.value
end

local function Push(queue: Queue, value: any)
    local entry: Entry = {
        value = value,
        next = nil
    }

    if queue.tail ~= nil then
        queue.tail.next = entry
    end

    queue.tail = entry

    if queue.head == nil then
        queue.head = entry
    end
end

local Calls = table.create(256)

local Events: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

local Queue: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

Queue.Unreliable[0] = table.create(256)
Queue.Reliable[0] = table.create(256)
Queue.Reliable[1] = CreateQueue()
export type Transform = { id: number, dp: Vector3 }
export type TransformFull = { id: number, dp: Vector3 }
local function ReadEVENT_UpdateTransformDelta(): ({ { id: number, dp: Vector3 } })
	-- Read BLOCK: 2 bytes
	local BLOCK_START = Read(2)
	-- START ARRAY
	local Length = buffer.readu16(RecieveBuffer, BLOCK_START + 0)
	if Length < 0 then error(`Expected "Length" to be larger than 0, got {Length} instead.`) end
	if Length > 65535 then error(`Expected "Length" to be smaller than 65535, got {Length} instead.`) end
	local Value = table.create(Length)
		-- Read BLOCK: 8 bytes
	local ARRAY_START_1 = Read(8 * Length)
	for Index = 1, Length do
		local Item_1 = {} :: any
		-- Read 2
		local OPERATION_OFFSET_0 = ARRAY_START_1
		ARRAY_START_1 += 2
		Item_1.id = buffer.readu16(RecieveBuffer, OPERATION_OFFSET_0)
		-- Read 2
		local OPERATION_OFFSET_1 = ARRAY_START_1
		ARRAY_START_1 += 2
		local Encoded = buffer.readu16(RecieveBuffer, OPERATION_OFFSET_1)
		local X
		local MantissaExponent = Encoded % 0x8000
		if MantissaExponent == 0b0_11111_0000000000  then
			if Encoded // 0x8000 == 1 then
				X = -math.huge
			else
				X = math.huge
			end
		elseif MantissaExponent == 0b1_11111_0000000000   then
			X = 0 / 0
		elseif MantissaExponent == 0b0_00000_0000000000   then
			X = 0
		else
			local Mantissa = MantissaExponent % 0x400
			local Exponent = MantissaExponent // 0x400
			local Fraction;
			if Exponent == 0 then
				Fraction = Mantissa / 0x400
			else
				Fraction = Mantissa / 0x800 + 0.5
			end
			local Result = math.ldexp(Fraction, Exponent - 14)
			X = if Encoded // 0x8000 == 1 then -Result else Result
		end
		-- Read 2
		local OPERATION_OFFSET_2 = ARRAY_START_1
		ARRAY_START_1 += 2
		Encoded = buffer.readu16(RecieveBuffer, OPERATION_OFFSET_2)
		local Y
		local MantissaExponent = Encoded % 0x8000
		if MantissaExponent == 0b0_11111_0000000000  then
			if Encoded // 0x8000 == 1 then
				Y = -math.huge
			else
				Y = math.huge
			end
		elseif MantissaExponent == 0b1_11111_0000000000   then
			Y = 0 / 0
		elseif MantissaExponent == 0b0_00000_0000000000   then
			Y = 0
		else
			local Mantissa = MantissaExponent % 0x400
			local Exponent = MantissaExponent // 0x400
			local Fraction;
			if Exponent == 0 then
				Fraction = Mantissa / 0x400
			else
				Fraction = Mantissa / 0x800 + 0.5
			end
			local Result = math.ldexp(Fraction, Exponent - 14)
			Y = if Encoded // 0x8000 == 1 then -Result else Result
		end
		-- Read 2
		local OPERATION_OFFSET_3 = ARRAY_START_1
		ARRAY_START_1 += 2
		Encoded = buffer.readu16(RecieveBuffer, OPERATION_OFFSET_3)
		local Z
		local MantissaExponent = Encoded % 0x8000
		if MantissaExponent == 0b0_11111_0000000000  then
			if Encoded // 0x8000 == 1 then
				Z = -math.huge
			else
				Z = math.huge
			end
		elseif MantissaExponent == 0b1_11111_0000000000   then
			Z = 0 / 0
		elseif MantissaExponent == 0b0_00000_0000000000   then
			Z = 0
		else
			local Mantissa = MantissaExponent % 0x400
			local Exponent = MantissaExponent // 0x400
			local Fraction;
			if Exponent == 0 then
				Fraction = Mantissa / 0x400
			else
				Fraction = Mantissa / 0x800 + 0.5
			end
			local Result = math.ldexp(Fraction, Exponent - 14)
			Z = if Encoded // 0x8000 == 1 then -Result else Result
		end
		Item_1.dp = Vector3.new(X, Y, Z)
		table.insert(Value, Item_1)
	end
	-- END ARRAY
	return Value
end

local function ReadEVENT_UpdateTransformFull(): ({ { id: number, dp: Vector3 } })
	-- Read BLOCK: 2 bytes
	local BLOCK_START = Read(2)
	-- START ARRAY
	local Length = buffer.readu16(RecieveBuffer, BLOCK_START + 0)
	if Length < 0 then error(`Expected "Length" to be larger than 0, got {Length} instead.`) end
	if Length > 65535 then error(`Expected "Length" to be smaller than 65535, got {Length} instead.`) end
	local Value = table.create(Length)
		-- Read BLOCK: 14 bytes
	local ARRAY_START_1 = Read(14 * Length)
	for Index = 1, Length do
		local Item_1 = {} :: any
		-- Read 2
		local OPERATION_OFFSET_0 = ARRAY_START_1
		ARRAY_START_1 += 2
		Item_1.id = buffer.readu16(RecieveBuffer, OPERATION_OFFSET_0)
		-- Read 4
		local OPERATION_OFFSET_1 = ARRAY_START_1
		ARRAY_START_1 += 4
		local X = buffer.readf32(RecieveBuffer, OPERATION_OFFSET_1)
		-- Read 4
		local OPERATION_OFFSET_2 = ARRAY_START_1
		ARRAY_START_1 += 4
		local Y = buffer.readf32(RecieveBuffer, OPERATION_OFFSET_2)
		-- Read 4
		local OPERATION_OFFSET_3 = ARRAY_START_1
		ARRAY_START_1 += 4
		local Z = buffer.readf32(RecieveBuffer, OPERATION_OFFSET_3)
		Item_1.dp = Vector3.new(X, Y, Z)
		table.insert(Value, Item_1)
	end
	-- END ARRAY
	return Value
end

local function ReadEVENT_SpawnMob(): (number, CFrame, number)
	-- Read BLOCK: 27 bytes
	local BLOCK_START = Read(27)
	local Encoded = buffer.readu16(RecieveBuffer, BLOCK_START + 0)
	local Value1
	local MantissaExponent = Encoded % 0x8000
	if MantissaExponent == 0b0_11111_0000000000  then
		if Encoded // 0x8000 == 1 then
			Value1 = -math.huge
		else
			Value1 = math.huge
		end
	elseif MantissaExponent == 0b1_11111_0000000000   then
		Value1 = 0 / 0
	elseif MantissaExponent == 0b0_00000_0000000000   then
		Value1 = 0
	else
		local Mantissa = MantissaExponent % 0x400
		local Exponent = MantissaExponent // 0x400
		local Fraction;
		if Exponent == 0 then
			Fraction = Mantissa / 0x400
		else
			Fraction = Mantissa / 0x800 + 0.5
		end
		local Result = math.ldexp(Fraction, Exponent - 14)
		Value1 = if Encoded // 0x8000 == 1 then -Result else Result
	end
	local X = buffer.readf32(RecieveBuffer, BLOCK_START + 2)
	local Y = buffer.readf32(RecieveBuffer, BLOCK_START + 6)
	local Z = buffer.readf32(RecieveBuffer, BLOCK_START + 10)
	local Position = Vector3.new(X, Y, Z)
	local rX = buffer.readf32(RecieveBuffer, BLOCK_START + 14)
	local rY = buffer.readf32(RecieveBuffer, BLOCK_START + 18)
	local rZ = buffer.readf32(RecieveBuffer, BLOCK_START + 22)
	local Value2 = CFrame.new(Position) * CFrame.fromOrientation(rX, rY, rZ)
	local Value3 = buffer.readu8(RecieveBuffer, BLOCK_START + 26)
	return Value1, Value2, Value3
end

if not RunService:IsRunning() then
	local NOOP = function() end
	local Returns = table.freeze({
	UpdateTransformDelta = {
		On = NOOP
	},
	UpdateTransformFull = {
		On = NOOP
	},
	SpawnMob = {
		Iter = NOOP,
		Next = NOOP
	},
	})
	return Returns :: BLINK_EVENTS_SYMBOL
end

if not RunService:IsClient() then
    error("Client network module can only be required from the client.")
end

local Reliable: RemoteEvent = ReplicatedStorage:WaitForChild(BASE_EVENT_NAME .. "_RELIABLE_REMOTE") :: RemoteEvent
local Unreliable: UnreliableRemoteEvent = ReplicatedStorage:WaitForChild(BASE_EVENT_NAME .. "_UNRELIABLE_REMOTE") :: UnreliableRemoteEvent

local function StepReplication()
    if SendCursor <= 0 then
        return
    end

    local Buffer = buffer.create(SendCursor)
    buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
    Reliable:FireServer(Buffer, SendInstances)

    SendSize = 64
    SendCursor = 0
    SendOffset = 0
    SendBuffer = buffer.create(64)
    table.clear(SendInstances)
end
RunService.Heartbeat:Connect(StepReplication)
Reliable.OnClientEvent:Connect(function(Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
		if Index == 0 then
			local Value: { { id: number, dp: Vector3 } } = ReadEVENT_UpdateTransformFull()
			if Events.Reliable[0] ~= nil then
				Events.Reliable[0](Value)
			else
				if #Queue.Reliable[0] > 256 then
					warn("[Blink]: Event queue of \"UpdateTransformFull\" exceeded 256, did you forget to implement a listener?")
				end
				table.insert(Queue.Reliable[0], {Value} :: {any})
			end
		elseif Index == 1 then
			Push(Queue.Reliable[1], table.pack(ReadEVENT_SpawnMob()))
		end
	end
end)
Unreliable.OnClientEvent:Connect(function(Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
		if Index == 0 then
			local Value: { { id: number, dp: Vector3 } } = ReadEVENT_UpdateTransformDelta()
			if Events.Unreliable[0] ~= nil then
				Events.Unreliable[0](Value)
			end
		end
	end
end)


local Returns = table.freeze({
	StepReplication = StepReplication,

	UpdateTransformDelta = {
		On = function(Listener: (Value: { { id: number, dp: Vector3 } }) -> ()): () -> ()
			Events.Unreliable[0] = Listener
			return function (): ()
				if Events.Unreliable[0] == Listener then
					Events.Unreliable[0] = nil
				end
			end
		end
	},
	UpdateTransformFull = {
		On = function(Listener: (Value: { { id: number, dp: Vector3 } }) -> ()): () -> ()
			Events.Reliable[0] = Listener
			for Index, Arguments in Queue.Reliable[0] do
				Listener(table.unpack(Arguments))
			end
			Queue.Reliable[0] = {}
			return function (): ()
				if Events.Reliable[0] == Listener then
					Events.Reliable[0] = nil
				end
			end
		end
	},
	SpawnMob = {
		Iter = function(): () -> (number, number, CFrame, number)
			local index = 0
			local queue = Queue.Reliable[1]
			return function (): (number, number, CFrame, number)
				index += 1
				local arguments = Pop(queue)
				if arguments ~= nil then
					return index, unpack(arguments, 1, arguments.n)
				end
				return 
			end
		end,
		--- @deprecated v0.14.1 -- Use `Iter` instead.
		Next = function(): () -> (number, number, CFrame, number)
			local index = 0
			local queue = Queue.Reliable[1]
			return function (): (number, number, CFrame, number)
				index += 1
				local arguments = Pop(queue)
				if arguments ~= nil then
					return index, unpack(arguments, 1, arguments.n)
				end
				return 
			end
		end
	},
})
type BLINK_EVENTS_SYMBOL = typeof(Returns)
return Returns :: BLINK_EVENTS_SYMBOL]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004c9</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerScriptService" referent="311">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000379</UniqueId>
		</Properties>
		<Item class="Script" referent="312">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">main</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{28E77FD0-7315-46A7-9F6C-2668D548CB91}</string>
				<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local start = require(ReplicatedStorage.start)

start(script.Parent:WaitForChild("systems"):GetChildren())
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ca</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="313">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">systems</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004cc</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="314">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">mobs</string>
					<string name="ScriptGuid">{AF60139E-C070-43DF-A291-C2F44317B76A}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local jecs = require(ReplicatedStorage.ecs)
local __ = jecs.Wildcard
local std = ReplicatedStorage.std
local scheduler = require(std.scheduler)

local world = require(std.world)
local cts = require(std.components)
local mailbox = require(std.mailbox)

local Mob = cts.Mob
local Transform = cts.Transform
local Speed = cts.Speed
local Player = cts.Player
local Character = cts.Character
local Size = cts.Size

-- ===== Tunables =====
local TICK_HZ = 20
local TICK = 1 / TICK_HZ

local RESUME_RADIUS = 12     -- resume movement when farther than this (hysteresis)
local EPS = 1e-4             -- don't send tiny deltas

local STOP_RADIUS = 5
local lastPositions: {[number]: Vector3} = {}
local halted: {[number]: boolean} = {}

local targets: {Vector3} = table.create(16)

local characters = world
	:query(Character)
	:with(Player)
	:cached()

local moving_mobs = world
	:query(Transform, Speed, Size)
	:with(Mob)
	:cached()

local last_accum = 0

-- Optimized distance calculation (avoids sqrt when possible)
local function getClosestTarget(position: Vector3): (Vector3?, number)
	if #targets == 0 then return nil, math.huge end
	
	local closestPos: Vector3? = nil
	local closestDistSq = math.huge
	
	for i = 1, #targets do
		local target = targets[i]
		local distSq = (target - position).Magnitude ^ 2
		if distSq < closestDistSq then
			closestDistSq = distSq
			closestPos = target
		end
	end
	
	return closestPos, math.sqrt(closestDistSq)
end

local function mobsMove(dt: number)
	last_accum += dt

	if last_accum < TICK then return end -- 30hz

	local step_dt = last_accum
	last_accum = 0

	-- Collect player target positions
	table.clear(targets)
	for _, character in characters do
		local pp = (character.PrimaryPart :: Part)
		if pp then
			targets[#targets + 1] = pp.Position
		end
	end

	if #targets == 0 then
		return
	end

	for mob, transform, speed, size in moving_mobs do
		local cf = transform.new
		local position = cf.Position
		

		local stopRadius = math.max(STOP_RADIUS, size * 2)  -- Larger mobs stop farther out
		-- Find closest player
		local closestPos, closestDist = getClosestTarget(position)
		if not closestPos then
			continue
		end

		local isHalted = halted[mob] or false

		-- Hysteresis logic to prevent jittering
		if isHalted then
			if closestDist > RESUME_RADIUS then
				halted[mob] = false
				isHalted = false
			end
		else
			if closestDist < stopRadius then
				halted[mob] = true
				isHalted = true
			end
		end

		if isHalted then
			-- Stay put; no delta to send
			continue
		end

		-- Move toward target, but don't overshoot past STOP_RADIUS
		local dir = (closestPos - position)
		local dist = dir.Magnitude

		if dist < EPS then
			continue
		end
		
		dir = dir / dist

		-- How far we're allowed to move this tick:
		-- 1) natural step = speed * dt
		-- 2) clamp so we never cross into STOP_RADIUS
		local stepMax = math.max(0, dist - stopRadius)
		local step = math.min(speed * step_dt, stepMax)

		if step <= EPS then
			-- Already close enough; nothing to do
			continue
		end

		local delta = dir * step
		local newPos = position + delta

		-- Update Transform
		transform.new = CFrame.new(newPos, cf.LookVector)

		-- Batch delta (skip near-zero)
		if delta.Magnitude > EPS then
			mailbox.push(cts.PendingMovements, { id = mob, dp = delta })
		end

		local lastPos = lastPositions[mob]
		if lastPos and (position - lastPos).Magnitude < 0.1 and not isHalted then
			-- Mob hasn't moved much - might be stuck
			-- Force unhalt or add small random offset
			halted[mob] = false
		end
		lastPositions[mob] = position

	end
end

scheduler.SYSTEM(mobsMove)

return 0]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004cd</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="315">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">players</string>
					<string name="ScriptGuid">{3E787769-F80E-41F2-85F0-C3861445C327}</string>
					<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local std = ReplicatedStorage.std
local ref = require(std.ref)
local collect = require(std.collect)

local cts = require(std.components)
local world = require(std.world)
local Player = cts.Player
local Character = cts.Character

local conn = {}

local function playersAdded(player: Player)
	local e = ref(player.UserId)
	world:set(e, Player, player)
	local characterAdd = player.CharacterAdded
	conn[e] = characterAdd:Connect(function(rig)
		while rig.Parent ~= workspace do
			task.wait()
		end
		world:set(e, Character, rig)
	end)
end

local function playersRemoved(player: Player) 
	local e = ref(player.UserId)
	world:clear(e)
	local connection = conn[e]
	connection:Disconnect()
	conn[e] = nil
end

local scheduler = require(std.scheduler)
local phases = require(std.phases)
scheduler.SYSTEM(playersAdded, phases.PlayerAdded)
scheduler.SYSTEM(playersRemoved, phases.PlayerRemoved)

return 0]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004ce</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX31CDBEF4ADEB4D8EA77E5629C5E16B17">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">physics</string>
					<string name="ScriptGuid">{475FD67B-9347-4F39-838C-8172F4684EDE}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local std = ReplicatedStorage.std
local world = require(std.world)
local cts = require(std.components)
local scheduler = require(std.scheduler)
local phases = require(std.phases)

local Transform = cts.Transform
local Velocity = cts.Velocity
local Gravity = cts.Gravity
local Knockback = cts.Knockback
local Collider = cts.Collider
local Grounded = cts.Grounded
local Mob = cts.Mob

-- =================== constants ===================
local GRAVITY_ACC          = -196.2              -- Roblox default
local TERMINAL_VY          = -200.0
local STEP_MAX_Y           = 0.5                 -- max “snap up” to ground (studs)
local GROUND_PROBE_UP      = 1.0                 -- start a little above feet
local GROUND_PROBE_DOWN    = 5.0                 -- how far we probe downward
local SKIN_WIDTH           = 0.05                -- small separation to avoid sinking
local GRID_SIZE            = 16                  -- spatial hashing cell size
local RESOLVE_ITERATIONS   = 1                   -- simple positional solve passes
local MAX_NEIGHBOR_CELLS   = 1                   -- 3x3 neighborhood

-- =================== helpers ===================
local function setPosPreserveRot(cf: CFrame, p: Vector3): CFrame
    -- Recompose with original orientation (no roll loss)
    -- CFrame.fromMatrix expects basis axes; Roblox LookVector is +Z (forward).
    return CFrame.fromMatrix(p, cf.RightVector, cf.UpVector, cf.LookVector)
end

local function moveBy(cf: CFrame, dp: Vector3): CFrame
    return setPosPreserveRot(cf, cf.Position + dp)
end

local groundParams = RaycastParams.new()
groundParams.FilterType = Enum.RaycastFilterType.Exclude
groundParams.FilterDescendantsInstances = {} -- set externally if you want to ignore some things
groundParams.IgnoreWater = true

local function raycastGround(origin: Vector3, down: number): RaycastResult?
    return workspace:Raycast(origin, Vector3.new(0, -down, 0), groundParams)
end

-- =================== spatial grid ===================
local spatialGrid: {[string]: {number}} = {}
local function gridKey(x: number, z: number): string
    return string.format("%d,%d", x, z)
end

local function clearSpatialGrid()
    for k in spatialGrid do
        spatialGrid[k] = nil
    end
end

local function addToGrid(e: number, p: Vector3)
    local gx, gz = math.floor(p.X / GRID_SIZE), math.floor(p.Z / GRID_SIZE)
    local key = gridKey(gx, gz)
    local bin = spatialGrid[key]
    if not bin then
        bin = {}
        spatialGrid[key] = bin
    end
    bin[#bin+1] = e
end

local function getNearby(entityPos: Vector3): {number}
    local gx, gz = math.floor(entityPos.X / GRID_SIZE), math.floor(entityPos.Z / GRID_SIZE)
    local list = table.create(32)
    for dx = -MAX_NEIGHBOR_CELLS, MAX_NEIGHBOR_CELLS do
        for dz = -MAX_NEIGHBOR_CELLS, MAX_NEIGHBOR_CELLS do
            local bin = spatialGrid[gridKey(gx+dx, gz+dz)]
            if bin then
                for i = 1, #bin do 
                    list[#list+1] = bin[i] 
                end
            end
        end
    end
    return list
end

-- =================== queries ===================
local qGravity   = world:query(Transform, Gravity):with(Mob):cached()
local qXZ        = world:query(Transform, Velocity):with(Mob):cached()
local qKnockback = world:query(Transform, Knockback):with(Mob):cached()
local qColliders = world:query(Transform, Collider):with(Mob):cached()

-- =================== systems ===================

-- 1) Apply gravity (vertical integration only)
local function gravitySystem(dt: number)
    for e, tf, g in qGravity do
        if g.enabled ~= false then
            g.vy = math.max((g.vy or 0) + GRAVITY_ACC * dt, TERMINAL_VY)
            tf.new = moveBy(tf.new, Vector3.new(0, (g.vy or 0) * dt, 0))
        end
        -- clear grounded tag for now; grounding step will add it back if applicable
        if world:has(e, Grounded) then
            world:remove(e, Grounded)
        end
    end
end

-- 2) Integrate horizontal velocity (and optional y if you store it in Velocity)
local function integrateXZSystem(dt: number)
    for _, tf, vel in qXZ do
        local v = vel.v
        if v and (v.X ~= 0 or v.Z ~= 0 or v.Y ~= 0) then
            tf.new = moveBy(tf.new, v * dt)
        end
    end
end

-- 3) Apply knockback (additive positional)
local function knockbackSystem(dt: number)
    for e, tf, kb in qKnockback do
        tf.new = moveBy(tf.new, kb.force * dt)
        kb.remaining -= dt
        if kb.remaining <= 0 then
            world:unset(e, Knockback)
        end
    end
end

-- 4) Grounding (raycast down; snap up/down within small band; set vy=0)
local function groundingSystem(_dt: number)
    for e, tf, g in qGravity do
        local pos = tf.new.Position
        -- probe around feet (slightly above current pos)
        local origin = pos + Vector3.new(0, GROUND_PROBE_UP, 0)
        local res = raycastGround(origin, GROUND_PROBE_UP + GROUND_PROBE_DOWN)

        if res then
            -- accept hits on Terrain or BaseParts
            local inst = res.Instance
            if inst == workspace.Terrain or (inst and inst:IsA("BasePart")) then
                local hitY = res.Position.Y
                local targetY = hitY + SKIN_WIDTH
                local deltaY = targetY - pos.Y
                -- snap within band; if we fell through, bring us back up to surface
                if deltaY >= -STEP_MAX_Y and deltaY <= (GROUND_PROBE_DOWN + GROUND_PROBE_UP) then
                    tf.new = setPosPreserveRot(tf.new, Vector3.new(pos.X, targetY, pos.Z))
                    g.vy = 0
                    if not world:has(e, Grounded) then
                        world:set(e, Grounded, true)
                    end
                end
            end
        end
    end
end

-- 5) Dynamic sphere-sphere collisions (simple positional solve)
local function collisionSystem(_dt: number)
    clearSpatialGrid()
    -- bin all mobiles
    for e, tf, _ in qColliders do
        addToGrid(e, tf.new.Position)
    end

    -- single-pass positional correction with pair de-dup
    local handled: {[number]: true} = {}
    for e, tf, col in qColliders do
        local p = tf.new.Position
        local r = col.radius
        local neighbors = getNearby(p)

        for i = 1, #neighbors do
            local o = neighbors[i]
            if o ~= e then
                -- ensure each unordered pair is processed once
                local a, b = e, o
                if a > b then
                    a, b = b, a
                end
                local key = ("%d:%d"):format(a, b)
                if not handled[key] and world:has(o, Collider) then
                    handled[key] = true

                    local otf = world:get(o, Transform) :: any
                    local ocol = world:get(o, Collider)  :: any
                    if otf and ocol then
                        local op = otf.new.Position
                        local rr = r + ocol.radius
                        local delta = p - op
                        local dist2 = delta.X*delta.X + delta.Y*delta.Y + delta.Z*delta.Z
                        if dist2 > 0 then
                            local dist = math.sqrt(dist2)
                            if dist < rr then
                                local n = delta / dist
                                local push = (rr - dist) * 0.5 + SKIN_WIDTH
                                -- move both apart
                                p   = p   + n * push
                                op  = op  - n * push
                                tf.new  = setPosPreserveRot(tf.new,  p)
                                otf.new = setPosPreserveRot(otf.new, op)
                            end
                        else
                            -- perfectly overlapping positions; nudge deterministically
                            local n = Vector3.new(1, 0, 0)
                            local push = rr * 0.5 + SKIN_WIDTH
                            p  = p  + n * push
                            tf.new = setPosPreserveRot(tf.new, p)
                        end
                    end
                end
            end
        end
    end
end

-- (Optional) multiple iterations to reduce interpenetration
local function collisionSolve(dt: number)
    for _ = 1, RESOLVE_ITERATIONS do
        collisionSystem(dt)
    end
end


scheduler.SYSTEM(knockbackSystem, phases.Physics)
scheduler.SYSTEM(integrateXZSystem, phases.Physics)
scheduler.SYSTEM(gravitySystem, phases.PhysicsGravity)
scheduler.SYSTEM(groundingSystem,phases.PhysicsTerrain)
scheduler.SYSTEM(collisionSolve, phases.PhysicsCollision)

return {}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002539</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX76673B8E3BDD428D89782B65734E237B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Network</string>
					<string name="ScriptGuid">{60C1F919-E0CD-4563-BCC7-2D06E4207566}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local blink = require(game:GetService("ServerScriptService").net)
local std = ReplicatedStorage.std

local world = require(std.world)
local cts = require(std.components)
local scheduler = require(std.scheduler)
local phases = require(std.phases)
local mailbox = require(std.mailbox)

-- Network constants
local TICK_HZ = 12
local TICK = 1 / TICK_HZ
local FULL_SYNC_INTERVAL = 5
local MAX_BATCH_SIZE = 64

local lastFullSync = 0
local last_accum = 0
local ToSendFull = table.create(128)
local ToSendDelta = table.create(MAX_BATCH_SIZE)

local moving_mobs = world:query(cts.Transform, cts.Velocity, cts.Size):with(cts.Mob):cached()

local function flush(ev, arr)
    if #arr > 0 then 
        ev.FireAll(arr); 
        table.clear(arr) 
    end
end

-- Data store for movements
local function networkSystem(dt: number)
    lastFullSync += dt
    last_accum += dt

    if last_accum < TICK then return end

    last_accum = 0

    table.clear(ToSendDelta)

    mailbox.drain(cts.PendingMovements, function(item)
        ToSendDelta[#ToSendDelta+1] = item
        if #ToSendDelta >= MAX_BATCH_SIZE then
            flush(blink.UpdateTransformDelta, ToSendDelta)
        end
    end)

    -- Full sync logic
    if lastFullSync >= FULL_SYNC_INTERVAL then
        lastFullSync = 0
        table.clear(ToSendFull)
        
        for mob, transform in moving_mobs do
            ToSendFull[#ToSendFull + 1] = { 
                id = mob,
                dp = transform.new.Position
            }
            if #ToSendFull >= 128 then
			blink.UpdateTransformFull.FireAll(ToSendFull)
			table.clear(ToSendFull)
            end
        end

        
        -- Send full state to correct any drift
		if #ToSendFull > 0 then
        	blink.UpdateTransformFull.FireAll(ToSendFull)
			table.clear(ToSendFull)
		end
    else
        if #ToSendDelta > 0 then
            blink.UpdateTransformDelta.FireAll(ToSendDelta)
        end
    end
end

scheduler.SYSTEM(networkSystem, phases.NetworkDelta)

return {}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000253c</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB376143F74924B678D03759E17B5A0FF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SpawnMob</string>
					<string name="ScriptGuid">{F10CB74E-B8D1-4C69-B29D-6DAB6B827D81}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local blink = require(game:GetService("ServerScriptService").net)

local std = ReplicatedStorage.std
local interval = require(std.interval)
local world = require(std.world)
local cts = require(std.components)
local scheduler = require(std.scheduler)
local phases = require(std.phases)

local Transform = cts.Transform
local Speed = cts.Speed
local Velocity = cts.Velocity
local Size = cts.Size
local Mob = cts.Mob
local Gravity = cts.Gravity
local Knockback = cts.Knockback
local Collider = cts.Collider

local Aggressive = cts.Aggressive
local StateMachine = cts.StateMachine
local Wander = cts.Wander
local Patrol = cts.Patrol
local Timer = cts.Timer

local throttle = interval(.1)
local counter = interval(1)
local count = 0

local function randomPosition()
    local angle = math.random() * math.pi * 2
    local radius = math.random(50, 150)
    local x = math.cos(angle) * radius
    local z = math.sin(angle) * radius
    return Vector3.new(x, 20, z)
end

--[[local function spawnSystem()
    if throttle() then

        local e = world:entity()
        local cf = CFrame.new(randomPosition())

        -- Base components
        world:set(e, Transform, { new = cf })
        world:set(e, Velocity, math.random(30, 70))
        world:set(e, Size, math.random(1, 5))
        world:add(e, Mob)

        -- Different mob types
        local mobType = math.random(1, 3)

        if mobType == 1 then
            -- Aggressive chaser
            world:set(e, StateMachine, { 
                current = "idle", 
                states = { idle = {}, chase = {}, attack = {} }
            })
            world:set(e, Wander, {
                center = cf.Position,
                radius = 10,
                nextMove = 0
            })
            world:set(e, Timer, { remaining = 2 })
            
        elseif mobType == 2 then
            -- Patrol guard
            world:set(e, Patrol, {
                points = {
                    cf.Position,
                    cf.Position + Vector3.new(20, 0, 0),
                    cf.Position + Vector3.new(20, 0, 20),
                    cf.Position + Vector3.new(0, 0, 20),
                },
                current = 1,
                wait = 3
            })
            world:set(e, Timer, { remaining = 0 })
            
        else
            -- Peaceful wanderer
            world:set(e, Wander, {
                center = cf.Position,
                radius = 30,
                nextMove = 0
            })
            world:set(e, Timer, { remaining = 1 })
        end
        
        blink.SpawnMob.FireAll(e, cf, world:get(e, Size))
    end
end]]

local function spawnMobs()
	if throttle() then
		local cf = CFrame.new(randomPosition())
		local v = math.random(30, 70) -- Vary speed for more interesting behavior
		local size = math.random(1,5)
		local e = world:entity()

		world:set(e, Size, size)
		world:set(e, Speed, v)
		world:set(e, Transform, { new = cf })
		world:add(e, Mob)
        world:set(e, Gravity,   { vy = 0, enabled = true })
        world:set(e, Collider,  { radius = size })

		blink.SpawnMob.FireAll(e, cf, size)
        count += 1
	end
end

local function countMobs()
    if counter() then
        print("Current mob count:", count)
    end
end

--Spawn mobs on Heartbeat (independent of other systems)
scheduler.SYSTEM(spawnMobs, phases.Heartbeat)
scheduler.SYSTEM(countMobs, phases.Heartbeat)
return {}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000253e</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCEAF4FA347EB4318B2B21D30F69BB586">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Data</string>
					<string name="ScriptGuid">{2535E777-4D95-415D-BBBD-BAF1BC8BDBD6}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local std = ReplicatedStorage.std
local world = require(std.world)
local cts = require(std.components)

local SystemData = world:entity()
world:set(SystemData, cts.PendingMovements, {})
world:set(SystemData, cts.PendingStateChanges, {})

return 0]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002543</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBCB5E3DC80BE4662B7E736ADF32E5822">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">AI</string>
					<string name="ScriptGuid">{88389B51-3264-4859-8CE0-A8DC45DC92C5}</string>
					<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
--!strict

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local std = ReplicatedStorage.std
local world = require(std.world)
local cts = require(std.components)
local scheduler = require(std.scheduler)
local phases = require(std.phases)

local mailbox = require(std.mailbox)
 
local Transform = cts.Transform
local Velocity = cts.Velocity
local StateMachine = cts.StateMachine
local ChaseTarget = cts.ChaseTarget
local Patrol = cts.Patrol
local Wander = cts.Wander
local Aggressive = cts.Aggressive
local Flee = cts.Flee
local Timer = cts.Timer
local Player = cts.Player
local Character = cts.Character
local Mob = cts.Mob

-- Utility functions
local function getPlayerPositions(): {Vector3}
    local targets = {}
    for _, character in world:query(Character):with(Player) do
        local pp = character.PrimaryPart :: Part
        if pp then
            targets[#targets + 1] = pp.Position
        end
    end
    return targets
end

local function findClosestPlayer(position: Vector3, targets: {Vector3}): (Vector3?, number)
    if #targets == 0 then return nil, math.huge end
    
    local closest = nil
    local closestDist = math.huge
    
    for _, target in targets do
        local dist = (target - position).Magnitude
        if dist < closestDist then
            closestDist = dist
            closest = target
        end
    end
    
    return closest, closestDist
end

-- ===== BEHAVIOR SYSTEMS =====

-- Chase Behavior System
local function chaseSystem(dt: number)
    local targets = getPlayerPositions()
    
    for entity, transform, velocity, chase in world:query(Transform, Velocity, ChaseTarget):with(Mob) do
        local position = transform.new.Position
        local closest, distance = findClosestPlayer(position, targets)
        
        if closest then
            if distance <= chase.range then
                -- Start/continue chasing
                chase.target = 1  -- Could store actual player entity
                
                -- Calculate movement
                local direction = (closest - position).Unit
                local speed = velocity
                local movement = direction * speed * dt
                
                -- Don't get too close
                if distance > 3 then
                    transform.new = CFrame.new(position + movement, direction)
                    mailbox.push(cts.PendingMovements, { id = entity, dp = movement })
                end
                
            elseif distance > chase.loseRange then
                -- Lost target
                chase.target = nil
            end
        else
            chase.target = nil
        end
    end
end

-- Patrol Behavior System
local function patrolSystem(dt: number) 
    for entity, transform, velocity, patrol, timer in world:query(Transform, Velocity, Patrol, Timer):with(Mob) do
        local position = transform.new.Position
        
        -- Count down wait timer
        timer.remaining -= dt
        
        if timer.remaining <= 0 then
            -- Move to next patrol point
            local targetPoint = patrol.points[patrol.current]
            local direction = (targetPoint - position)
            local distance = direction.Magnitude
            
            if distance < 2 then
                -- Reached point, move to next
                patrol.current = (patrol.current % #patrol.points) + 1
                timer.remaining = patrol.wait  -- Wait at point
            else
                -- Move toward point
                direction = direction / distance
                local speed = velocity
                local movement = direction * speed * dt
                
                transform.new = CFrame.new(position + movement, direction)
                mailbox.push(cts.PendingMovements, { id = entity, dp = movement })
            end
        end
    end
end

-- Wander Behavior System  
local function wanderSystem(dt: number)
    
    for entity, transform, velocity, wander, timer in world:query(Transform, Velocity, Wander, Timer):with(Mob) do
        local position = transform.new.Position
        
        timer.remaining -= dt
        
        if timer.remaining <= 0 then
            -- Choose new random direction
            local angle = math.random() * math.pi * 2
            local distance = math.random() * wander.radius
            local target = wander.center + Vector3.new(
                math.cos(angle) * distance,
                0, 
                math.sin(angle) * distance
            )
            
            local direction = (target - position)
            if direction.Magnitude > 1 then
                direction = direction.Unit
                local speed = velocity * 0.5  -- Slower wandering
                local movement = direction * speed * dt
                
                transform.new = CFrame.new(position + movement, direction)
                mailbox.push(cts.PendingMovements, { id = entity, dp = movement })
            end
            
            timer.remaining = math.random(2, 5)  -- Next wander
        end
    end
end

-- State Machine System
local function stateMachineSystem()
    for entity, stateMachine in world:query(StateMachine):with(Mob) do
        local currentState = stateMachine.current
        
        -- Example state transitions
        if currentState == "idle" then
            local targets = getPlayerPositions()
            local position = world:get(entity, Transform).new.Position
            local closest, distance = findClosestPlayer(position, targets)
            
            if closest and distance < 15 then
                -- Switch to chase
                stateMachine.current = "chase"
                
                -- Add chase component
                world:set(entity, ChaseTarget, {
                    range = 15,
                    loseRange = 25,
                    target = nil
                })
                
                -- Remove wander if it exists
                world:remove(entity, Wander)
                world:remove(entity, Timer)
            end
            
        elseif currentState == "chase" then
            local chase = world:get(entity, ChaseTarget)
            if not chase or not chase.target then
                -- Lost target, go back to wandering
                stateMachine.current = "wander"
                
                world:remove(entity, ChaseTarget)
                world:set(entity, Wander, {
                    center = world:get(entity, Transform).new.Position,
                    radius = 20,
                    nextMove = 0
                })
                world:set(entity, Timer, { remaining = 1 })
            end
        end
    end
end

--[[Register all systems
scheduler.SYSTEM(stateMachineSystem, phases.AIBehavior)
scheduler.SYSTEM(chaseSystem, phases.AIBehavior)
scheduler.SYSTEM(patrolSystem, phases.AIBehavior)
scheduler.SYSTEM(wanderSystem, phases.AIBehavior)]]


return 0]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300002547</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="316">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">net</string>
				<string name="ScriptGuid">{208BF6C9-0093-4F49-B22C-66B04AD1FB0B}</string>
				<ProtectedString name="Source"><![CDATA[--!strict
--!native
--!optimize 2
--!nolint LocalShadow
--#selene: allow(shadowing)
-- File generated by Blink v0.18.0 (https://github.com/1Axen/Blink)
-- This file is not meant to be edited

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local BASE_EVENT_NAME = "BLINK"
local Invocations = 0

local SendSize = 64
local SendOffset = 0
local SendCursor = 0
local SendBuffer = buffer.create(64)
local SendInstances = {}

local RecieveCursor = 0
local RecieveBuffer = buffer.create(64)

local RecieveInstances = {}
local RecieveInstanceCursor = 0

local Null = newproxy()

type Entry = {
    value: any,
    next: Entry?
}

type Queue = {
    head: Entry?,
    tail: Entry?
}

type BufferSave = {
    Size: number, 
    Cursor: number, 
    Buffer: buffer, 
    Instances: {Instance}
}

local function Read(Bytes: number)
    local Offset = RecieveCursor
    RecieveCursor += Bytes
    return Offset
end

local function Save(): BufferSave
    return {
        Size = SendSize,
        Cursor = SendCursor,
        Buffer = SendBuffer,
        Instances = SendInstances
    }
end

local function Load(Save: BufferSave?)
    if Save then
        SendSize = Save.Size
        SendCursor = Save.Cursor
        SendOffset = Save.Cursor
        SendBuffer = Save.Buffer
        SendInstances = Save.Instances
        return
    end

    SendSize = 64
    SendCursor = 0
    SendOffset = 0
    SendBuffer = buffer.create(64)
    SendInstances = {}
end

local function Invoke()
    if Invocations == 255 then
        Invocations = 0
    end

    local Invocation = Invocations
    Invocations += 1
    return Invocation
end

local function Allocate(Bytes: number)
    local InUse = (SendCursor + Bytes)
    if InUse > SendSize then
        --> Avoid resizing the buffer for every write
        while InUse > SendSize do
            SendSize *= 1.5
        end

        local Buffer = buffer.create(SendSize)
        buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
        SendBuffer = Buffer
    end

    SendOffset = SendCursor
    SendCursor += Bytes
    
    return SendOffset
end

local function CreateQueue(): Queue
    return {
        head = nil,
        tail = nil
    }
end

local function Pop(queue: Queue): any
    local head = queue.head
    if head == nil then
        return
    end

    queue.head = head.next
    return head.value
end

local function Push(queue: Queue, value: any)
    local entry: Entry = {
        value = value,
        next = nil
    }

    if queue.tail ~= nil then
        queue.tail.next = entry
    end

    queue.tail = entry

    if queue.head == nil then
        queue.head = entry
    end
end

local Calls = table.create(256)

local Events: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

local Queue: any = {
    Reliable = table.create(256),
    Unreliable = table.create(256)
}

export type Transform = { id: number, dp: Vector3 }
export type TransformFull = { id: number, dp: Vector3 }
local function WriteEVENT_UpdateTransformDelta(Value: { { id: number, dp: Vector3 } }): ()
	-- Allocate BLOCK: 3 bytes
	local BLOCK_START = Allocate(3)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 0)
	-- START ARRAY
	buffer.writeu16(SendBuffer, BLOCK_START + 1, #Value)
		-- Allocate BLOCK: 8 bytes
	local ARRAY_START_1 = Allocate(8 * #Value)
	for Index = 1, #Value do
		local Item_1 = Value[Index]
		-- Allocate 2
		local OPERATION_OFFSET_0 = ARRAY_START_1
		ARRAY_START_1 += 2
		buffer.writeu16(SendBuffer, OPERATION_OFFSET_0, Item_1.id)
		local Vector = Item_1.dp
		-- Allocate 2
		local OPERATION_OFFSET_1 = ARRAY_START_1
		ARRAY_START_1 += 2
		if Vector.X > 65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_1, 0b0_11111_0000000000)
		elseif Vector.X < -65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_1, 0b1_11111_0000000000)
		elseif Vector.X ~= Vector.X then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_1, 0b1_11111_0000000001)
		elseif Vector.X == 0 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_1, 0)
		else
			local float = Vector.X
			local Abosulte = math.abs(float)
			local Interval = math.ldexp(1, math.floor(math.log(Abosulte, 2)) - 10)
			local RoundedValue = (Abosulte // Interval) * Interval
			local Fraction, Exponent = math.frexp(RoundedValue)
			Exponent += 14
			local Mantissa = math.round(if Exponent <= 0
				then Fraction * 0x400 / math.ldexp(1, math.abs(Exponent))
				else Fraction * 0x800) % 0x400
			local Result = Mantissa
				+ math.max(Exponent, 0) * 0x400
				+ if float < 0 then 0x8000 else 0
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_1, Result)
		end
		-- Allocate 2
		local OPERATION_OFFSET_2 = ARRAY_START_1
		ARRAY_START_1 += 2
		if Vector.Y > 65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_2, 0b0_11111_0000000000)
		elseif Vector.Y < -65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_2, 0b1_11111_0000000000)
		elseif Vector.Y ~= Vector.Y then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_2, 0b1_11111_0000000001)
		elseif Vector.Y == 0 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_2, 0)
		else
			local float = Vector.Y
			local Abosulte = math.abs(float)
			local Interval = math.ldexp(1, math.floor(math.log(Abosulte, 2)) - 10)
			local RoundedValue = (Abosulte // Interval) * Interval
			local Fraction, Exponent = math.frexp(RoundedValue)
			Exponent += 14
			local Mantissa = math.round(if Exponent <= 0
				then Fraction * 0x400 / math.ldexp(1, math.abs(Exponent))
				else Fraction * 0x800) % 0x400
			local Result = Mantissa
				+ math.max(Exponent, 0) * 0x400
				+ if float < 0 then 0x8000 else 0
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_2, Result)
		end
		-- Allocate 2
		local OPERATION_OFFSET_3 = ARRAY_START_1
		ARRAY_START_1 += 2
		if Vector.Z > 65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_3, 0b0_11111_0000000000)
		elseif Vector.Z < -65504 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_3, 0b1_11111_0000000000)
		elseif Vector.Z ~= Vector.Z then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_3, 0b1_11111_0000000001)
		elseif Vector.Z == 0 then
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_3, 0)
		else
			local float = Vector.Z
			local Abosulte = math.abs(float)
			local Interval = math.ldexp(1, math.floor(math.log(Abosulte, 2)) - 10)
			local RoundedValue = (Abosulte // Interval) * Interval
			local Fraction, Exponent = math.frexp(RoundedValue)
			Exponent += 14
			local Mantissa = math.round(if Exponent <= 0
				then Fraction * 0x400 / math.ldexp(1, math.abs(Exponent))
				else Fraction * 0x800) % 0x400
			local Result = Mantissa
				+ math.max(Exponent, 0) * 0x400
				+ if float < 0 then 0x8000 else 0
			buffer.writeu16(SendBuffer, OPERATION_OFFSET_3, Result)
		end
	end
	-- END ARRAY
end

local function WriteEVENT_UpdateTransformFull(Value: { { id: number, dp: Vector3 } }): ()
	
	-- Allocate BLOCK: 3 bytes
	local BLOCK_START = Allocate(3)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 0)
	-- START ARRAY
	buffer.writeu16(SendBuffer, BLOCK_START + 1, #Value)
		-- Allocate BLOCK: 14 bytes
	local ARRAY_START_1 = Allocate(14 * #Value)
	for Index = 1, #Value do
		local Item_1 = Value[Index]
		-- Allocate 2
		local OPERATION_OFFSET_0 = ARRAY_START_1
		ARRAY_START_1 += 2
		buffer.writeu16(SendBuffer, OPERATION_OFFSET_0, Item_1.id)
		local Vector = Item_1.dp
		-- Allocate 4
		local OPERATION_OFFSET_1 = ARRAY_START_1
		ARRAY_START_1 += 4
		buffer.writef32(SendBuffer, OPERATION_OFFSET_1, Vector.X)
		-- Allocate 4
		local OPERATION_OFFSET_2 = ARRAY_START_1
		ARRAY_START_1 += 4
		buffer.writef32(SendBuffer, OPERATION_OFFSET_2, Vector.Y)
		-- Allocate 4
		local OPERATION_OFFSET_3 = ARRAY_START_1
		ARRAY_START_1 += 4
		buffer.writef32(SendBuffer, OPERATION_OFFSET_3, Vector.Z)
	end
	-- END ARRAY
end

local function WriteEVENT_SpawnMob(Value1: number, Value2: CFrame, Value3: number): ()
	-- Allocate BLOCK: 28 bytes
	local BLOCK_START = Allocate(28)
	buffer.writeu8(SendBuffer, BLOCK_START + 0, 1)
	if Value1 > 65504 then
		buffer.writeu16(SendBuffer, BLOCK_START + 1, 0b0_11111_0000000000)
	elseif Value1 < -65504 then
		buffer.writeu16(SendBuffer, BLOCK_START + 1, 0b1_11111_0000000000)
	elseif Value1 ~= Value1 then
		buffer.writeu16(SendBuffer, BLOCK_START + 1, 0b1_11111_0000000001)
	elseif Value1 == 0 then
		buffer.writeu16(SendBuffer, BLOCK_START + 1, 0)
	else
		local float = Value1
		local Abosulte = math.abs(float)
		local Interval = math.ldexp(1, math.floor(math.log(Abosulte, 2)) - 10)
		local RoundedValue = (Abosulte // Interval) * Interval
		local Fraction, Exponent = math.frexp(RoundedValue)
		Exponent += 14
		local Mantissa = math.round(if Exponent <= 0
			then Fraction * 0x400 / math.ldexp(1, math.abs(Exponent))
			else Fraction * 0x800) % 0x400
		local Result = Mantissa
			+ math.max(Exponent, 0) * 0x400
			+ if float < 0 then 0x8000 else 0
		buffer.writeu16(SendBuffer, BLOCK_START + 1, Result)
	end
	local Vector = Value2.Position
	buffer.writef32(SendBuffer, BLOCK_START + 3, Vector.X)
	buffer.writef32(SendBuffer, BLOCK_START + 7, Vector.Y)
	buffer.writef32(SendBuffer, BLOCK_START + 11, Vector.Z)
	local rX, rY, rZ = Value2:ToOrientation()
	buffer.writef32(SendBuffer, BLOCK_START + 15, rX)
	buffer.writef32(SendBuffer, BLOCK_START + 19, rY)
	buffer.writef32(SendBuffer, BLOCK_START + 23, rZ)
	buffer.writeu8(SendBuffer, BLOCK_START + 27, Value3)
end

if not RunService:IsRunning() then
	local NOOP = function() end
	local Returns = table.freeze({
	UpdateTransformDelta = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	UpdateTransformFull = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	SpawnMob = {
		Fire = NOOP,
		FireAll = NOOP,
		FireList = NOOP,
		FireExcept = NOOP
	},
	})
	return Returns :: BLINK_EVENTS_SYMBOL
end

if not RunService:IsServer() then
    error("Server network module can only be required from the server.")
end

local Reliable: RemoteEvent = ReplicatedStorage:FindFirstChild(BASE_EVENT_NAME .. "_RELIABLE_REMOTE") :: RemoteEvent
if not Reliable then
    local RemoteEvent = Instance.new("RemoteEvent")
    RemoteEvent.Name = BASE_EVENT_NAME .. "_RELIABLE_REMOTE"
    RemoteEvent.Parent = ReplicatedStorage
    Reliable = RemoteEvent
end

local Unreliable: UnreliableRemoteEvent = ReplicatedStorage:FindFirstChild(BASE_EVENT_NAME .. "_UNRELIABLE_REMOTE") :: UnreliableRemoteEvent
if not Unreliable then
    local UnreliableRemoteEvent = Instance.new("UnreliableRemoteEvent")
    UnreliableRemoteEvent.Name = BASE_EVENT_NAME .. "_UNRELIABLE_REMOTE"
    UnreliableRemoteEvent.Parent = ReplicatedStorage
    Unreliable = UnreliableRemoteEvent
end

local PlayersMap: {[Player]: BufferSave} = {}

Players.PlayerRemoving:Connect(function(Player)
    PlayersMap[Player] = nil
end)

local function StepReplication()
    for Player, Send in PlayersMap do
        if Send.Cursor <= 0 then
            continue
        end

        local Buffer = buffer.create(Send.Cursor)
        buffer.copy(Buffer, 0, Send.Buffer, 0, Send.Cursor)
        Reliable:FireClient(Player, Buffer, Send.Instances)

        Send.Size = 64
        Send.Cursor = 0
        Send.Buffer = buffer.create(64)
        table.clear(Send.Instances)
    end
end
RunService.Heartbeat:Connect(StepReplication)
Reliable.OnServerEvent:Connect(function(Player: Player, Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
	end
end)
Unreliable.OnServerEvent:Connect(function(Player: Player, Buffer: buffer, Instances: {Instance})
	RecieveCursor = 0
	RecieveBuffer = Buffer
	RecieveInstances = Instances
	RecieveInstanceCursor = 0
	local Size = buffer.len(RecieveBuffer)
	while (RecieveCursor < Size) do
		-- Read BLOCK: 1 bytes
		local BLOCK_START = Read(1)
		local Index = buffer.readu8(RecieveBuffer, BLOCK_START + 0)
	end
end)


local Returns = table.freeze({
	StepReplication = StepReplication,

	UpdateTransformDelta = {
		Fire = function(Player: Player, Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformDelta(Value)
			local Buffer = buffer.create(SendCursor)
			buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
			Unreliable:FireClient(Player, Buffer, SendInstances)
		end,
		FireAll = function(Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformDelta(Value)
			local Buffer = buffer.create(SendCursor)
			buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
			Unreliable:FireAllClients(Buffer, SendInstances)
		end,
		FireList = function(List: {Player}, Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformDelta(Value)
			local Buffer = buffer.create(SendCursor)
			buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
			for _, Player in List do
				Unreliable:FireClient(Player, Buffer, SendInstances)
			end
		end,
		FireExcept = function(Except: Player, Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformDelta(Value)
			local Buffer = buffer.create(SendCursor)
			buffer.copy(Buffer, 0, SendBuffer, 0, SendCursor)
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Unreliable:FireClient(Player, Buffer, SendInstances)
			end
		end,
	},
	UpdateTransformFull = {
		Fire = function(Player: Player, Value: { { id: number, dp: Vector3 } }): ()
			Load(PlayersMap[Player])
			WriteEVENT_UpdateTransformFull(Value)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformFull(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformFull(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value: { { id: number, dp: Vector3 } }): ()
			Load()
			WriteEVENT_UpdateTransformFull(Value)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
	SpawnMob = {
		Fire = function(Player: Player, Value1: number, Value2: CFrame, Value3: number): ()
			Load(PlayersMap[Player])
			WriteEVENT_SpawnMob(Value1, Value2, Value3)
			PlayersMap[Player] = Save()
		end,
		FireAll = function(Value1: number, Value2: CFrame, Value3: number): ()
			Load()
			WriteEVENT_SpawnMob(Value1, Value2, Value3)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireList = function(List: {Player}, Value1: number, Value2: CFrame, Value3: number): ()
			Load()
			WriteEVENT_SpawnMob(Value1, Value2, Value3)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in List do
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
		FireExcept = function(Except: Player, Value1: number, Value2: CFrame, Value3: number): ()
			Load()
			WriteEVENT_SpawnMob(Value1, Value2, Value3)
			local Buffer, Size, Instances = SendBuffer, SendCursor, SendInstances
			for _, Player in Players:GetPlayers() do
				if Player == Except then
					continue
				end
				Load(PlayersMap[Player])
				local Position = Allocate(Size)
				buffer.copy(SendBuffer, Position, Buffer, 0, Size)
				table.move(Instances, 1, #Instances, #SendInstances + 1, SendInstances)
				PlayersMap[Player] = Save()
			end
		end,
	},
})
type BLINK_EVENTS_SYMBOL = typeof(Returns)
return Returns :: BLINK_EVENTS_SYMBOL]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004cf</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBXFA48C960C76F47749586A3323646AFFD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000037a</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBX4148C26677BC4A64BFECE42823DE1698">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a4830000037d</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX63C3217BD67940E99CC81D1923D92A73">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000392</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="0">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<BinaryString name="AttributesSerialize"><![CDATA[AgAAACYAAABSQlhfTGlnaHRpbmdUZWNobm9sb2d5VW5pZmllZE1pZ3JhdGlvbgMBIAAAAFJC
WF9PcmlnaW5hbFRlY2hub2xvZ3lPbkZpbGVMb2FkBAEAAAA=]]></BinaryString>
			<float name="Brightness">2</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<token name="ExtendLightRangeTo120">0</token>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="LightingStyle">1</token>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<bool name="PrioritizeLightingQuality">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000394</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX0E66FA3913B54FC59B963E96CC4A9A83">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="ThrottlePhysicsToRealtime">true</bool>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004f7</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX14253D9C5FEA4BFE90383E082A7CC8F7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a483000004fb</UniqueId>
		</Properties>
	</Item>
	<Item class="VideoService" referent="RBXBE2C5843665B4A6C890F6578B1593E3B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000513</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBXF1412E5298B144FF99B29498C8CA47C5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300000514</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBXF6DCA73DD9714794BB30FFB819BCC005">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxIndicatorsVisible">16</int>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">17af8baad36f8d4e08e5a48300001df0</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>